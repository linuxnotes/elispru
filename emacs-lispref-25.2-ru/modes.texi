@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2017 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@documentencoding UTF-8
@documentlanguage ru
@c@documentencoding UTF-8

@c\usepackage{babel}
@c\usepackage[utf8]{inputenc}
@c\usepackage[russian]{babel}

@node Modes
@chapter Основные и Второстепенные режимы
@cindex mode

  Режим (@dfn{mode}) это набор определений который добавляет в Emacs полезные функции.
Различают 2 вида режимов: второстепенные режимы @dfn{minor modes},
которые предоставляют функции которые можно включить и выключить во время редактирования;
и Основные режимы @dfn{major modes}, которые используются для редактирования или взаимодействия
с определенным видом текста. Буфер может иметь равно один Основной @dfn{major
mode} в каждый момент времени (основной режим можно менять).

Данная глава описывает как писать Основные и Второстепенные режимы, как показывать их
в строке режимов, и как режимы выполняют функции перехватчики (hook) предоставленные пользователем.
Связанные темы раскладки и синтаксические таблицы описаны в разделах:
@ref{Keymaps}, и @ref{Syntax Tables}.

@menu
* Hooks::             Как использовать функции перехватчики; как написать код который предоставляет перехватчики.
* Major Modes::       Определение Основных режимов.
* Minor Modes::       Определение Второстепенных режимов.
* Mode Line Format::  Настройка отображения текста для строки режимов.
* Imenu::             Предоставление menu для определений из буфера.
* Font Lock Mode::    Подсветка синтаксиса в режиме.
* Auto-Indentation::  Как научить Emacs выполнять отступы в Основном режиме.
* Desktop Save Mode:: Как режимы могут сохранять состояние буфера между сессиями Emacs.
@end menu

@node Hooks
@section Hooks Перехватчики (Ловушки)
@cindex hooks

  Перехватчик @dfn{hook} это переменная которая может хранить функцию
или функции, которые могут быть вызваны в определенном случае
выполняемой программой. В Emacs перехватчики используются для
настройки. Как правило, перехватчики задаются в init файле
(@pxref{Init File}), но Lisp программы тоже могут задавать
перехватчики.  В @xref{Standard Hooks}, описывается часть стандартных
переменных перехватчиков.

@cindex normal hook
@cindex Обыкновенный перехватчик
  Большинство перехватчиков являются обыкновенными @dfn{normal
hooks}. Это переменные, которые содержат списки функций вызываемых без
аргументов. По соглашению, если имя перехватчика оканчивается на
@samp{-hook}, это означает что перехватчик является обыкновенным. Мы
пытаемся сделать все перехватчики обыкновенными, насколько это
возможно, чтобы их можно было использовать единообразно.

  Команда каждого основного режима (например list-mode), поддерживает
выполнение обыкновенного перехватчика, называемого перехватчик
@dfn{mode hook}, как часть завершающего шага инициализации. Это
позволяет просто настроить режим переназначив уже заданные для буфера
значения локальных переменных.  (первоначально они устанавливаются
при включении режима, после чего в перехватчике они могут быть
переопределены). Большинство вспомогательных режимов так же выполняют
перехватчик режима при включении. Перехватчики могут использоваться и в другом
контексте. Например перехватчик @code{suspend-hook} выполняется перед
тем как Emacs остановит (suspend) свою работу (@pxref{Suspending Emacs}).

  Рекомендуется добавлять функции перехватчики к перехватчику путем
вызова @code{add-hook} (@pxref{Setting Hooks}). Функция перехватчик
может быть любым из допустимых функций для которых поддерживается
вызов @code{funcall} (@pxref{What Is a Function}). Большинство
переменных обычных перехватчиков имеют начальное значение void; и
@code{add-hook} умеет обрабатывать данную ситуацию. Используя
@code{add-hook} можно добавлять перехватчики как глобально, так и
локально для буфера.

@cindex abnormal hook
@cindex Необычный перехватчик
  Если имя переменной перехватчика не оканчивается на @samp{-hook},
это является признаком того, что данная переменная @dfn{abnormal hook}
(необычный перехватчик).  Это означает, что функции перехватчика
вызываются с аргументами, или их возвращаемые значение каким-то
образом используются. Документация перехватчика описывает как функции
вызываются.  Можно использовать @code{add-hook} для добавления функций
к необычному перехватчику, но функция должна быть написана в
соответствии с соглашением по вызову.  Условлено, что имена для
необычных перехватчиков оканчиваются на @samp{-functions}.

@cindex single-function hook
@cindex перехватчик с одной функцией
Если имя переменной заканчивается на @samp{-function} это значит что
значение переменной просто одна функция, а не список
функций. @code{add-hook} не может быть использована для изменения
таких перехватчиков @emph{single function hook}.  Для изменения таких
перехватчиков нужно использовать @code{add-function} (@pxref{Advising Functions}).

@menu
* Running Hooks::    Как выполнить перехватчик.
* Setting Hooks::    Как поместить и удалить функцию в перехватчик.
@end menu

@node Running Hooks
@node Запуск перехватчиков
@subsection Running Hooks

  В данном разделе рассматривается функция @code{run-hooks}, которая используется
для запуска обыкновенных перехватчиков. А так же функции для запуска
различных видов необычных перехватчиков.

@defun run-hooks &rest hookvars
Функция принимает одно или более имя переменной обычного перехватчика,
и запускает все перехватчики по очереди. Каждый аргумент должен быть
символом который является переменной обычного перехватчика. Аргументы обрабатываются
согласно их порядку.

Если переменная перехватчик non-@code{nil} (не @code{nil}) значение переменной
должно быть списком функций. @code{run-hooks} вызывает все функции по очереди без
аргументов.

Значение переменной перехватчика может быть отдельная функция, как
лямбда выражение так и символ с определенной функцией, которые @code{run-hooks}
вызовет. Но такое использование устарело.

Если переменная перехватчик локальная для буфера, будет использовано локальное
для буфера значение. Но, если локальная переменная содержит элемент @code{t}, то будут
вызваны функции и из глобальной переменной.
@end defun

@defun run-hook-with-args hook &rest args
Данная функция запускает необычные перехватчика путем вызова всех функций перехватчика
@var{hook}, с передачей каждому параметров @var{args}.
@end defun

@defun run-hook-with-args-until-failure hook &rest args
Функция запускает необычный перехватчик путем вызова всех функций
перехватчика по очереди, если какая-то из функций вернет @code{nil}
то, выполнение перехватчика прекратится и оставшиеся функции вызваны
не будут. Каждая функция вызывается с аргументами @var{args}.  Если
функция останавливается из-за того, что какая-то из функций
перехватчика не выполнилась, то функция возвращает @code{nil} иначе
не-@code{nil} значение.
@end defun

@defun run-hook-with-args-until-success hook &rest args
Функция запускает необычный перехватчик путем вызова всех функций
перехватчика по очереди, с остановкой если она из них вернет
не-@code{nil} значение.  Каждая функция вызывается с аргументами
@var{args}.  Если функция остановилась потому что одна из функций
вернула не-@code{nil} значение, то это значение и возвращается, иначе
возвращается @code{nil}.
@end defun

@node Setting Hooks
@node Установка перехватчиков
@subsection Setting Hooks

  Ниже приведет пример использования перехватчика для режима для
включения Auto Fill режима при включении Lisp Interaction режима:

@example
(add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)
@end example

@defun add-hook hook function &optional append local
Функция предоставляет удобный способ добавить функцию @var{function} к
перехватчику @var{hook}.  @var{function} может быть любой Lisp
функцией которая может принимать правильное для @var{hook} количество
аргументов.  Например,

@example
(add-hook 'text-mode-hook 'my-text-hook-function)
@end example

@noindent
добавляет @code{my-text-hook-function} к перехватчику с именем
@code{text-mode-hook}.

Если @var{function} уже есть в перехватчике @var{hook} (сравнение
выполняется с использованием функции @code{equal}), тогда
@code{add-hook} не выполняет второе добавление.

Если @var{function} содержит не-@code{nil} свойство
@code{permanent-local-hook}, тогда @code{kill-all-local-variables}
(или смена основного режима) не будет удалять ее из локальных значений
переменной перехватчика.

Для обычного перехватчика, функции перехватчики должно быть написаны
так, чтобы порядок их вызова не имел значения. Зависимость от порядка
может привести к проблемам.  Однако порядок выполнения предсказуем:
обычно @var{function} помещается в начала списка перехватчика, поэтому
она выполняется первой (barring another @code{add-hook} call). Если
необязательный параметр @var{append} не-@code{nil}, новая функция
перехватчик добавляется в конец списка и выполняется после других.

@code{add-hook} обрабатывает случаи когда @var{hook} void или
значение одна функция, она устанавливает или изменяет значение на
список функций.

Если @var{local} не-@code{nil}, тогда @var{function} добавляется к
локальному для буфера списку перехватчика, а не к глобальному. При
этом создается перехватчик локальный для буфера и добавляется @code{t}
к локальному перехватчику, чтобы вызывались и функции из глобального
(см. run-hook).
@end defun

@defun remove-hook hook function &optional local
Функция удаляет @var{function} из переменной перехватчика
@var{hook}.  Функция сравнивает @var{function} с элементами @var{hook}
используя @code{equal}, поэтому это работает для символов и лямбда выражения.

Если @var{local} не-@code{nil}, то @var{function} удаляется из локального для буфера перехватчика,
а не из глобального списка перехватчика.
@end defun

@node Major Modes
@section Major Modes (Основные режимы)
@cindex major mode
@cindex основной режим

@cindex major mode command
@cindex команда основного режима
  Основной режим настраивает Emacs для редактирования и взаимодействия
с определенным видом текста. Каждый буфер имеет ровно один основной
режим в каждый момент времени. Каждый основной режим связан с
@dfn{major mode command} (командой основного режима), чье имя должно
оканчиваться на @samp{-mode}. Такая команда выполняет переключение на
соответствующий режим текущего буфера, путем установки различных
локальных для буфера переменных таких как локальная раскладка(keymap).
@xref{Major Mode Conventions}. Стоит отметить, что в отличие от
вспомогательных режимов основные режимы не возможно ``выключить'',
можно только переключиться на другой основной режим.

  Наименее специализированный основной режим называется
@dfn{Fundamental mode}, который не содержит каких-то определений или
настроек переменных.

@deffn Command fundamental-mode
Это команда переключения в основной режим Fundamental. В отличие от
других команд режимов, она @emph{не} запускает никаких перехватчиков
(@pxref{Major Mode Conventions}), поскольку не предполагается
настройка данного режима.
@end deffn

Проще всего создать основной режим, если воспользоваться макросом
@code{define-derived-mode}, который создаст новый режим как вариант
уже существующего основного режима. @xref{Derived
Modes}. Рекомендуется использовать @code{define-derived-mode} даже в
том случае если новый режим не является очевидной производной другого
режима, так как макрос автоматически обеспечивает выполнения множества
соглашений по кодированию. @xref{Basic Major Modes}, for common modes
to derive from.

Стандартное дерево каталогов GNU Emacs Lisp содержит код для нескольких
основных режимов, в таких файлах как @file{text-mode.el},
@file{texinfo.el}, @file{lisp-mode.el}, и @file{rmail.el}. Вы можете
изучить эти библиотеки, чтобы разобраться как пишутся режимы.

@defopt major-mode
Локальное для буфера значение данной переменной хранит символ текущего
основного режима. Значением по умолчанию является режим по умолчанию
для новых буферов. Обычное значение по умолчанию
@code{fundamental-mode}.

Если значение по умолчанию @code{nil}, тогда при создании нового буфера,
например с таким образом @kbd{C-x b} (@code{switch-to-buffer}), для нового
буфера устанавливается основной режим такой же как у предыдущего выбранного буфера.
За исключением случаев, если символ основного режима предыдущего буфера содержит
свойство @code{mode-class} со значением @code{special}, тогда для нового буфера
основным режимом выставляется Fundamental (@pxref{Major Mode Conventions}).
@end defopt

@menu
* Major Mode Conventions::  Соглашения по кодированию .
* Auto Major Mode::         Как Emacs автоматически выбирает основной режим.
* Mode Help::               Получение справки по использованию режима.
* Derived Modes::           Определение основного режима на основе другого основного режима.
* Basic Major Modes::       Режимы на основе которых наиболее часто строятся другие режимы.
* Mode Hooks::              Перехватчики запускаемые в конце функций режимов.
* Tabulated List Mode::     Родительский режим для буферов с табличными данными..
* Generic Modes::           Определение простого основного режима с поддержкой комментариев
                            и Font Lock режимом (режим выполняющий подсветку некоторых конструкций).
* Example Major Modes::     Текстовые и Lisp режимы.
@end menu

@node Major Mode Conventions
@node Соглашения по основным режимам
@subsection Major Mode Conventions
@cindex major mode conventions
@cindex соглашения по основным режимам
@cindex conventions for writing major modes
@cindex соглашения по написанию основных режимов

  Код каждого основного режима должен следовать ряду соглашений,
включающих соглашения по инициализации локальной раскладки (local
keymap) и синтаксической таблицы (syntax table), именах функций,
переменных, и перехватчиков.

  Если используется @code{define-derived-mode}, он берет на себя заботу о
выполнении многих из соглашений автоматически. @xref{Derived Modes}. Отметим
также, что режим Fundamental является исключением для многих из соглашений,
потому что представляет состояние Emacs по умолчанию.

Далее приводится частичный список соглашений. Каждый основной режим
должен стремиться к согласованности с остальными основными режимами, так
как это делает Emacs в целом более последовательным и понятным. Не возможно
перечислить все возможные моменты где могут возникнуть вопросы согласованности;
в случае если разработчики Emacs укажут где ваш режим отклоняется от соглашений,
пожалуйста сделайте свой режим совместимым.

@itemize @bullet
@item
Определяйте команду основного режима оканчивающейся на @samp{-mode}.
Вызываемая без аргументов команда должна переключать текущий буфер в в
новый режим устанавливая раскладку (keymap), синтаксическую таблицу, и
локальные для буфера переменные. Команда не должна изменять содержимое
буфера.

@item
Напишите комментарий(документацию) для команды, которая описывает команды доступные в
данном режиме. @xref{Mode Help}.

Строка документации может включать особые подстроки, @samp{\[@var{command}]},
@samp{\@{@var{keymap}@}}, и
@samp{\<@var{keymap}>}, которые позволяют справке автоматически определять и показывать
пользовательские настройки привязки клавиш.  @xref{Keys in
Documentation}.

@item
Команда основного режима должна начинаться вызовом
@code{kill-all-local-variables}.  Который запускает обычный перехватчик
@code{change-major-mode-hook}, который уничтожает переменные буфера предыдущего
основного режима.  @xref{Creating Buffer-Local}.

@item
Команда основного режима должна присвоить переменной @code{major-mode}
символ команды основного режима. На основе этого значения @code{describe-mode}
определяет какая документация должна быть показана.

@item
Команда основного режима должна присвоить переменной @code{mode-name}
``удобное''(``pretty'') название режима, обычно являющееся строкой
(см. @ref{Mode Line Data}, с описание других возможных вариантов).
Это имя режима будет отображаться в строке режима.

@item
@cindex functions in modes
@cindex функции в режимах
Поскольку все глобальные имена находятся в одном пространстве имен, все
глобальные переменные, константы, и функции которые относятся к режиму должны
иметь имена, которые начинаются с имени режима (или с его сокращения если имя
длинное). @xref{Coding Conventions}.

@item
В основном режиме предназначенном для редактирования структурированного текста,
например программ, отступы соответствующие структуре вероятно будет полезными.
Поэтому стоит установит для @code{indent-line-function} переменной подходящее
значение, и вероятно настроить другие переменные отвечающие
за расстановку отступов. @xref{Auto-Indentation}.

@item
@cindex keymaps in modes
@cindex привязки клавиш в режимах
Основной режим как правило должен иметь свою собственную раскладку, которая
используется как локальная для всех буферов с данным режимом. Команда
основного режима должная вызывать @code{use-local-map} для установки
локальной раскладки. @xref{Active Keymaps} для получения
более полной информации.

Данная раскладка должна быть перманентно загруженной в глобальной
переменной с именем @code{@var{modename}-mode-map}. Как правило библиотека
определяющая режим устанавливает эту переменную.

@xref{Tips for Defining}, для получения советов по установки
значения переменной отвечающей за раскладку в режиме.

@item
Комбинации клавиш в основном режиме обычно должно начинаться с
@kbd{C-c}, за которым следует контрольный символ или цифра, или @kbd{@{},
@kbd{@}}, @kbd{<}, @kbd{>}, @kbd{:} или и@kbd{;}. Другие символы пунктуации
зарезервированы для второстепенных режимов, и обычные буквы зарезервированы
для пользователей.

Основной режим можно так же переназначить @kbd{M-n}, @kbd{M-p} и
@kbd{M-s}. Привязки @kbd{M-n} и @kbd{M-p} должны быть разновидностями
движения вперед и назад, что однако, не обязательно означает перемещение
курсора.

В основном режиме допускается переопределение стандартных комбинаций
если предоставляемые команды делают схожие действия но более подходят
для текста с которым должен работать режим. Например, основной режим
для редактирования программ может переопределить @kbd{C-M-a} для перехода
в начало функции способом который подходит для редактируемого языка.

Кроме того допускается переопределять редко используемые в данном
режиме клавиши. Например, режим минибуфера переопределяет @kbd{M-r},
чье обычное назначение (прим. @code{move-to-window-line-top-bottom})
редко может быть использовано в минибуфере. Основные режимы такие как
Dired или Rmail которые не выполняют непосредственную работу с текстом
могут вполне обосновано переопределять буквы и другие печатные символы
для выполнения команд.

@item
Основные режимы для редактирования текста не должны определять для @key{RET}
действия отличные от вставки новой строки. Однако, вполне нормально для
специальных режимов в которых не выполняется редактирование текста, таких
как Dired, переопределить @key{RET} для выполнения совершенно
других действий.

@item
Основной режим не должен изменять параметр, которые должен определить
пользователь в соответствии со своими предпочтениями, такие как
использование Auto-Fill режима. Оставьте это на усмотрение пользователя.
Однако, основной режим должен настроить другие переменные таким образом,
чтобы режим Auto-Fill был полезен в случае @emph{если} (@emph{if}) пользователь
решит его использовать.

@item
@cindex syntax tables in modes
@cindex синтаксические таблицы в режимах
Режим может использовать свою собственную синтаксическую таблицу или
использовать общую вместе с другими связанными режимами. Если режим
имеет собственную таблицу, то она должна хранится в переменной
@code{@var{modename}-mode-syntax-table}.  @xref{Syntax Tables}.

@item
В режимах для языков которые содержат комментарии, нужно установить
переменные которые определяют синтаксис комментариев. @xref{Options for
Comments,, Options Controlling Comments, emacs, The GNU Emacs Manual}.

@item
@cindex abbrev tables in modes
@cindex Таблицы сокращений в режимах
Режим может содержать свою таблицу сокращений или использовать общую с
другими связанными режимами. Если режим имеет собственную таблицу, то
она должна хранится в переменной  @code{@var{modename}-mode-abbrev-table}.
Если команда основного режима определяет какие-то сокращения должен быть
установлен в @code{t} аргумент флаг @var{system-flag} функции
@code{define-abbrev} используемой для определения сокращений.
@xref{Defining Abbrevs}.

@item
Режим должен определять как подсвечивать режим Font Lock, путем
установки локальной для буфера переменной @code{font-lock-defaults}
(@pxref{Font Lock Mode}).

@item
Каждый начертание шрифта(face, дальше просто начертание) который
определят режим, должен наследоваться, если это возможно, от
существующего в Emacs начертания.
@xref{Basic Faces}, и @ref{Faces for Font Lock}.

@item
Режим должен определить как Imenu будет находить определение разделов
буфера, путем установки локальной (для буфера) переменных
@code{imenu-generic-expression}, и
@code{imenu-prev-index-position-function} и
@code{imenu-extract-index-name-function} или переменной
@code{imenu-create-index-function} (@pxref{Imenu}).

@item
Режим может задать локальное значение для @code{eldoc-documentation-function},
чтобы определить как режим ElDoc будет обрабатывать данный режим.

@item
Режим может определить как завершать разные ключевые слова добавив один или
более локальных перехватчиков в специальный перехватчик
@code{completion-at-point-functions}.  @xref{Completion in Buffers}.

@item
@cindex buffer-local variables in modes
@cindex локальные (для буфера) переменные в режимах
Что бы сделать переменную локальной для буфера, следует использовать
@code{make-local-variable} в основной функции режима, а не
@code{make-variable-buffer-local}. @code{make-variable-buffer-local}
делает переменную локальной для всех буферов в которых она устанавливается,
что будет влиять и на буферы в других режимах. Такой глобальный эффект
является не желательным для режима. @xref{Buffer-Local Variables}.

За редким исключением, единственный оправданный способ использования
@code{make-variable-buffer-local} в Lisp пакете для переменных, которые
используются только в этом пакете. Использование этой функции на переменных
используемых другими пакетами может приводить к конфликтам.

@item
@cindex mode hook
@cindex major mode hook
@cindex перехватчик режима
@cindex основной перехватчик режима
Каждый основной режим должен иметь нормальный  @dfn{mode hook} с именем
@code{@var{modename}-mode-hook}. В конце команда режима должна вызывать
команда @code{run-mode-hooks}. Которая вызывает обыкновенный перехватчик
@code{change-major-mode-after-body-hook}, перехватчик режима, после которого
нормальный перехватчик @code{after-change-major-mode-hook}.
@xref{Mode Hooks}.

@item
Команда основного режима может может начинаться с вызова нескольких
команд других основных режимов (называемых @dfn{parent mode} родительские)
после чего изменить некоторые из их настроек. Выполняющий это ражим
называется @dfn{derived mode} (дочерний). Рекомендуется, но не требуется
делать дочерние режимы путем использования макроса
@code{define-derived-mode}. Такой режим должен вызывать команду родительского
режима внутри формы @code{delay-mode-hooks}. (При использовании
@code{define-derived-mode} это делается автоматически.) @xref{Derived
Modes}, and @ref{Mode Hooks}

@item
В случае необходимости выполнения каких-то специфичных действий при
переключении на другой режим, данный режим должен установить локальную
(для буфера) переменную @code{change-major-mode-hook}
(@pxref{Creating Buffer-Local}).

@item
Если режим предназначен для работы только со специальным текстом созданным
самим режимом (не как обычно набранного пользователем или внешнего файла),
тогда для символа команды основного режима должно быть задано свойство
@code{mode-class} со значением @code{special}.
Код для задания:

@kindex mode-class @r{(property)}
@cindex @code{special} modes
@example
(put 'funny-mode 'mode-class 'special)
@end example

@noindent
Таким образом указав Emacs, что новые буферы созданные из буфера в режиме
Funny mode не нужно запускать в режиме Funny mode, даже если значение
по умолчанию свойства @code{major-mode}  @code{nil}. Значение
@code{nil} для свойства @code{major-mode} предполагает использование
основного режима текущего буфера при создании новых буферов
(@pxref{Auto Major Mode}), но для специальных
@code{special} режимов вместо этого используется Fundamental mode.
Режимы такие как Dired, Rmail, и Buffer List используют данную особенность.

Функция @code{view-buffer} не включает дополнительный режим View для
буферов у которых mode-class задан как special, потому что такие режимы
обычно предоставляют свои привязки для просмотра (см. View mode).

Макрос @code{define-derived-mode} автоматически помечает дочерний режим
как специальный если родительский режим специальный.
@xref{Basic Major Modes}.

@item
С помощью добавления элемента в @code{auto-mode-alist}
можно задать определения имен файлов для которых режим будет
использоваться по умолчанию (@pxref{Auto Major Mode}). Если
режим загружается через autoload, нужно поместить добавление
элемента в @code{auto-mode-alist}, в тот же файл где вызывается @code{autoload}.
Если используются autoload cookie для команды режима, так же нужно использовать
autoload cookie для формы добавления элемента (@pxref{autoload cookie}).
Если autoload не используется, добавление в @code{auto-mode-alist} можно
выполнить в файле с определением режима.

@item
@cindex mode loading
@cindex Загрузка режима
Форма первого уровня (top-level) файла в котором определяется режим,
должна позволять многократное выполнение без негативных последствий.
Например, стоит использовать @code{defvar} или @code{defcustom} для установки
переменных режима, таким образом значения переменных не будут переопределены
если они уже имеют значения (@pxref{Defining Variables}).

@end itemize

@node Auto Major Mode
@node Автоматический выбор основного режима
@subsection How Emacs Chooses a Major Mode
@subsection Как Emacs выбирает основной режим
@cindex major mode, automatic selection
@cindex основной режим, автоматический выбор

Когда Emacs открывает файл, оно автоматически выбирает основной режим
основываясь на информации об имени файла или информации в самом файле.
Также обрабатываются локальные переменные определенные в тексте файла.

@deffn Command normal-mode &optional find-file
Функция устанавливает подходящий основной режим и значение локальных переменных
для текущего буфера. В этой функции сначала вызывается @code{set-auto-mode}
(см. ниже), затем запускается функция @code{hack-local-variables}, которая
разбирает и затем связывает или вычисляет локальные переменные файла
(@pxref{File Local Variables}).

Если значение параметра @var{find-file} функии @code{normal-mode} не @code{nil},
тогда @code{normal-mode} считает, что она была вызвана из @code{find-file} и в этом
случае выполняется обработка локальных переменных в @samp{-*-} и в конце файла.
Переменная @code{enable-local-variables} включает или выключает данный
функционал. @xref{File
Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}, для получения
информации по синтаксису секции описания локальных переменных.

В случае интерактивного запуска @code{normal-mode}, аргумент @var{find-file}
по умолчанию @code{nil}. В этом случае @code{normal-mode} безусловно
обрабатывает все локальные переменные файла.

Функция вызывает @code{set-auto-mode} для выбора основного режима.
Если режим не был определен, основной режим остается равным значению
основного режима по умолчанию @code{major-mode} см. ниже.

@cindex file mode specification error
@cindex Ошибка определения основного режима
@code{normal-mode} вызывает команду режима внутри @code{condition-case}, поэтому
ошибки ловятся и о них сообщается как @samp{File
mode specification error} следующей за полученным сообщением об ошибке.
@end deffn

@defun set-auto-mode &optional keep-mode-if-same
@cindex visited file mode
@cindex режим для посещенного файла
 Функция выбирает основной режим который подходит для текущего буфера.
Выбор основывается на (в порядке предшествования) строке @w{@samp{-*-}},
на любой @samp{mode:} (используется @code{interpreter-mode-alist}) в
районе завершения файла, @w{@samp{#!}}
(используется @code{magic-mode-alist}) в тексте в начале файла, и
в заключение имени файла (используется auto-mode-alist). @xref{Choosing Modes, ,
How Major Modes are Chosen, emacs, The GNU Emacs Manual}. Если @code{enable-local-variables}
равно @code{nil}, @code{set-auto-mode} не проверяет @w{@samp{-*-}} или окончание файла, для
любого тега режима. (TODO: тут перевод не очень получился)

@vindex inhibit-local-variables-regexps
Для некоторых типов файлов не выполняется сканирование содержимого
для определения режима. Например, tar архив может содержать файл,
который имеет секцию с локальными переменными в конце, определяющими
режим для этого файла. Но они не будут применены ко всему tar файлу.
Аналогично, tiff файл изображения может иметь первую строку соответствующую
шаблону @w{@samp{-*-}}. По этой причини, файлы с таким расширением находятся
в списке @code{inhibit-local-variables-regexps}. Добавление шаблона в этот
список предотвращает поиск Emacs-ом поиск локальных переменных (не только
определяющих режима) в файлах соответствующих шаблону.

Если переменная @var{keep-mode-if-same} не @code{nil}, функция не
вызывает команду режима если буфер уже имеет подходящий основной режим.
Например @code{set-visited-file-name}, выставляет данную переменную в
@code{t}, чтобы предотвратить уничтожение локальных переменных, которые
пользователь мог установить
@end defun

@defun set-buffer-major-mode buffer
Функция устанавливает основной режим @var{buffer} в значение по умолчанию
определяемое @code{major-mode}; если оно @code{nil}, используется
основной режим текущего режима (если он подходит). Если имя буфера
@file{*scratch*}, то для него устанавливается режим определяемый значением
@code{initial-major-mode}.

Низкоуровневые простые функции для создания буфера не используют
это функцию, но команды среднего уровня такие как @code{switch-to-buffer} и
@code{find-file-noselect} используют ее как только они создадут
буфер.
@end defun

@defopt initial-major-mode
@cindex @file{*scratch*}
Значение этой переменной определяет основной режим буфера @file{*scratch*}.
Значение должно быть символом который является командой основного
режима. Значение по умолчанию @code{lisp-interaction-mode}.
@end defopt

@defvar interpreter-mode-alist
Переменная определяет основной режим, который будет использоваться для
скриптов для которых задан командный интерпретатор в @samp{#!} строке.
Переменная представляет собой ассоциативный список (alist) с элементами
в форме @code{(@var{regexp} . @var{mode})}, что указывает использовать
режим @var{mode} если в файле указано использование интерпретатора,
удовлетворяющее регулярному выражению @code{\\`@var{regexp}\\'}. Например
по умолчанию есть такое соответствие: @code{("python[0-9.]*" . python-mode)}.
@end defvar

@defvar magic-mode-alist
Значением переменной является ассоциативный список (alist) в форме:
@code{(@var{regexp} .  @var{function})}.
@var{regexp} - регулярное выражение,
@var{function} - функция или @code{nil}.
При посещении файла (открытии) @code{set-auto-mode} вызывает @var{function}
если текст в начале буфера удовлетворяет @var{regexp} и функция
@var{function} не-@code{nil}, если @var{function} @code{nil}, то
режим определяется на основе значения переменной @code{auto-mode-alist}.
@end defvar

@defvar magic-fallback-mode-alist
Данная переменная работает так же как @code{magic-mode-alist}, за исключением
того что она используется только если @code{auto-mode-alist} не определило
режим для данного файла.
@end defvar

@defvar auto-mode-alist
Переменная содержит ассоциативный список @code{(@var{regexp} .  @var{mode-function})},
@code{(@var{regexp} - регулярное выражение,
    которому должно удовлетворять имя файла.
@var{mode-function})} - функция режима которая будет выполнена если
имя соответствует регулярному выражению.
Как правило @code{(@var{regexp}} проверяет расширение имени файла,
например @samp{.el} или @samp{.c}, но не обязательно.

Например,

@smallexample
@group
(("\\`/tmp/fol/" . text-mode)
 ("\\.texinfo\\'" . texinfo-mode)
 ("\\.texi\\'" . texinfo-mode)
@end group
@group
 ("\\.el\\'" . emacs-lisp-mode)
 ("\\.c\\'" . c-mode)
 ("\\.h\\'" . c-mode)
 @dots{})
@end group
@end smallexample

Когда открывается файла чье полное имя (@pxref{File Name
Expansion}) с удаленными номерами версии и расширениями резервных копий
@code{file-name-sans-versions} (@pxref{File Name Components}), соответствует
регулярному выражению @var{regexp}, @code{set-auto-mode} вызывает
соответствующую @var{mode-function}. Данная способность позволяет Emacs
выбирать подходящий режим для большинства файлов.

Если элемент списка @code{auto-mode-alist} имеет форму @code{(@var{regexp}
@var{function} t)}, тогда после вызова функции @var{function}, Emacs
выполняет поиск в @code{auto-mode-alist} снова, для получения соответствия
для части имени файла которая не могла совпасть ранее.
Данная возможность полезна например для пакетов архивов, запись @code{("\\.gz\\'"
@var{function} t)} позволяет распаковать файл и открыть распакованный файл
в режиме соответствующем части перед @samp{.gz}.

Пример создания правил задания режимов @code{auto-mode-alist}:
(Такие выражения можно использовать в init файле)

@smallexample
@group
(setq auto-mode-alist
  (append
   ;; @r{File name (within directory) starts with a dot.}
   '(("/\\.[^/]*\\'" . fundamental-mode)
     ;; @r{File name has no dot.}
     ("/[^\\./]*\\'" . fundamental-mode)
     ;; @r{File name ends in @samp{.C}.}
     ("\\.C\\'" . c++-mode))
   auto-mode-alist))
@end group
@end smallexample
@end defvar

@node Mode Help
@node Справка по режиму
@subsection Getting Help about a Major Mode
@cindex mode help
@cindex help for major mode
@cindex documentation for major mode
@cindex справка по режиму
@cindex помощь по основному режиму
@cindex документация по основному режиму

Функция @code{describe-mode} предоставляет информацию по
основному режиму. Как правило она вызывается комбинацией @kbd{C-h m}.
Функция использует значение переменной @code{major-mode} (@pxref{Major Modes}).
Поэтому каждая команда основного режима должна устанавливать эту переменную.

@deffn Command describe-mode &optional buffer
Команда отображает документацию по основному и вспомогательным режимам
текущего буфера. Команда использует функцию @code{documentation} для
нахождения строк документации команд основного и вспомогательных режимов
@pxref{Accessing Documentation}).

Если вызывается из Lisp cо значением аргумента @var{buffer} не-@code{nil},
функция отображает документацию для основного и вспомогательного режимов
указанного буфера, а не текущего буфера.
@end deffn

@node Derived Modes
@node Дочерние режимы
@subsection Defining Derived Modes
@cindex derived mode
@cindex дочерние режимы

  Рекомендуемым способом определения основного режима является создание
дочернего режима для одного из уже существующих с использованием
@code{define-derived-mode}. В случае если нет подходящего режима, стоит
наследоваться от @code{text-mode}, @code{special-mode}, или @code{prog-mode}.
@xref{Basic Major Modes}. Если и не один из этих режимов не подходит
стоит наследоваться от @code{fundamental-mode} (@pxref{Major Modes}).

@defmac define-derived-mode variant parent name docstring keyword-args@dots{} body@dots{}
Макрос определяет @var{variant} как команду основного режима,
используя @var{name} в качестве имени режима. @var{variant} и @var{parent} должны
быть символами без кавычки (без цитирования).

Новая команда @var{variant} определяется как вызов функции родителя
@var{parent} с последующем переопределением некоторых частей
родительского режима:

@itemize @bullet
@item
Новый режим имеет пустую раскладку, которая называется
@code{@var{variant}-map}. @code{define-derived-mode} задает
раскладку родительского режима, родителем новой раскладки, если
только @code{@var{variant}-map} еще не задан и уже имеет родителя.

@item
Новый режим содержит свою собственную синтаксическую таблицу,
хранящуюся в переменной @code{@var{variant}-syntax-table}, если
только она не переопределяется явно с использованием ключевого
слова @code{:syntax-table} (см. ниже). Команда @code{define-derived-mode}
устанавливает родителя синтаксической таблицы равным синтаксической
таблице родительского режима, если только @code{@var{variant}-syntax-table}
еще не установлена и не содержит родителя отличающегося от стандартного.

@item
Новый режим содержит свою таблицу аббревиатур(abbrev table), хранящуюся
в @code{@var{variant}-abbrev-table}, если ее не переопределили с использованием
ключевого слова @code{:abbrev-table} (см. ниже).

@item
Новый режим содержит свой перехватчик (mode hook), @code{@var{variant}-hook}.
Режим запускает этот перехватчик после перехватчиков предков, используя
@code{run-mode-hooks}, в конце выполнения команды режима. @xref{Mode Hooks}.
@end itemize

Кроме того можно переопределить другие части родителей @var{parent}
используя @var{body}. Команда @var{variant} выполняет формы (выражения)
@var{body} после установки всех обычных переопределений, непосредственно
перед вызовом перехватчиков (hooks).

Если @var{parent} содержит non-@code{nil} @code{mode-class} свойство
символа, тогда @code{define-derived-mode} устанавливает @code{mode-class}
свойство @var{variant} в это же значение. Это позволяет обеспечить, например то,
что если @var{parent} специальный режим, то и @var{variant} будет специальным
режимом (@pxref{Major Mode Conventions}).

Можно также задать значение @var{parent} равным @code{nil}. Что приведет
к создания нового режима без родителя. Тогда @code{define-derived-mode}
все равно будет действовать как описано выше, при этом пропуская действия
связанные с родителем (@var{parent}).

Аргумент @var{docstring} определяет строку документации для нового режима.
@code{define-derived-mode} добавляет общую информацию о перехватчиках и раскладках
режима, в конец данной строки документации. Если пропустить @var{docstring},
@code{define-derived-mode} сгенерирует строку документации.

@var{keyword-args} это пары ключ значение. Значения вычисляются.
Поддерживаются следующие ключевые слова:

@table @code
@item :syntax-table
Аргумент позволяет явно задать синтаксическую таблицу для нового режима.
Если значение @code{nil}, новый режим будет использовать ту же таблицу
синтаксиса что и @var{parent} или стандартную таблицу синтаксиса если
@var{parent} тоже @code{nil}. (Заметьте что это @emph{не} соответствует
соглашению для не ключевых слов, для которых значение @code{nil} равносильно
отсутствию аргумента).

@item :abbrev-table
Аргумент позволяет явно задать таблицу аббревиатур для нового режима.
Если задать значение @code{nil}, новый режим будет использовать
туже таблицу что и режим родитель(@var{parent}) или
@code{fundamental-mode-abbrev-table}
если @var{parent} тоже @code{nil}. (Снова значение @code{nil} @emph{не}
соответствует отсутствию аргумента).

@item :group
Если значение задано, то оно должно быть группой настройки(customization group).
Не у всех режимов такая группа есть. Команда @code{customize-mode} использует
данную переменную. @code{define-derived-mode} @emph{не} задает
по умолчанию данную переменную.
@end table

Предположительный пример:

@example
(defvar hypertext-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [down-mouse-3] 'do-hyper-link)
    map))

(define-derived-mode hypertext-mode
  text-mode "Hypertext"
  "Major mode for hypertext."
  (setq-local case-fold-search nil))
@end example

Не стоит писать @code{interactive} в определении, @code{define-derived-mode}
добавит его автоматически.
@end defmac

@defun derived-mode-p &rest modes
Функция возвращает не-@code{nil} если текущий основной режим
является дочерним к режиму заданному символами @var{modes}.
@end defun

@node Basic Major Modes
@node Базовые основные режимы
@subsection Basic Major Modes

Кроме Fundamental, есть три основных режима которые другие основные
режимы используют как родительские: Text, Prog и Special режимы.
В отличие от Text режима, который сам является режимом для файлов
с расширением @file{.txt}, Prog и Special предназначены главным
образом для того, чтобы другие режимы могли наследоваться от них.

@vindex prog-mode-hook
  Там где это возможно, новые основные режимы должны быть дочерними напрямую
или нет для этих трех режимов. Одной из причин для этого является возможность
настройки пользователем одного и того же перехватчика режима,
  As far as possible, new major modes should be derived, either directly
or indirectly, from one of these three modes.  One reason is that this
allows users to customize a single mode hook (например, @code{prog-mode-hook})
для всего семейства соответствующего режиму (например, для всех режимов работы с языками программирования).

@deffn Command text-mode
Режим Text, является основным режимом для редактирования текстов естественных языков
(human languages). Он определяет символы @samp{"} и @samp{\} как символы
пунктуации (@pxref{Syntax Class Table}) и задана привязка @kbd{M-@key{TAB}} для
@code{ispell-complete-word} автодополнения (@pxref{Spelling,,, emacs, The GNU Emacs
Manual})

HTML режим является примером режима дочернего к Text.
@xref{HTML Mode,,SGML and HTML Modes, emacs, The GNU Emacs Manual}.
@end deffn

@deffn Command prog-mode
Режим Prog является базовым для режимов редактирования исходных кодов
на различных языках программирования. Большинство режимов Emacs являются
наследниками данного режима.

Режим Prog делает устанавливает @code{parse-sexp-ignore-comments} в @code{t}
(@pxref{Motion via Parsing})
и @code{bidi-paragraph-direction} в @code{left-to-right}
(@pxref{Bidirectional Display}).
@end deffn

@deffn Command special-mode
Режим Special является основным режимом для буферов текст в которым
специальным образом генерируется самим Emacs-ом, а не берется из файла
(например dired)
Основные являющиеся дочерними к Special имеют свойство @code{mode-class}
равное @code{special} (@pxref{Major Mode Conventions}).

Режим Special устанавливает буфер в режим только чтение (read-only).
Таблица привязки клавиш (keymap) определяет несколько общих привязок,
таких как @kbd{q} - @code{quit-window} и @kbd{g} - @code{revert-buffer}.
(@pxref{Reverting}).


Например Buffer Menu является основном режимом дочерним к Special.
Данный режим используется буфером @file{*Buffer List*}. @xref{List
Buffers,,Listing Existing Buffers, emacs, The GNU Emacs Manual}.
@end deffn

  Режимы с табличными данными могут наследоваться от режима Tabulated List,
который в свою очередь является дочерним для Special режима.
@xref{Tabulated List Mode}.

@node Mode Hooks
@node Перехватчики режима
@subsection Mode Hooks

Каждая команда основного режима должна заканчиваться запуском не зависимым от
режима обычным перехватчиком @code{change-major-mode-after-body-hook}, вызовом
перехватчиком режима и вызовом обычного перехватчика @code{after-change-major-mode-hook}.
Что выполняется через вызов @code{run-mode-hooks}. Если основной режим
является дочерним, тогда команда вызывает родительский основной режим в
теле команды режима, вызов делается через @code{delay-mode-hooks}, чтобы родитель
не вызвал свои перехватчики самостоятельно. При это в дочернем режиме при
вызове @code{run-mode-hooks} выполняются перехватчики родительских режимов тоже.
Таким образом выполняются сначала все body режимом, потом перехватчики режимов.
@xref{Major Mode Conventions}.

  Emacs версий до 22, не имел @code{delay-mode-hooks}.
Версии до 24 не имеют @code{change-major-mode-after-body-hook}.
Когда пользовательские основные режимы не используют @code{run-mode-hooks} и
не были обновлены для использования этих новых возможностей, они не полностью
соответствуют текущим соглашениям, они могут запустить родительский перехватчик
слишком рано или не запустить @code{after-change-major-mode-hook}. В случае
использования или встречи с таким режимом рекомендуется исправить его.

При определении основного режима с использованием @code{define-derived-mode},
указанные соглашения соблюдаются автоматически. Если же режим определяется
в ручном режима (``by hand``), без использования @code{define-derived-mode},
стоит использовать следующие функции для автоматического выполнения соглашений.

@defun run-mode-hooks &rest hookvars
Основной режим должен выполнять свои перехватчики используя эту функцию.
Функция схожа с @code{run-hooks} (@pxref{Hooks}), но она так же запускает
@code{change-major-mode-after-body-hook} и
@code{after-change-major-mode-hook}.

Когда функция вызывается в рамкам выполнения формы @code{delay-mode-hooks},
она не выполняет перехватчики сразу. Напротив, она делает так чтобы они были вызваны
при следующем вызове @code{run-mode-hooks}.
@end defun

@defmac delay-mode-hooks body@dots{}
Когда один основной режим вызывает другой, такой вызов должен выполняться
внутри @code{delay-mode-hooks}.

Такой макрос выполняет тело @var{body}, но не выполняет вызовы перехватчиков
внутри @code{run-mode-hooks}. Такие перехватчики будут выполнены
при следующем выполнении @code{run-mode-hooks}, после завершения действия
конструкции @code{delay-mode-hooks}.
@end defmac

@defvar change-major-mode-after-body-hook
Это обычный перехватчик запускаемый @code{run-mode-hooks}. Он выполняется до
перехватчика режима.
@end defvar

@defvar after-change-major-mode-hook
Обыкновенный перехватчик запускаемый @code{run-mode-hooks}. Перехватчик
запускается в конце функции режима, если она правильно написана.
@end defvar

@node Tabulated List Mode
@node Режим табличных списков
@subsection Tabulated List mode
@cindex Tabulated List mode
@cindex режим табулированного списка

  Режим табличных списков (Tabulated List) основной режим для
отображения табличных данных, т.е. данных состоящих из @dfn{entries}
(@dfn{записей}), каждая запись это одна строка текста разделенная на
колонки. Табличный режим предоставляет возможности для красивой печати
строк и колонок, сортировки строк в соответствии со значениями в
колонках. Данный режим является дочерним для Special режима
(@pxref{Basic Major Modes}.

Табличный режим предназначен для использования как родительский для
множества специальных основных режимов. Например режимы Меню Процессов
(Process Menu), (@pxref{Process Information}) и Меню Пакетов (Package
Menu) (@pxref{Package Menu,,, emacs, The GNU Emacs Manual}).

@findex tabulated-list-mode
  Дочерний режим должен использовать @code{define-derived-mode} как
обычно, задав @code{tabulated-list-mode} вторым аргументом
(@pxref{Derived Modes}).  Тело @code{define-derived-mode} должно
определять формат табличных данных, путем задания значения переменных
описанных ниже, функция @code{tabulated-list-init-header} может быть
вызвана для заполнения заголовка именами колонок.

Дочерний режим должен определить @dfn{listing command}. Это не команда
режима, а команда вызываемая аналогично (e.g., @kbd{M-x
list-processes}).
Команда должна создавать или переключать буфер, включать дочерний режим,
определять табличные данные и в заключение вызывать @code{tabulated-list-print}
для заполнения буфера.

@defvar tabulated-list-format
Данная локальная для буфера (buffer-local) переменная определяет формат
данных табличного списка. Значение должно быть вектором. Каждый элемент
вектора представляет колонку данных, и должен быть списком
@code{(@var{name} @var{width} @var{sort})}, где

@itemize
@item
@var{name} имя колонки (строка).

@item
@var{width} ширина колонки (число). Данный параметр не используется для
крайней колонки которая занимает все оставшееся место.

@item
@var{sort} задает правило сортировки записей по колонкам. Если
@code{nil}, колонка не будет использоваться для сортировки. Если
@code{t}, колонка сортируется как строковая. В другом случае,
нужно задать функцию предикат @code{sort} (@pxref{Rearrangement}),
которая принимает 2 аргумента того же вида что и элементы
@code{tabulated-list-entries} (см. ниже).
@end itemize
@end defvar

@defvar tabulated-list-entries
Данная локальная для буфера (buffer-local) переменная записи отображаемые
в Табличном режиме. Значение должно быть списком или функцией.

Если значение список, каждый элемент соответствует одной записи,
и должен иметь форму @w{@code{(@var{id} @var{contents})}}, где

@itemize
@item
@var{id} либо @code{nil}, либо Lisp объект идентифицирующий запись.
В случае объекта, курсор будет оставаться на той же записи при
пересортировке. Сравнение выполняется с использованием @code{equal}.

@item
@var{contents} это вектор с тем же количеством элементов, что и
@code{tabulated-list-format}. Каждый элемент вектора либо строка,
которая вставляется в буфер как есть, либо список @code{(@var{label}.
@var{properties})}, который предполагает вставку текстовой кнопки
вызовом @code{insert-text-button} с @var{label} и @var{properties}
в качестве аргументов (@pxref{Making Buttons}).

Переводов строк не в одной из строк быть не должно.
@end itemize

Если значение функция, то она должна возвращать список описанной выше
формы при вызове без аргументов.
@end defvar

@defvar tabulated-list-revert-hook
Обыкновенный перехватчик выполняемые как правило для перезагрузки
буфера с табличным списком. Дочерний режим может добавить функцию
в этот перехватчик для пересчета
@code{tabulated-list-entries}.
@end defvar

@defvar tabulated-list-printer
Значение данное переменной должно быть функцией вызываемой для вставки
записи в точке, включая символ перевода строки. Функция должна
принимать два аргумента @var{id} и @var{contents} (id и содержимое),
такие же как для @code{tabulated-list-entries}. Значение по умолчанию
функция вставляющая запись как есть, режимы использующие табличный
список более сложным образом могут задавать другую функцию.
@end defvar

@defvar tabulated-list-sort-key
Значение этой переменной определяет значение текущего ключа для сортировки
в буфере. Если значение @code{nil}, сортировка не выполняется.
Значение должно быть в форме @code{(@var{name} . @var{flip})}, где
@var{name} строка соответствующая имени одной из колонок в
@code{tabulated-list-format}, и @var{flip} если не-@code{nil},
задает сортировку в обратном порядке.
@end defvar

@defun tabulated-list-init-header
Функция вычисляет и устанавливает @code{header-line-format} для
буфера с табличным списком (@pxref{Header Lines}), и присваивает
обработчики кнопок для строки заголовков, чтобы было возможном
сортировать записи по клику на заголовке колонки.

Режимы дочерние к режиму Табличных списков, должны вызывать
данную функцию после установки вышеописанных переменных,
(в особенности после установки @code{tabulated-list-format}).
@end defun

@defun tabulated-list-print &optional remember-pos update
Функция заполняет текущий буфер записями. Она должна вызываться
командой листинга (listing-command). Функция очищает буфер, сортирует
записи заданные @code{tabulated-list-entries} в соответствии с
@code{tabulated-list-sort-key}, а затем вызывает функцию определенную
@code{tabulated-list-printer} для вставки каждой записи.

Если необязательный аргумент @var{remember-pos} не-@code{nil}, функция
смотрит на @var{id} текущей записи, и пытается спозиционироваться
на ту же запись после того как все записи будут (пере)вставлены ((re)inserted).

Если необязательный аргумент @var{update} не-@code{nil}, функция
будет удалять и вставлять только записи, которые изменились со
времени предыдущей печати. Такое поведение может быть в несколько
раз быстрее если большинство записей не изменились с предыдущего вызова
функции. Единственная разница в результатах, заключается в том, что
теги выставленные через @code{tabulated-list-put-tag}, не будут удалены
для записей которые не изменились (обычно все теги удаляются).
@end defun

@node Generic Modes
@node Общие режимы
@subsection Generic Modes
@cindex generic mode
@cindex Общие режимы

  @dfn{Generic modes} Общие режимы это простые основные режимы с базовой
поддержкой синтаксиса комментариев и подсветкой синтаксиса (Font Lock mode).
См. @file{generic-x.el} чтобы изучить примеры использования @code{define-generic-mode}.

@defmac define-generic-mode mode comment-list keyword-list font-lock-list auto-mode-list function-list &optional docstring
Макрос определяет команду общего режима с именем @var{mode}
(символ без кавычки (not quoted)).
Не обязательный аргумент @var{docstring} документация для команды режима.
Если опущено, то @code{define-generic-mode} сгенерирует значение по умолчанию.

Аргумент @var{comment-list} список в котором каждый элемент это
символ, строка из одного или двух символов, или cons ячейка.
Символ или строка установлены в таблице синтаксиса режима как
начало комментария. Если запись является cons ячейкой, то @sc{car}
является началом комментария, а @sc{cdr} завершением комментария.
(Стоит использовать @code{nil} в качестве @sc{cdr} если нужно чтобы комментарии
заканчивались в конце строки.)
Стоит учитывать, что синтаксическая таблица
имеет накладывает ограничения на то что может быть началом
и концом комментария.

@xref{Syntax Tables}.

Аргумент @var{keyword-list} это список ключевых слов которые должны
выделяться шрифтом @code{font-lock-keyword-face}. Каждое ключевое
слово должно быть строкой.  Кроме того, @var{font-lock-list}
это список дополнительных выражений для выделения. Каждый элемент
этого списка должен иметь ту же форму что и элементы @code{font-lock-keywords}.
@xref{Search-based Fontification}.

Аргумент @var{auto-mode-list} это список регулярных выражений для добавления
в переменную @code{auto-mode-alist}. Они добавляются при выполнении
формы @code{define-generic-mode}, а не при раскрытии макроса.

Переменная @var{function-list} является списком функций которые
выполняются при выполнении команды режима для задания дополнительных
настроек. Данные функции выполняет непосредственно перед вызовом
перехватчиков из переменной @code{@var{mode}-hook}.
@end defmac

@node Example Major Modes
@node Пример основных режимов
@subsection Major Mode Examples

  Текстовый (Text) режим вероятно самый простой режим после Fundamental
режима. Приведем отрывок из @file{text-mode.el} иллюстрирующий многие
из вышеописанных соглашений.

@smallexample
@group
;; @r{Create the syntax table for this mode.}
(defvar text-mode-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?\" ".   " st)
    (modify-syntax-entry ?\\ ".   " st)
    ;; Add 'p' so M-c on 'hello' leads to 'Hello', not 'hello'.
    (modify-syntax-entry ?' "w p" st)
    st)
  "Syntax table used while in `text-mode'.")
@end group

;; @r{Create the keymap for this mode.}
@group
(defvar text-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\t" 'ispell-complete-word)
    map)
  "Keymap for `text-mode'.
Many other modes, such as `mail-mode', `outline-mode' and
`indented-text-mode', inherit all the commands defined in this map.")
@end group
@end smallexample

  Далее выполняется определение команды режима:

@smallexample
@group
(define-derived-mode text-mode nil "Text"
  "Major mode for editing text written for humans to read.
In this mode, paragraphs are delimited only by blank or white lines.
You can thus get the full benefit of adaptive filling
 (see the variable `adaptive-fill-mode').
\\@{text-mode-map@}
Turning on Text mode runs the normal hook `text-mode-hook'."
@end group
@group
  (set (make-local-variable 'text-mode-variant) t)
  (set (make-local-variable 'require-final-newline)
       mode-require-final-newline)
  (set (make-local-variable 'indent-line-function) 'indent-relative))
@end group
@end smallexample

@noindent
(Крайняя строка в настоящее время избыточна, так как @code{indent-relative}
это значение по умолчанию, и стоит удалить ее в будущих версиях.)

@cindex @file{lisp-mode.el}
  Следующие 3 Lisp режима (Lisp режим, Emacs Lisp режим и Lisp Interaction режим)
имеют больше особенностей чем Text режим и код данных режимов
более сложный. Далее приводится выдержка из @file{lisp-mode.el}, которая
иллюстрирует как данные режимы написаны.

  Так определяются таблица синтаксиса и аббревиатур:

@cindex syntax table example
@cindex пример синтаксической таблицы
@smallexample
@group
;; @r{Create mode-specific table variables.}
(defvar lisp-mode-abbrev-table nil)
(define-abbrev-table 'lisp-mode-abbrev-table ())

(defvar lisp-mode-syntax-table
  (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table)))
    (modify-syntax-entry ?\[ "_   " table)
    (modify-syntax-entry ?\] "_   " table)
    (modify-syntax-entry ?# "' 14" table)
    (modify-syntax-entry ?| "\" 23bn" table)
    table)
  "Syntax table used in `lisp-mode'.")
@end group
@end smallexample

  Три режима для Lisp разделяются большую часть кода. Например,
все вызывают следующую функцию для установки переменных:

@smallexample
@group
(defun lisp-mode-variables (&optional syntax keywords-case-insensitive)
  (when syntax
    (set-syntax-table lisp-mode-syntax-table))
  (setq local-abbrev-table lisp-mode-abbrev-table)
  @dots{}
@end group
@end smallexample

@noindent
Среди прочего, функция устанавливает переменную @code{comment-start}
для обработки Lisp комментариев:

@smallexample
@group
  (make-local-variable 'comment-start)
  (setq comment-start ";")
  @dots{}
@end group
@end smallexample

  Каждый из различных Lisp режимов имеет немного отличающуюся
привязку клавиш (keymap, раскладку). Например в Lisp режиме по
@kbd{C-c C-z} выполняется @code{run-lisp}, а в других Lisp
режимах нет. Однако, все Lisp режимы имеют часть общих команд.
Общие команды устанавливаются следующим кодом:

@smallexample
@group
(defvar lisp-mode-shared-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\C-q" 'indent-sexp)
    (define-key map "\177" 'backward-delete-char-untabify)
    map)
  "Keymap for commands shared by all sorts of Lisp modes.")
@end group
@end smallexample

@noindent
Далее приводится код для установки раскладки Lisp режима:

@smallexample
@group
(defvar lisp-mode-map
  (let ((map (make-sparse-keymap))
	(menu-map (make-sparse-keymap "Lisp")))
    (set-keymap-parent map lisp-mode-shared-map)
    (define-key map "\e\C-x" 'lisp-eval-defun)
    (define-key map "\C-c\C-z" 'run-lisp)
    @dots{}
    map)
  "Keymap for ordinary Lisp mode.
All commands in `lisp-mode-shared-map' are inherited by this map.")
@end group
@end smallexample

@noindent
Далее приводится команда основного режима, для  Lisp режима:

@smallexample
@group
(define-derived-mode lisp-mode prog-mode "Lisp"
  "Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
Commands:
Delete converts tabs to spaces as it moves back.
Blank lines separate paragraphs.  Semicolons start comments.

\\@{lisp-mode-map@}
Note that `run-lisp' may be used either to start an inferior Lisp job
or to switch back to an existing one.
@end group

@group
Entry to this mode calls the value of `lisp-mode-hook'
if that value is non-nil."
  (lisp-mode-variables nil t)
  (set (make-local-variable 'find-tag-default-function)
       'lisp-find-tag-default)
  (set (make-local-variable 'comment-start-skip)
       "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
  (setq imenu-case-fold-search t))
@end group
@end smallexample

@node Minor Modes
@node Дополнительные режимы
@section Minor Modes
@cindex minor mode
@cindex дополнительные режимы

  Дополнительный @dfn{minor mode} режим предоставляется необязательные
функции, которые пользователи могут включать или выключать не зависимо от
основного режима. Дополнительные режимы могут включаться по отдельности
или в некоторой комбинации.

  Большинство дополнительных режимов реализуют функционал, который не зависит
от основного режима, и таким образом могут быть использованы с большинством
основных режимов. Например, Auto Fill (режим автозаполнения) может работать
с любым текстовым режимом который поддерживает вставку текста. Некоторые
дополнительные режимы, однако, специализированы для определенных основных
режимов. Например, Diff Auto Refine дополнительный режим предназначен
только для использования с Diff режимом.

  В идеале, дополнительный режим не должен оказывать влияния на другие
дополнительные режимы. Должно быть возможно включать и выключать дополнительные
режимы в любом порядке.

@defvar minor-mode-list
Значение этой переменной это список всех команд вспомогательных режимов
@end defvar

@menu
* Minor Mode Conventions::      Tips for writing a minor mode. (Советы по написанию дополнительных режимов)
* Keymaps and Minor Modes::     How a minor mode can have its own keymap. (Раскладки для вспомогательных режимов)
* Defining Minor Modes::        A convenient facility for defining minor modes. (Средства ддля упрощения определения дополнительных режимов)
@end menu

@node Minor Mode Conventions
@node Соглашения по дополнительным режимам
@subsection Conventions for Writing Minor Modes
@cindex minor mode conventions
@cindex соглашения по дополнительным режимам
@cindex conventions for writing minor modes
@cindex соглашения по написанию дополнительных режимов

  Как и для основных режимов, для дополнительных существуют соглашения
по их написанию. Указанные соглашения будут описаны ниже. Использование
макроса @code{define-minor-mode} простейший способ следовать этим
соглашениям.
@xref{Defining Minor Modes}.

@itemize @bullet
@item
@cindex mode variable
Переменная режима определяется переменной, чье имя оканчивается на
@samp{-mode}. Данную переменную будем называть @dfn{mode variable}.
Команда дополнительного режима должна устанавливать данную переменную.
Значение должно быть @code{nil} если режим не активен(disabled)
и не-@code{nil} если режим активен (enabled). Переменная должна быть
локальной для буфера (buffer-local) если дополнительный режим локальный
для буфера (buffer-local).

Данная переменная используется для в списке @code{minor-mode-alist}, для
отображения имени дополнительного режима в строке режима. Так же данная
переменная определяет является ли раскладка режима активной, через
@code{minor-mode-map-alist} (@pxref{Controlling Active Maps}). Другие
команды и перехватчики тоже могут проверять значение данной переменной.

@item
Нужно определить команду, называемую @dfn{mode command}, имя которой такое
же как имя переменной режима. Задача данной команды установить значение
переменной режима и выполнить другие действия включения и выключения
функций режима.

Команда режима должна принимать один необязательный параметр.
Если команда вызывается интерактивно, она должна переключать
состояние режима (включать если выключен и наоборот). Если она
вызывается интерактивно с prefix аргументом
(задается при помощи C-u <значение>), то режим нужно включить если
значение аргумента положительное и выключить в другом случае.

Если команда режима вызывается из Lisp (т.е не-интерактивно), тогда
команда должна включить режим если аргумент не задан или @code{nil};
должна переключить режима если аргумент символ @code{toggle};
иначе аргумент должен обработаться аналогично интерактивному поведению.

Дальше приводится пример как реализовать такое поведение (код схож
с кодом генерируемым макросом @code{define-minor-mode}):

@example
(interactive (list (or current-prefix-arg 'toggle)))
(let ((enable (if (eq arg 'toggle)
                  (not foo-mode) ; @r{this mode's mode variable}
                (> (prefix-numeric-value arg) 0))))
  (if enable
      @var{do-enable}
    @var{do-disable}))
@end example

Причина такого отчасти сложного поведения в том, что пользователю
нужно предоставить удобный способ включения дополнительного режима
интерактивно и из перехватчиков, например так:

@example
(add-hook 'text-mode-hook 'foo-mode)
@end example

@noindent
Данный код работает корректно в не зависимости от того включен ли
уже режим @code{foo-mode} или нет, так как @code{foo-mode} безусловно
включит дополнительный режим при вызове из Lisp без аргументов.
Выключение режима в перехватчике выглядит немного хуже:

@example
(add-hook 'text-mode-hook (lambda () (foo-mode -1)))
@end example

@noindent
Но, данный вызов используется не часто.

@item
В @code{minor-mode-alist} должен быть добавлен элемент
для каждого дополнительного режима (@pxref{Definition of minor-mode-alist}),
если дополнительный режим должен отображаться в строке режимов.
Элемент должен быть списком следующей формы:

@smallexample
(@var{mode-variable} @var{string})
@end smallexample

Где @var{mode-variable} переменная определяющая активность дополнительного
режима, а @var{string} короткая строка начинающаяся с пробела, которая
будет описывать режим в строке режимов. Данная строка должна быть короткой
так как пространство для описания всех режимов ограничено и одно на всех.

При добавлении элемента в @code{minor-mode-alist}, стоит использовать
@code{assq} чтобы избежать дублирования.
Например:

@smallexample
@group
(unless (assq 'leif-mode minor-mode-alist)
  (push '(leif-mode " Leif") minor-mode-alist))
@end group
@end smallexample

@noindent
или например, использовать @code{add-to-list} (@pxref{List Variables}):

@smallexample
@group
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end group
@end smallexample
@end itemize

  Часть соглашений для основных режимов хорошо подходят и для
дополнительных: например касающиеся имен глобальных символов,
использования функций в завершении функции инициализации режима, и
использования таблицы раскладок и других таблиц.

Дополнительный режима должен, если это возможно, поддерживать
включение и выключение через Custom (режим графической настройки)
(@pxref{Customization}). Чтобы это реализовать, переменная режима
должна быть определена через @code{defcustom}, обычно с
@code{:type 'boolean}. Если простое установление значения не
достаточно для включения режима, нужно определить метод @code{:set}
который включит режим вызовом команды режима. Стоит отметить, что
строка документации заданная не через Custom будет игнорироваться.
(примю
@code{autoload cookie} это магический комментарий @code{;;;###autoload},
который понимается командой @code{update-file-autoloads} и записывает
соответствующий autoload код в специальный файл @code{loaddefs.el}
)
Также можно пометить определение с использованием
autoload cookie (@pxref{autoload cookie}),
и добавить @code{:require}, чтобы изменение переменной
загружала соответствующую библиотеку с определением режима.
Например:

@smallexample
@group
;;;###autoload
(defcustom msb-mode nil
  "Toggle msb-mode.
Setting this variable directly does not take effect;
use either \\[customize] or the function `msb-mode'."
  :set 'custom-set-minor-mode
  :initialize 'custom-initialize-default
  :version "20.4"
  :type    'boolean
  :group   'msb
  :require 'msb)
@end group
@end smallexample

@node Keymaps and Minor Modes
@node Раскладки и дополнительные режимы
@subsection Keymaps and Minor Modes

  Дополнительный режим может иметь свою собственную раскладку, которая
активна когда режим включен. Для установки раскладки дополнительного режима
нужно добавить элемент в alist @code{minor-mode-map-alist}.
@xref{Definition of minor-mode-map-alist}.

@cindex @code{self-insert-command}, minor modes
@cindex @code{self-insert-command}, дополнительные режимы
  Одно из применений раскладок второстепенных режимов изменение поведения
символов (self-inserting characters символы вставляющие себя), чтобы
они делали еще что-то кроме вставки себя. (Другой способ настроить
@code{self-insert-command} использовать @code{post-self-insert-hook}. Кроме того,
настройка @code{self-insert-command} ограничена особыми случаями для
аббревиатур и режимом автозаполнения (Auto Fill mode)). Не нужно пытаться
заменить своим определением стандартное. Так как цикл редактора
обработает их специальным образом.)

Дополнительные режимы могут выполнять привязку к последовательности
@kbd{C-c} + знак пунктуации. Но @kbd{C-c} и следующим @kbd{@{@}<>:;} или
управляющим символом или цифрой зарезервированы для основных режимов.
Так же @kbd{C-c @var{letter}} зарезервировано для пользователей.
@xref{Key Binding Conventions}.
(Прим. То ест почти не с чем использовать нельзя.)

@node Defining Minor Modes
@node Определение дополнительного режима
@subsection Defining Minor Modes
@subsection Определение дополнительного режима

  Макрос @code{define-minor-mode} является удобным способом
определения режима.

@defmac define-minor-mode mode doc [init-value [lighter [keymap]]] keyword-args@dots{} body@dots{}
Макрос определяет новый дополнительный режим чье имя @var{mode}
(символ (a symbol)). Макрос определяет команду @var{mode} для
включения/выключения дополнительного режима, с @var{doc} в
качестве документации.

Команда переключения получает 1 необязательный (prefix) аргумент.
Если команда вызывается интерактивно без аргументов то она переключает
состояние режима с включенного на выключенное и наоборот.
Положительный prfix включает режим, любой другой prefix выключает.
При вызове из Lisp, аргумент @code{toggle} переключает режим, а
отсутствие аргумента или @code{nil} аргумент включает режим.
Такое поведение позволяет легко включить дополнительный режим в перехватчике
основного режима, например.
Если @var{doc} @code{nil}, макрос предоставляют строку документации
по умолчанию описанную выше.

По умолчанию, так же определяется переменная с именем @var{mode}, которая
устанавливается в @code{t} и @code{nil} при включении или выключении режима.
Переменная инициализируется значением @var{init-value}. За исключением
особых случаем (см. ниже), такое значение должно быть @code{nil}.

Параметр @var{lighter} определяет то, что будет отображаться в
строке режима, когда режим включен; если значение @code{nil},
режим не отображается в строке режима.

Не обязательный аргумент @var{keymap} определяет раскладку для
дополнительного режима. Если не-@code{nil}, то значение должно
быть именем переменной, чье значение это раскладка, или alist (ассоциативный массив)
в форме

@example
(@var{key-sequence} . @var{definition})
@end example

@noindent
где @var{key-sequence} и @var{definition} аргументы пригодные для
команды @code{define-key} (@pxref{Changing Key
Bindings}). Если @var{keymap} это раскладка или alist, то в макросе
будет этим будет определена переменная @code{@var{mode}-map}.

Три вышеописанных аргумента @var{init-value}, @var{lighter}, и
@var{keymap} могут быть (частично) опущены когда используется
@var{keyword-args}. Некоторые ключевые слова имеют
специальное значение:

@table @code
@item :group @var{group}
Специальное имя группы, которое будет использоваться во всех
формах @code{defcustom}.
По умолчанию @var{mode}, @samp{-mode}.
@strong{Warning:} не стоит использовать это имя по умолчанию,
если вы не определили использовали @code{defgroup} для
правильного определения группы. @xref{Group Definitions}.

@item :global @var{global}
Если значение не-@code{nil}, то режим будет глобальным,
а не локальным для буфера. Значение по умолчанию @code{nil}.

Одним из эффектов глобального дополнительного режима, является
то что переменная режима @var{mode} становится переменной
настройки (customization variable). Переключение ее значения
через интерфейс настройки (Customize interface) включает
и выключает режим, и данное значение может быть сохранено
для следующих сессий Emacs. (@pxref{Saving
Customizations,,, emacs, The GNU Emacs Manual}. Чтобы
сохранение переменной работало, нужно проверить, что
форма @code{define-minor-mode} выполняется каждый раз когда
Emacs запускается; для пакетов не являющихся частью
Emacs использование ключевого слова @code{:require}
является простейшим способом сделать это.

@item :init-value @var{init-value}
Эквивалентно позиционному @var{init-value}.

@item :lighter @var{lighter}
Эквивалентно позиционному @var{lighter}.

@item :keymap @var{keymap}
Эквивалентно позиционному @var{keymap}.

@item :variable @var{place}
Данная переменная заменяет переменную по умолчанию @var{mode},
используемую для хранения состояния режима. Если задать
это значение @var{mode} не определяется, и любой
@var{init-value} аргумент не будет использоваться. @var{place}
может быть другой именованной переменной (которую должна быть определена),
или чем угодно что может быть использовано с функцией @code{setf}
(@pxref{Generalized Variables}).
@var{place} может быть cons ячейкой @code{(@var{get} . @var{set})},
где @var{get} выражение возвращающее текущее значение, а
@var{set} функция одного аргумента устанавливающая значение.

@item :after-hook @var{after-hook}
Параметр определяет одну Lisp форму, которая выполняется после
того как выполнится перехватчик режима. Форма не должна быть
цитированием (quoted).
@end table

Все другие аргументы заданные с ключевыми словами передаются
непосредственно в @code{defcustom} сгенерированной для
переменной @var{mode}.

Команда с именем @var{mode} сначала выполняет стандартные действия
такие как установку переменной @var{mode} и затем выполняет формы @var{body},
если они заданы. Затем вызывается перехватчик режима @code{@var{mode}-hook},
и в завершении выполняется форма @code{:after-hook}.
@end defmac

  Начальное значение должно быть @code{nil} за исключением случаев
где (1) режим предварительно загружен в Emacs, или (2) загрузка режима
""безболезненна"" даже если пользователь ее не запрашивал. Например если
режим не оказывает эффекта, пока еще что-то не включено, тогда он будет
загружен для этого чего-то. Это особые случаи. Обычно начальное
значение @code{nil}.

@findex easy-mmode-define-minor-mode
  Имя @code{easy-mmode-define-minor-mode} является псевдонимом для
макроса.

  Пример использования @code{define-minor-mode}:

@smallexample
(define-minor-mode hungry-mode
  "Toggle Hungry mode.
Interactively with no argument, this command toggles the mode.
A positive prefix argument enables the mode, any other prefix
argument disables it.  From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

When Hungry mode is enabled, the control delete key
gobbles all preceding whitespace except the last.
See the command \\[hungry-electric-delete].

   Переключение Hunrgy режима.
Интерактивно без аргументов, команда переключает режим.
Положительный префикс аргумент включает режим, а любой другой
выключает. Из Lisp, отсутствие аргумента или nil включает режим, `toggle'
переключает состояние.

Когда Hungry режим включен, control + delete удаляет все
предшествующие пробелы кроме 1.
См. команду \\[hungry-electric-delete].
"
 ;; The initial value. Начальное значение
 nil
 ;; The indicator for the mode line. Текст для строки режима.
 " Hungry"
 ;; The minor mode bindings. Привязка клавиш дополнительно режима.
 '(([C-backspace] . hungry-electric-delete))
 :group 'hunger)
@end smallexample

@noindent
В примере определяется дополнительный режим ``Hungry mode'', команда
для переключения @code{hungry-mode}, переменная @code{hungry-mode},
которая указывает на состояние режима, и переменная @code{hungry-mode-map},
которая содержит раскладку, которая хранит привязки клавиш, которые
активны, когда активен режим. Создается раскладка с привязкой для
@kbd{C-@key{DEL}}. Переменная @code{hungry-mode} помещается в группу
настройки @code{hunger}. Форма @var{body} отсутствует --- многие
дополнительные режимы в ней не нуждаются.

  Эквивалентный вариант записи:

@smallexample
(define-minor-mode hungry-mode
  "Toggle Hungry mode.
...rest of documentation as before..."
 ;; The initial value. Начальное значение
 :init-value nil
 ;; The indicator for the mode line. Текст для строки режима
 :lighter " Hungry"
 ;; The minor mode bindings. Раскладка дополнительного режима.
 :keymap
 '(([C-backspace] . hungry-electric-delete)
   ([C-M-backspace]
    . (lambda ()
        (interactive)
        (hungry-electric-delete t))))
 :group 'hunger)
@end smallexample

@defmac define-globalized-minor-mode global-mode mode turn-on keyword-args@dots{}
Определяет глобальный переключатель @var{global-mode}, назначение
которого выключать или включать локальный для буфера дополнительный режим
@var{mode} во всех буферах. Для включения дополнительного режима
в буфере используется функция @var{turn-on}, для выключения вызов
@var{mode} с аргументом @minus{}1.

Глобальное включение режима так же сказывается на буферах созданных
при открытии файлов в дальнейшем, и буферах которые используют
основной режим отличный от Fundamental режима; но не обнаруживается
создание новых буферов в Fundamental режиме.

Макросом определяется опция настройки @var{global-mode} (@pxref{Customization}),
которая может быть изменена через интерфейс настройки (Customize interface).
Как и с @code{define-minor-mode}, нужно проверять, что
@code{define-globalized-minor-mode} вычисляется при каждом
запуске Emacs, например используя ключевое слово @code{:require}.

Чтобы задать группу настройки можно использовать @code{:group @var{group}}
@var{keyword-args}.

В общем, когда определяется глобальный доп. режим, так же нужно
определить не глобальную версию, чтобы люди могли использовать (или отключать)
режим в отдельных буферах. Кроме того это позволит
им отключить глобально включенный доп. режим в заданных основных
режимах, используя перехватчики этих режимов.
@end defmac


@node Mode Line Format
@node Формат строки режима
@section Mode Line Format
@section Формат строки режима
@cindex mode line
@cindex строка режима

  Каждое Emacs окно (за исключением окна минибуфера) как правило
имеет строку режима внизу, на которой отображается информация о буфере
отображаемом в окне. Строка режима содержит информацию о буфере, такую
как имя файла, глубину рекурсивного редактирования, основной и
дополнительные режимы. Окно может также иметь @dfn{header line},
которая такая же как строка режима только сверху окна.

Данный раздел описывает как управлять содержимым строки состояния и
строкой заголовка (header line). Данный раздел включен в эту главу,
потому что основная часть информации строки состояния связана с
основным или вспомогательным режимом.

@menu
* Base: Mode Line Basics.       Основные идеи управления строкой режима.
* Data: Mode Line Data.         Структура данных управляющая строкой режима.
* Top: Mode Line Top.           Переменная верхнего уровня, mode-line-format.
* Mode Line Variables::         Переменные используемые в структуре данных строки режима.
* %-Constructs::                Размещение информации в строке режима.
* Properties in Mode::          Использования свойств текста в строке режим.
* Header Lines::                Как строка режима только сверху.
* Emulating Mode Line::         Форматирование текста в стиле строке режима (эмулирование).
@end menu

@node Mode Line Basics
@subsection Mode Line Basics

  Содержимое строки режима определяется локальной переменной буфера
@code{mode-line-format} (@pxref{Mode Line Top}).  Эта переменная
хранит @dfn{mode line construct}: шаблон, который определяет
что отображается на строке режима. Значение переменной
@code{header-line-format} определяет строку заголовка точно
аналогично. Все окна одного буфера используют одни и теже
@code{mode-line-format} и @code{header-line-format}.
  a template that controls what is
displayed on the buffer's mode line.  The value of
@code{header-line-format} specifies the buffer's header line in the same

Для повышения производительности, Emacs не всегда пересчитывает
строку режима и строку заголовка окна. Пересчет выполняется если
при ряде условие, таких как переключение буферов, сжатие или расширение
буфера, прокрутка, или изменение буфера. Если изменить переменные
@code{mode-line-format} или
@code{header-line-format} (@pxref{Mode Line Variables}), или любые
другие структуры данных которые влияют на отображение текста
(@pxref{Display}), нужно воспользоваться функцией
@code{force-mode-line-update} для обновления.

@defun force-mode-line-update &optional all
Функция заставляет Emacs обновить строку режима и строку заголовка
текущего буфера, на основе значений всех связанных переменных.
Если необязательный аргумент @var{all} не-@code{nil}, обновляются
все строки режима и заголовки.

Функция так же заставляет обновить строку меню и заголовок фрейма.
@end defun

  Строка выбранного окна, как правило отображается другим цветом,
используя шрифт @code{mode-line}. Строки других окон отображаются
шрифтом @code{mode-line-inactive}. @xref{Faces}.

@node Mode Line Data
@subsection The Data Structure of the Mode Line
@cindex mode line construct

  Строка режима задается при помощи структуры
@dfn{mode line construct}  состоящей из списков, строк, символов, и
чисел хранящихся в локальных переменных буфера. Каждый тип данных
имеет особое значение в строке режима, как описано ниже. Такие же
структуры данных используются для задания заголовка фрейма
(@pxref{Frame Titles}) и строки заголовка буфера (@pxref{Header Lines}).

 Строка режима может просто фиксированной строкой текста, но
как правило задается как в виде комбинации строки и значений
переменных для задания текста. Многие такие переменные сами
так определены специально для использования в строке режима.
(Many of these variables are themselves
defined to have mode line constructs as their values.)


 Далее описание значение типов данных в качестве частей строки режима:

@table @code
@cindex percent symbol in mode line
@item @var{string}
Строки в строке режима отображаются без изменений, за исключением
@dfn{@code{%}-constructs}. В такие конструкции выполняется
подстановка других данных.
@ref{%-Constructs}.

Если часть строки содержит @code{face} свойства, они управляют
текстом так же как в буфере. Любые символы  которые не содержат
@code{face} отображаются шрифтом по умолчанию @code{mode-line} или
@code{mode-line-inactive}. @code{help-echo} и @code{keymap}
свойства @var{string} имеют особое значение. @xref{Properties in Mode}.

@item @var{symbol}
Символ в строке режима добавляет свое значение. Значение @var{symbol}
используется как часть конструкции строки режима. Но @code{t} и @code{nil}
игнорируются, как и символы со значением void.

Есть 1 исключение: если значение @var{symbol} строка, то текст
вставляется как есть и подстановка @code{%}-constructs не выполняется.

Если символ не помечен как @var{symbol} рискованный (т.е
свойство @code{risky-local-variable} не-@code{nil}),
все текстовые свойства строк в переменной символа @var{symbol},
игнорируются, как и все @code{:eval} и @code{:propertize}
формы. (Это делается ради безопасности: не опасные переменные
могут быть установлены автоматически из переменных файла
без запроса у пользователя).
(Не очень понятно, что тут имеется ввиду. Оригинальный вариант:).
Unless @var{symbol} is marked as risky (i.e., it has a
non-@code{nil} @code{risky-local-variable} property), all text
properties specified in @var{symbol}'s value are ignored.  This includes
the text properties of strings in @var{symbol}'s value, as well as all
@code{:eval} and @code{:propertize} forms in it.  (The reason for this
is security: non-risky variables could be set automatically from file
variables without prompting the user.)

@item (@var{string} @var{rest}@dots{})
@itemx (@var{list} @var{rest}@dots{})
Список с первым элементом строкой, указывает что нужно обработать
все элементы рекурсивно и соединить результаты. Это наиболее
частая форма конструкции строки режима.

@item (:eval @var{form})
Список первым элементом которого является символ @code{:eval},
говорит вычислить @var{form}, и использовать результат как строку
для отображения. Вычисление не должно загружать файлы, так как
это может привести к бесконечной рекурсии.

@item (:propertize @var{elt} @var{props}@dots{})
Список первый элемент которого символ @code{:propertize} говорит
обработать @var{elt} рекурсивно, после чего добавить свойства текста
заданные @var{props} к результату. Аргумент @var{props} должен
состоять из 0 или более пар @var{text-property} @var{value}.

@item (@var{symbol} @var{then} @var{else})
Список с первым аргументом являющемся не ключевым символом обрабатывается
в зависимости от значения @var{symbol}. Если значение @var{symbol}
не-@code{nil}, второй элемент @var{then} обрабатывается рекурсивно
как элемент строки режима, иначе, третий аргумент @var{else},
обрабатывается рекурсивно. @var{else} можно опустить, тогда
в строке режима ничего не будет отображено если значение
@var{symbol} @code{nil} или void.

@item (@var{width} @var{rest}@dots{})
Список с первым элементом числом определяет максимальную
ширину для результата @var{rest}. @var{rest} обрабатывается
рекурсивно, как части строки режима и соединяются вместе.
Когда @var{width} положительное, если ширина вычисления
меньше @var{rest}, справа добавляются пробелы. Когда
@var{width} отрицательное, результат обрезается до
@minus{}@var{width} если ширина больше @minus{}@var{width}.

Например, обычный способ показать сколько процентов буфера находится
выше использовать: @code{(-3 "%p")}.
@end table

@node Mode Line Top
@subsection The Top Level of Mode Line Control

Переменная верхнего уровня.
 Переменная для задания всей строки режима
называется @code{mode-line-format}.


@defopt mode-line-format
Значение переменной элемент (конструкт) строки режима, задающий
содержимое строки режима. Как правило это локальная для буфера
переменная.

Если значение переменной установить в @code{nil}, строки режима
у буфера не будет. (Окна высотой в 1 строку так же не имеют
строки режима).
@end defopt

Значение по умолчанию @code{mode-line-format} проектируется с
использованием значением таких переменных как @code{mode-line-position} и
@code{mode-line-modes} (которые объединяют значение переменных
@code{mode-name} и @code{minor-mode-alist}). Совсем немногим
режимам требуется изменение @code{mode-line-format} самостоятельно.
В большинстве случаев, достаточно задать какие-то переменные
которые влияют на @code{mode-line-format}.

Если вы изменяете @code{mode-line-format}, новое
значение должно использовать те же переменные что и в
оригинальном значении (@pxref{Mode Line Variables}),
вместо дублирования их значений или использования другого
способа отображения информации. Такой способ, позволяет
оставить возможность настройки через переменные пользователем или
Lisp программой (как @code{display-time} и основными режимами).

Ниже гипотетический пример @code{mode-line-format}, который
может использоваться для Shell режима (в реальности, Shell режим, не
задает @code{mode-line-format}).

@example
@group
(setq mode-line-format
  (list "-"
   'mode-line-mule-info
   'mode-line-modified
   'mode-line-frame-identification
   "%b--"
@end group
@group
   ;; @r{Отметим, что это вычисляется при построении списка.}
   ;; @r{Получается  конструкт строки режима который является строкой.}
   (getenv "HOST")
@end group
   ":"
   'default-directory
   "   "
   'global-mode-string
   "   %[("
   '(:eval (mode-line-mode-name))
   'mode-line-process
   'minor-mode-alist
   "%n"
   ")%]--"
@group
   '(which-func-mode ("" which-func-format "--"))
   '(line-number-mode "L%l--")
   '(column-number-mode "C%c--")
   '(-3 "%p")))
@end group
@end example

@noindent
(Переменные @code{line-number-mode}, @code{column-number-mode}
и @code{which-func-mode} включают соответствующие дополнительные режимы; как правило,
имена этих переменных являются именами команд дополнительных режимов.)

@node Mode Line Variables
@subsection Variables Used in the Mode Line

Переменные строки режима.
  Данная секция содержит описание переменных объединяющихся в
значение строки режима для стандартного значения @code{mode-line-format}.
Ничем существенно особенным эти переменные не являются; но некоторые
переменные могут иметь определенное влияние не строку режима,
если значение @code{mode-line-format} изменено, так чтобы они
использовались. Но, различные части Emacs устанавливают значения
данных переменных, считая, что влияют на строку режима; таким образом;
важно чтобы строка режима их использовала. См. @ref{Optional Mode Line,,,
emacs, The GNU Emacs Manual}.
(Суть в том, что если изменяется @code{mode-line-format}, стоит
оставить в ней использование описанных ниже переменных, так как
другой Lisp код считает что они используются).

@defvar mode-line-mule-info
Переменная в строке режима определяет отображение информации
о языке, кодировке буфера, и текущем методе ввода.
@xref{Non-ASCII Characters}.
@end defvar

@defvar mode-line-modified
Переменная отвечает за информации о том, был ли буфер изменен.
Типичные значения: @samp{**} -- буфер изменен, @samp{--} -- не
изменен, @samp{%%} -- буфер только для чтения, @samp{%*} -- буфер
только для чтения, но при этом изменен.

Изменение этой переменной, не приводит к немедленному обновлению
строки режима.
@end defvar

@defvar mode-line-frame-identification
Переменная определяет отображение информации о текущем фрейме.
Значение по умолчанию:
@code{" "} -- если используется система окон, которая
может отображать множество фреймов, или @code{"-%F "} на
терминалах, которые могут отображать только один фрейм за раз.
@end defvar

@defvar mode-line-buffer-identification
Переменная отвечает за отображение информации о буфере. Значение по умолчанию
предполагает отображение имени буфера расширенное пробелами до минимальных
12 символов.
@end defvar

@defvar mode-line-position
Переменная определяет отображение позиции в буфере. Значение по умолчанию
отображает часть буфера сверху в процентах, и опционально размер
буфера, номер строки и столбца курсора.
@end defvar

@defvar vc-mode
Переменная @code{vc-mode} локальная для буфера, определяет,
поддерживается для контроль версий для файла буфера, и если да
то какая система контроля версий. Значение переменной строка,
которая отображается в строке режима или @code{nil} если
система контроля версий не используется.
@end defvar

@defvar mode-line-modes
Переменная определяет отображение основного и дополнительных режимов.
Значение по умолчанию также отображает уровень рекурсивного редактироавния
(recursive editing level), информацию о статусе процесса и используется
ли сужение (narrow).
(narrow -- такая штука когда, выделяется часть буфера, нажимается
C-x n n (narrow-to-region) и редактируется только часть буфера,
потом нажимается C-x n w (widen) и опять видим весь буфер).
@end defvar

@defvar mode-line-remote
Переменная определяет отображение удаленности @code{default-directory}.
То есть является ли текущий каталог удаленным (прим. например ssh.).
@end defvar

@defvar mode-line-client
Переменная отображает @code{emacsclient} фреймов.
@end defvar

  Три следующих переменных используются в @code{mode-line-modes}:

@defvar mode-name
 Локальная для буфера переменная хранит ``pretty'' (удобное) имя
основного режима. Каждый основной режим устанавливает данную переменную.
Значение не обязано быть строкой, но может использовать все типы данных
конструктов (частей) строки режима (@pxref{Mode Line Data}).
Для вычисления строки, которая появится в строки режима можно
использовать @code{format-mode-line} (@pxref{Emulating Mode Line}).
@end defvar

@defvar mode-line-process
Локальная для буфера переменная содержит информацию о статусе
процесса в режимах используемых для связи с подпроцессами.
Значение отображается сразу за именем основного режима.
Например в буфере @file{*shell*} используется значение @code{(":%s")},
которое позволяет оболочке (shell) отображать статус вместе
с основным режимом как: @samp{(Shell:run)}.
Обычно значение переменной @code{nil}.
@end defvar

@defvar mode-line-front-space
Значение данной переменной отображается в начале строки режима, за
исключением наличия memory-full сообщения.
@end defvar

@defvar mode-line-end-spaces
Значение данной переменной отображается в конце строки режима.
@end defvar

@defvar mode-line-misc-info
Переменная используется для отображения дополнительно информации.
По умолчанию, переменная отображает информации заданную
@code{global-mode-string}.
@end defvar

@defvar minor-mode-alist
@anchor{Definition of minor-mode-alist}
Переменная содержит ассоциативный список элементы которого определяют
как должно отображаться в строке режима активность соответствующего
дополнительного режима. Каждый элемент @code{minor-mode-alist}
должен быть 2-х элементным списком:

@example
(@var{minor-mode-variable} @var{mode-line-string})
@end example


В общем, @var{mode-line-string} может быть любым конструктом
строки режима. Значение появляется в строке режима, когда
@var{minor-mode-variable}  не-@code{nil}. Строки должна
начинаться с пробела, чтобы названия режимов не сливались.
Традиционно, переменная @var{minor-mode-variable} режима не-@code{nil}
когда дополнительный режим активен.

@code{minor-mode-alist} не локальная для буфера. Но переменные
используемые в списке, должны быть локальными для буфера, если
дополнительный режим может включаться-выключаться в отдельных буферах.
@end defvar

@defvar global-mode-string
Переменная хранит контрукт строки режима, который ко умолчанию, появляется
в строке режима сразу за @code{which-func-mode} второстепенного режима,
если он задан, иначе за @code{mode-line-modes}. Команда @code{display-time}
устанавливает ссылку @code{global-mode-string} на переменную
@code{display-time-string}, которая хранит строку времени и
информацию о загрузке. (прим. средняя информации по загрузке системы,
за какой-то промежуток времени, по умолчанию видимо 1 минута).

Конструкт @samp{%M} выполняет подстановку значения @code{global-mode-string},
(но это считается устаревшим), так как переменная включена в
строку режима в @code{mode-line-format}.
@end defvar

Ниже упрощенный пример значения по умолчанию
@code{mode-line-format}. Реальное определение
определяет дополнительные текстовые свойства.

@example
@group
("-"
 mode-line-mule-info
 mode-line-modified
 mode-line-frame-identification
 mode-line-buffer-identification
@end group
 "   "
 mode-line-position
 (vc-mode vc-mode)
 "   "
@group
 mode-line-modes
 (which-func-mode ("" which-func-format "--"))
 (global-mode-string ("--" global-mode-string))
 "-%-")
@end group
@end example

@node %-Constructs
@subsection @code{%}-Constructs in the Mode Line

  Строки используемые в строке режима могут использовать
@code{%}-конструкты для подстановки разных данных.
Ниже содержится описание списка @code{%}-конструктов, и
их значений.

  В любом конструкте за исключением @samp{%%}, можно добавить натуральное
числе после @samp{%}, для задания минимальной ширины поля. Чисто числовые
конструкты (@samp{c}, @samp{i}, @samp{I}, and @samp{l}) расширяются
пробелами слева, другие расширяются пробелами справа.

@table @code
@item %b
Имя текущего буфера, полученное функцией @code{buffer-name}.
@xref{Buffer Names}.

@item %c
Текущий номер колонки.

@item %e
Когда у Emacs приближается переполнение памяти Lisp объектов,
показывается краткое сообщение. В других случая, контрукт пустой.

@item %f
Имя файла, полученное функцией @code{buffer-file-name}.
@xref{Buffer File Name}.

@item %F
Заголовок (только для системы окон) или имя выбранного фрейма.
@xref{Basic Parameters}.

@item %i
Размер доступной части текущего буфера; вычисляемой
@code{(- (point-max) (point-min))}.

@item %I
Так же как @samp{%i}, но размер печатается в более читаемой форме,
используя  @samp{k} для 10^3,
@samp{M} для 10^6, @samp{G} для 10^9, и т.д., для сокращения.

@item %l
Текущий номер строки, вычисляемой для доступной части буфера.

@item %n
@samp{Narrow} Когда включено сужение; иначе пусто (см.
@code{narrow-to-region} в @ref{Narrowing}).

@item %p
Процент буфера находящийся сверху @strong{top} окна, или
@samp{Top}, @samp{Bottom} или @samp{All}. Конструкция для
строки режима по умолчанию, обрезает значение до 3-х символов.

@item %P
Процент текста буфера который выше @strong{bottom} окна
(включает текст видимый в окне, как и текст выше top), плюс @samp{Top}
если верх буфера виден на экране; или @samp{Bottom}  @samp{All}.

@item %s
Статус подпроцесса принадлежащего текущему буферу,
полученный функцией @code{process-status}.
@xref{Process Information}.

@item %z
Мнемоническое обозначение кодировки раскладки, терминала или
буфера.

@item %Z
Как @samp{%z}, но включает форматирования конца строки end-of-line.

@item %*
@samp{%} Если буфер только для чтения (см @code{buffer-read-only}); @*
@samp{*} Если буфер изменен (см. @code{buffer-modified-p}); @*
@samp{-} В других случаях.  @xref{Buffer Modification}.

@item %+
@samp{*} Если буфер изменен (см. @code{buffer-modified-p}); @*
@samp{%} Если буфер только для чтения (см. @code{buffer-read-only}); @*
@samp{-} В других случаях.  Тут отличие от @samp{%*} только
для измененных буферов и только на чтение.  @xref{Buffer Modification}.

@item %&
@samp{*} Если буфер изменен, и @samp{-} если не изменен.

@item %[
Индикатор глубины рекурсивного редактирования (не считаются уровни
минибуфера): одна @samp{[} для каждого уровня.
@xref{Recursive Editing}.

@item %]
Одна @samp{]} для каждого уровня рекурсивного редактирования
(не считаются уровни минибуфера).

@item %-
Черточка для заполнения оставшейся части строки режима.
(Dashes sufficient to fill the remainder of the mode line.)
(Прим. Видимо просто заполнение.)

@item %%
Позволяет включить символ @samp{%} в строку в которой
поддерживаются @code{%}-конструкты.
(То есть экранирование @samp{%}).
@end table

Следующие 2 @code{%}-конструкта еще поддерживаются, но они уже
устарели, так как тот же результат можно получить:
через @code{mode-name} and @code{global-mode-string}.

@table @code
@item %m
Значение @code{mode-name}.

@item %M
Значение @code{global-mode-string}.
@end table

@node Свойства в режиме
@node Properties in Mode
@subsection Properties in the Mode Line
@cindex text properties in the mode line
@cindex текстовые свойства в строке режима

Некоторые свойства текста влияют на строку режима.
Свойство @code{face} влияет на внешний вид текста;
@code{help-echo} ассоциирует подсказку с текстом, а
@code{keymap} делает текст кликабельным (мышкой).


Существует 4 способа задать текстовые свойства в строке режима:

@enumerate
@item
Поместить строку с текстовыми свойствами непосредственно в структуры
данных строки режима.

@item
Поместить текстовые свойства на %-конструкт, такой как @samp{%12b};
в результате чего текст полученный для конструкта будет содержать
те же свойства.

@item
Использовать @code{(:propertize @var{elt} @var{props}@dots{})} конструкт
чтобы задать @var{elt} текстовое свойство заданное @var{props}.

@item
Использовать список @code{:eval @var{form}} в структуре данных
строки режима, и выполнить интерпретацию @var{form}
в строку с текстовыми свойствами.
(make @var{form} evaluate)
@end enumerate

  Можно использовать @code{keymap} для задания раскладки. Раскладка
будет действовать только для нажатия мышкой; привязка
других клавиш будет игнорироваться, потому что перемещение
по строке режима не возможно.

  Если строка режима ссылается на переменную, которая не содержит
не-@code{nil} @code{risky-local-variable} свойства,
любой текст определенный с такой переменной игнорируется.
Так делается потому что такие свойства могут определять вызов
функций, и такие функции могут быть получены из
локальных переменных файлов.
(судя по всему имеется ввиду, что свойства игнорируются, потому что
зависят от переменных локальных для файла)

@node Header Lines
@node Строки заголовка
@subsection Window Header Lines
@cindex header line (of a window)
@cindex window header line

  Окно может иметь @dfn{header line} (строку заголовка) сверху,
так же как строку режима снизу. Строка заголовка
определяется и функционирует так же как строка режима, за
исключением того, что определяется переменной @code{header-line-format}:

@defvar header-line-format
Переменная, локальная для любого буфера, определяет то как будет
отображаться строка заголовка. Формат переменной такой же как 
for @code{mode-line-format} (@pxref{Mode Line Data}).
Как правило это значение @code{nil}, то есть буферы не
содержат строки заголовка.
@end defvar

@defun window-header-line-height &optional window
Функция возвращает высоту в пикселах строки заголовка @var{window}
(окна). @var{window} (окно) должно быть существующим окном,
значением по умолчанию является выбранной окно.
@end defun

  Окно высотой в одну строку не отображает строку заголовка.
Окно высотой в 2 строки не может отобразить строку заголовка и строку
режима одновременно, если у окна есть строка режима, то строка
заголовка отображаться не будет.

@node Эмулирование строки режима
@node Emulating Mode Line
@subsection Emulating Mode Line Formatting

  Можно использовать функцию @code{format-mode-line} для вычисления
текста который появится в строке режима или строке заголовка для
заданной конструкции строки режима.

@defun format-mode-line format &optional face window buffer
Функция выполняет форматирование текстовой строки @var{format}
как если бы это была строка режима окна @var{window},
и возвращает текст как результат. Значение по умолчанию
для @var{window} текущее окно. Если @var{buffer} не @code{nil},
информация берется из @var{buffer}; @var{buffer} по умолчанию
буфер из @var{window}. 

Строковое значение содержит свойства текста такие соответствующие
шрифтам, раскладкам и т.д. такие какие бы были у текста строки режима.
Любой символ для которого @code{face} не задается через @var{format}
получит шрифт по умолчанию из аргумента @var{face}. Если @code{t},
используется шрифт как для строки режима активного окна (@code{mode-line})
если @var{window}
окно активное, иначе как для не активного (@code{mode-line-inactive}).
Если @var{face} @code{nil}, то используется шрифт по умолчанию.
Если @var{face} число, значение возвращаемое функцией не содержит
свойств текста.

Если задать шрифт в аргументе @var{face}, он будет использоваться
по умолчанию для символов чей шрифт не определяется в @var{format}.

Стоит отметить, что использование @code{mode-line},
@code{mode-line-inactive}, или @code{header-line} в качестве @var{face}
шрифта, приведет к перерисовки строки режима или строки заголовка
соответственно, а не только возвращению форматированной строки.
(Другие шрифты такого влияния не оказывают).

Например, @code{(format-mode-line header-line-format)} вернет
текст соответствующий строке заголовка (@code{""} если заголовка нет)
@code{(format-mode-line header-line-format
'header-line)} вернет тот же текст, и кроме того перерисует строку
заголовка.
@end defun

@node Imenu
@section Imenu

@cindex Imenu
  @dfn{Imenu} позволяет пользователю выполнять выделение определений
или секций буфера, из меню содержащего список всех элементов, с
непосредственным переходом к элементу. Imenu работает путем
создания индекса который представляет собой список имен
и соответствующих им позиций в буфере; после чего
пользователь может выбрав имя переместится на соответствующую
позицию. Основные режима могут добавить элемент в меню (основное)
для использования Imenu командой @code{imenu-add-to-menubar}.

@deffn Command imenu-add-to-menubar name
Функция определяет элемент меню с именем @var{name}, для
запуска Imenu.
@end deffn

  Пользовательские команды для использования Imenu описаны в руководстве
Emacs (@pxref{Imenu,, Imenu, emacs, the Emacs Manual}). Данная секция
описывает как настроить методы Imenu для поиска определений или
позиций для определенного основного режима.

  Простейший и наиболее часто используемым является
задание переменной @code{imenu-generic-expression}:

@defvar imenu-generic-expression
Если переменная не-@code{nil}, должна быть списком регулярных
выражений для поиска определений для Imenu. Простой элемент
@code{imenu-generic-expression} может выглядеть так:

@example
(@var{menu-title} @var{regexp} @var{index})
@end example

Тут, если @var{menu-title} не-@code{nil}, означает, что найденный
элемент попадет в подменю индекса буфера (или просто подменю);
@var{menu-title} определяет имя подменю. Если
@var{menu-title} @code{nil}, найденные элементы попадают непосредственно
в меню верхнего уровня.

@var{regexp} регулярное выражение (@pxref{Regular Expressions});
все что в буфере удовлетворяет является определением, попадающем
в индекс.

Третий элемент, @var{index}, это положительно целое, определяющее
какое подвыражение @var{regexp} является именем определения.
(Видимо имеется в виду что, в regexp есть группы, и это номер
группы).

Элемент может выглядеть и так:

@example
(@var{menu-title} @var{regexp} @var{index} @var{function} @var{arguments}@dots{})
@end example

Каждое совпадение для такого элемента создает элемент индекса,
но при выборе такого элемента пользователем вызывается функция
@var{function} с аргументами именем элемента, позицией в буфере, и
@var{arguments}.

Для режима Emacs Lisp, @code{imenu-generic-expression}, должна
выглядеть следующим образом:

@c should probably use imenu-syntax-alist and \\sw rather than [-A-Za-z0-9+]
@example
@group
((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Types*"
  "^\\s-*\
(def\\(type\\|struct\\|class\\|ine-condition\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2))
@end group
@end example

Установка данной переменной делает ее локальной для текущего буфера.
@end defvar

@defvar imenu-case-fold-search
Переменная @code{imenu-generic-expression} если @code{t}
то поиск выполняет с учетом регистра, по умолчанию
без учета.

Установка переменной делает ее локальной для текущего буфера.
@end defvar

@defvar imenu-syntax-alist
Переменная содержит ассоциативный список (alist) модификаторов
синтаксической таблицы при обработке @code{imenu-generic-expression},
для перезаписи синтаксической таблицы буфера.
Каждый элемент должен иметь форму:

@example
(@var{characters} . @var{syntax-description})
@end example

@sc{car}, @var{characters} может быть символом (character) или строкой.
Элемент предписывает взять символ или строки заданные
@var{syntax-description},
которые передаются @code{modify-syntax-entry}
(@pxref{Syntax Table Functions}).

Данная возможность используется для того, чтобы
сделать обычными некоторые слова которые обычно являются
символами, и упростить @code{imenu-generic-expression},
чтобы увеличить скорость.

Например, Fortran использует это так:

@example
(setq imenu-syntax-alist '(("_$" . "w")))
@end example

В регулярном выражении @code{imenu-generic-expression} можно после
этого использовать @samp{\\sw+} вместо @samp{\\(\\sw\\|\\s_\\)+}.
Данная техника не удобна когда в режиме нужно ограничить
начальную букву имени, до небольшого множества символов
которые разрешены в отличие от остальной части имени.

Установка данной переменной делает ее локально для буфера.
@end defvar

  Другой способ настройки Imenu для основного режима установить
переменные @code{imenu-prev-index-position-function} и
@code{imenu-extract-index-name-function}:

@defvar imenu-prev-index-position-function
Если переменная не-@code{nil}, то значением должна быть функция,
которая ищет следующее определение для помещения в индекс буфера,
выполняя сканирование буфера в обратном порядке начиная с текущей
точки. Функция должна возвращать @code{nil} если не одного
определения найдено не было. Иначе она должна оставить точку в месте
где найдено определение и вернуть любое не-@code{nil} значение.

Установка переменной делает ее локально для текущего буфера.
@end defvar

@defvar imenu-extract-index-name-function
Если значение переменной не-@code{nil}, значение должна быть
функция возвращающая имя определения, предполагая что точка (point, курсор)
находится на определении и была оставлена
функцией @code{imenu-prev-index-position-function}.

Установка данной переменной делает ее локально для буфера.
@end defvar

  Еще один способ настройки Imenu задать
@code{imenu-create-index-function}:

@defvar imenu-create-index-function
Переменная определяет функцию используемую для создания
индекса буфера. Функция не должна иметь аргументов, и возвращать
ассоциативный список, который будет индексом для текущего
буфера. Функция вызывается внутри, @code{save-excursion}, поэтому
изменение точки не важно.

Ассоциативный список индекса может иметь три типа аргументов:
Простые элементы выглядят как:

@example
(@var{index-name} . @var{index-position})
@end example

Выбор простого элемента приводит в позиционированию
на @var{index-position} в буфере. 
Специальные элементы выглядят как:

@example
(@var{index-name} @var{index-position} @var{function} @var{arguments}@dots{})
@end example

Выбор специального элемента выполняется как:

@example
(funcall @var{function}
         @var{index-name} @var{index-position} @var{arguments}@dots{})
@end example

Вложенные под-индексы выглядят:

@example
(@var{menu-title} . @var{sub-alist})
@end example

В результате создается подменю  @var{menu-title} с  @var{sub-alist}.

Значением по умолчанию для @code{imenu-create-index-function} является
@code{imenu-default-create-index-function}.  Функция вызывает
 @code{imenu-prev-index-position-function} и 
@code{imenu-extract-index-name-function} для создания индекса.
Но, если хотя бы одна из этих переменных @code{nil}, используется
@code{imenu-generic-expression}.

Установка данной переменной делает ее локально для буфера.
@end defvar

@node Режим блокировки шрифта
@node Font Lock Mode
@section Font Lock Mode
@cindex Font Lock mode

Прим. Font Lock режим используется для подсветки текста.
В режимах для языков программирования он подсвечивает переменные,
комментарии, строки константы и т.д.
В оригинале используется термин fontification, в переводи
это будет переводится как подсветка.

  @dfn{Font Lock mode} локальный для буфера дополнительный режим
который автоматически устанавливает свойство @code{face} для
некоторых частей буфера в зависимости от их синтаксической роли.
При сами части зависят от основного режима. Большинство
основных режимов задает синтаксис, для этого. Данная
секция описывает как настроить Font Lock для
основного режима.

  Font Lock находит текст для выделения двумя способами:
через разбор синтаксиса на основе таблицы синтаксиса, и
через поиск (обычно по регулярным выражениям).

Сначала выполняется подсветка по синтаксису (так
можно подсветить комментарии, строковые константы);
затем выполняется подсветка с использование поиска.

@menu
* Font Lock Basics::            Обзор настройки Font Lock.
* Search-based Fontification::  Подсветка по регулярным выражениям.
* Customizing Keywords::        Настройки подсветки по поиску.
* Other Font Lock Variables::   Дополнительные возможности настройки.
* Levels of Font Lock::         Каждый режим может задать дополнительные
                                уровни, а пользователь может выбрать
                                больше или меньше.
* Precalculated Fontification::  Как Lisp программы генерирующие содержимое буфера
                                 могут определить подсветку для них.
* Faces for Font Lock::         Шрифты специально для Font Lock.
* Syntactic Font Lock::         Подсветка основанная на таблицах синтаксиса.
* Multiline Font Lock::         Как включить подсветку Font Lock для многострочных
                                конструкций.
@end menu

@node Font Lock Basics
@subsection Font Lock Basics

Основы подсветки.

  Функционал Font Lock основан на нескольких базовых функциях.
Каждая из них вызывает функцию определенную соответствующей
переменной. Такая непрямолинейность позволяет основным и дополнительным
режимам изменять работу способа подсветки в буфере с соответствующим
режимом, или даже использовать механизмы Font Lock там где
подсветка не нужна. (Поэтому ниже в описании функций
говорится что они ``должны'' делать, так как режим может их
изменить на что-то другое).
Перечисленные ниже переменные описаны в @ref{Other
Font Lock Variables}.

@ftable @code
@item font-lock-fontify-buffer
Данная функция должна сделать подсветку доступной части буфера
путем вызова функции определенной
@code{font-lock-fontify-buffer-function}.

@item font-lock-unfontify-buffer
Если Font Lock включен то функция выключает подсветку (Font Lock).
Вызывается функция  @code{font-lock-unfontify-buffer-function}.

@item font-lock-fontify-region beg end &optional loudly
Функция должна сделать подсветку для региона между
@var{beg} и @var{end}. Если @var{loudly} не-@code{nil},
должно отображаться сообщения статуса пока выполняется
подсветка. Вызывается функция определенная
@code{font-lock-fontify-region-function}.

@item font-lock-unfontify-region beg end
Функция должна удалить подсветку региона между @var{beg} и
@var{end} Вызывается функция заданная переменной
@code{font-lock-unfontify-region-function}.

@item font-lock-flush &optional beg end
Функция должна пометить подсветку региона между
@var{beg} и @var{end} как устаревшую. Если
@var{beg} и @var{end} не заданы или @code{nil},
то помечается вся доступная область буфера. Вызывается
функция заданная переменной @code{font-lock-flush-function}.

@item font-lock-ensure &optional beg end
Функция должна удостоверится что регион @var{beg}, @var{end}
подсвечен. Если @var{beg}, @var{end} не заданы
или @code{nil}, то рассматривается вся доступная область буфера.
Вызывается функция определенная переменой
@code{font-lock-ensure-function}.
@end ftable

  Несколько переменных влияют на то как Font Lock выполняет подсветку.
Но основные режимы не должны устанавливать никакие из этих
переменных напрямую, вместо этого они должны установить
@code{font-lock-defaults} как локальную для буфера переменную.
Значение этой переменой используется для установки всех
других переменных Font Lock режима.

@defvar font-lock-defaults
Переменная устанавливается режимами для настройки подсветки
текста в этих режимах. Переменная автоматически становится локальной
для буфера при задании значения. Если значение @code{nil}, то
Font Lock ничего не подсвечивает, и можно использовать
меню @samp{Faces} (Шрифты) (@samp{Edit}->@samp{Text
Properties}) (Редактировать->Свойства текста) для явного задания
шрифта текста в буфере.

Если не-@code{nil}, значение должно выглядеть как:

@example
(@var{keywords} [@var{keywords-only} [@var{case-fold}
 [@var{syntax-alist} @var{other-vars}@dots{}]]])
@end example

Первый элемент, @var{keywords}, неявно задает значение
@code{font-lock-keywords} которые направляют подсветку по поиску.
Это может быть символ (symbol), переменная или функция, значение
которое список используемый в @code{font-lock-keywords}.
Так же она может списком из нескольких таких символов, под 1 на каждый
уровень подсветки. Первый символ определяет уровень @samp{mode default}
подсветки, следующий 1 уровень, следующий 2 и т.д. 
@samp{mode default} как правило такой же как и уровень 1.
Он используется когда @code{font-lock-maximum-decoration}
имеет значение @code{nil}. @xref{Levels of Font Lock}.

Второй элемент @var{keywords-only}, определяет значение переменной
@code{font-lock-keywords-only}. Если он опущен или @code{nil}
подсветка на основе синтаксиса (строки и комментарии) выполняется.
Если не-@code{nil}, то не выполняется. @xref{Syntactic Font Lock}.

Третий элемент @var{case-fold}, определяет значение
@code{font-lock-keywords-case-fold-search}, если он
не-@code{nil}, Font Lock режим игнорирует регистр при
подсветки основанной на поиске.

Если четвертый элемент, @var{syntax-alist}, не-@code{nil},
он должен быть списком cons ячеек в форме
@code{(@var{char-or-string} . @var{string})}. Они используются
для установки синтаксической таблицы, для подсветки основанной
на синтаксисе; результирующая таблица синтаксиса загружается
в @code{font-lock-syntax-table}. Если @var{syntax-alist} пропущен
или @code{nil}, подсветка основанная на синтаксисе использует
синтаксическую таблицу возвращаемую функцией @code{syntax-table}.
@xref{Syntax Table Functions}.

Все остальные элементы (если есть) имеют общее название
@var{other-vars}. Каждый из этих элементов должен иметь
форму @code{(@var{variable} . @var{value})} -- которая означает,
что нужно сделать переменную @var{variable} локальной для буфера
и установить в значение @var{value}. Можно использовать
@var{other-vars} для установки других переменных влияющих
на подсветку, кроме рассмотренных выше 5 переменных.
Each of these elements should have the form
@xref{Other Font Lock Variables}.
@end defvar

  Если подсветка в режиме делается путем добавления
@code{font-lock-face} свойств, нужно установить @code{font-lock-defaults}
в @code{(nil t)} для выключения автоматической подсветки.
Но, это не обязательно; возможна совмещать подсветку некоторых вещей
с использованием свойств @code{font-lock-face} с автоматической
подсветки других частей текста.

@node Search-based Fontification
@subsection Search-based Fontification

Подсветка основанная на поиске.

  Переменная @code{font-lock-keywords} напрямую управляет подсветкой
основанной на поиске, которая как правило определяется через
@var{keywords} элемент в @code{font-lock-defaults}.

@defvar font-lock-keywords
Значение этой переменной это список ключевых слов для подсветки. Lisp
программы не должны устанавливать эту переменную напрямую. Как правило,
значение автоматически устанавливается режимом Font Lock, используя
@var{keywords} элемент в @code{font-lock-defaults}. Значение может
быть изменено с использованием функций @code{font-lock-add-keywords} и
@code{font-lock-remove-keywords} (@pxref{Customizing Keywords}).
@end defvar

  Каждый элемент @code{font-lock-keywords} определяет как найти
определенный текстовые конструкции, и как подсветить эти конструкции.
Font Lock обрабатывает элементы @code{font-lock-keywords} по одному, и для
каждого находятся и обрабатываются все совпадения. Как правило, если
какая-то часть была подсвечена, ее подсветка не перезаписывается,
последующими совпадениями (то есть каждый элемент текста относится к 1
элементу поиска); но можно определить и другое поведение
с использованием @var{override} элемента a @var{subexp-highlighter}.

Каждый элемент @code{font-lock-keywords} должен представляться одной
из следующих форм:

@table @code
@item @var{regexp}
Подсвечиваются все совпадение @var{regexp} шрифтом
@code{font-lock-keyword-face}.  Например,

@example
;; @r{Highlight occurrences of the word @samp{foo}}
;; @r{using @code{font-lock-keyword-face}.}
"\\<foo\\>"
@end example

Стоит аккуратно строить такие регулярные выражения; плохо
написанные шаблоны могут можно сильно замедлить работу
редактора. Функция @code{regexp-opt} (@pxref{Regexp Functions})
полезна для полезна для построения регулярного выражения
совпадающего с несколькими ключевыми словами.

@item @var{function}
Находит текст путем вызова @var{function}, и подсвечивает
найденные совпадения шрифтом @code{font-lock-keyword-face}.

Когда @var{function}, она получает 1 аргумент, ограничение
на поиск; она должна начать поиск в текущей точке, не и
искать дальше ограничения. Функция должна вернуть
не-@code{nil}, если поиск успешен, и установить результат
совпадения (не ясно каким именно образом ???, вероятно в результате)
для описания найденных совпадений. Возвращение @code{nil}
является сигналом того, что поиск ничего не дал. 

При выполнении подсветки @var{function} будет вызываться повторно
с одни и тем же ограничением в точках где закончился предыдущий вызов,
пока поиск дает результаты. В случае
неудачи @var{function} не нужно вновь переставлять точку (point, курсор).

@item (@var{matcher} . @var{subexp})
В этом типе элемента, @var{matcher} регулярное выражение или
функция, как вышеописанные.  The @sc{cdr},
@var{subexp}, определяет какое подвыражение @var{matcher} должно
быть подсвечено (вместо всего текста совпадения с @var{matcher}).

@example
;; @r{Highlight the @samp{bar} in each occurrence of @samp{fubar},}
;; @r{using @code{font-lock-keyword-face}.}
("fu\\(bar\\)" . 1)
@end example

Если использовать @code{regexp-opt} для создания регулярного выражения
@var{matcher}, можно использовать @code{regexp-opt-depth} (@pxref{Regexp
Functions}) для вычисления значения @var{subexp}.

@item (@var{matcher} . @var{facespec})
В элементе данного вида, @var{facespec} выражение чье значение
определяет шрифт используемый для подсветки.  В простейшем случае,
@var{facespec} Lisp переменная (a symbol) чье значение имя шрифта.

@example
;; @r{Highlight occurrences of @samp{fubar},}
;; @r{using the face which is the value of @code{fubar-face}.}
("fubar" . fubar-face)
@end example

Но, @var{facespec} может вычисляться в список следующей формы:

@example
(face @var{face} @var{prop1} @var{val1} @var{prop2} @var{val2}@dots{})
@end example

@noindent
Для определения шрифта @var{face} и различных дополнительных
свойств текста которые должны быть добавлена к тексту совпадения.
В этом случае нужно добавить имена дополнительных свойств в
@code{font-lock-extra-managed-props}, чтобы эти свойства очищались
когда они перестают быть актуальными. Либо можно
установить @code{font-lock-unfontify-region-function} в
функцию которая очистит такие свойства. @xref{Other Font Lock
Variables}.

@item (@var{matcher} . @var{subexp-highlighter})
В данном виде элемента, @var{subexp-highlighter} список который
определяет как подсвечивать найденные @var{matcher} совпадения.
@var{subexp-highlighter} должен иметь форму:

@example
(@var{subexp} @var{facespec} [@var{override} [@var{laxmatch}]])
@end example

@sc{car}, @var{subexp}, число определяющее какое подвыражение совпадения
подсвечивать (0 означает все совпадение). @var{facespec},
выражение которое определяет шрифт, как описывалось выше.


@var{override} и @var{laxmatch}, необязательные флаги.  Если
@var{override} @code{t}, элемент должен перезаписывать подсветку
сделанную предыдущими элементами @code{font-lock-keywords}.
Если значение @code{keep}, тогда каждый символ подсвечивается, если
он еще не был подсвечен другим элементом. Если значение @code{prepend},
шрифт определенный @var{facespec} добавляется в начало
свойства @code{font-lock-face}. Если значение @code{append},
шрифт добавляется в конец свойства @code{font-lock-face}.

Если @var{laxmatch} не-@code{nil}, означает, что не является ошибкой
отсутствие подвыражения с номером @var{subexp} в @var{matcher}.
Очевидно, подсветки при для такого выражения не будет. Но
подсветка других подвыражений (и других регулярных выражений)
продолжится. Если @var{laxmatch} и @code{nil} и подвыражение
отсутствует, тогда сообщается об ошибке и выполнение
подсветки основанной на поиске заканчивается.

Ниже несколько примеров элементов данного вида:

@smallexample
;; @r{Highlight occurrences of either @samp{foo} or @samp{bar}, using}
;; @r{@code{foo-bar-face}, even if they have already been highlighted.}
;; @r{@code{foo-bar-face} should be a variable whose value is a face.}
("foo\\|bar" 0 foo-bar-face t)

;; @r{Highlight the first subexpression within each occurrence}
;; @r{that the function @code{fubar-match} finds,}
;; @r{using the face which is the value of @code{fubar-face}.}
(fubar-match 1 fubar-face)
@end smallexample

@item (@var{matcher} . @var{anchored-highlighter})
В данном виде элемента, @var{anchored-highlighter} определяет
как подсвечивать текст который следует за совпадением найденным
@var{matcher}. То есть совпадение найденное по @var{matcher}, выступает
в виде отправной точки (якоря) для дальнейшего поиска заданного
@var{anchored-highlighter}. @var{anchored-highlighter} это
список следующей формы:

@example
(@var{anchored-matcher} @var{pre-form} @var{post-form}
                        @var{subexp-highlighters}@dots{})
@end example

Где, @var{anchored-matcher}, как @var{matcher}, регулярное
выражение или функция.  После нахождение совпадения @var{matcher},
курсор(точка) в конце совпадения.  Теперь, Font Lock вычисляет
@var{pre-form}.  Затем ищет совпадения  для
@var{anchored-matcher} и использует @var{subexp-highlighters} для подсветки.
@var{subexp-highlighter} описано выше.  В завершении,
Font Lock вычисляет @var{post-form}.

Форма @var{pre-form} и @var{post-form} могут быть использованы для
инициализации до и очистки после @var{anchored-matcher}. Как правило,
@var{pre-form} используется для перемещения курсора на позицию
относительно совпадения @var{matcher}, до того как начать поиск
@var{anchored-matcher}. @var{post-form} может быть
использована для возврата курсора перед продолжением поиска
@var{matcher}.

После того как Font Lock вычислит @var{pre-form},
@var{anchored-matcher} не ищет дальше окончания строки. Но если
@var{pre-form} вернет позицию в буфере больше чем позиция
курсора после вычисления @var{pre-form}, тогда возвращенная
@var{pre-form} позиция используется в качестве ограничения поиска.
Как правило не стоит возвращать позицию дальше окончания строк,
то есть не стоит делать чтобы @var{anchored-matcher} переходила
на другую строку.

Например,

@smallexample
;; @r{Highlight occurrences of the word @samp{item} following}
;; @r{an occurrence of the word @samp{anchor} (on the same line)}
;; @r{in the value of @code{item-face}.}
("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))
@end smallexample

В примере, @var{pre-form} и @var{post-form} are @code{nil}.  Поэтому
поиск @samp{item} начинается в конце поиска
@samp{anchor}, и поиск последующих совпадений @samp{anchor}
продолжается там где завершился поиск @samp{item}.

@item (@var{matcher} @var{highlighters}@dots{})
Данный вид элемента определят несколько список @var{highlighter}
подсветки для одного @var{matcher}. @var{highlighter} может
быть типа @var{subexp-highlighter} или @var{anchored-highlighter}
которые описаны выше.

Например,

@smallexample
;; @r{Highlight occurrences of the word @samp{anchor} in the value}
;; @r{of @code{anchor-face}, and subsequent occurrences of the word}
;; @r{@samp{item} (on the same line) in the value of @code{item-face}.}
("\\<anchor\\>" (0 anchor-face)
                ("\\<item\\>" nil nil (0 item-face)))
@end smallexample

@item (eval . @var{form})
Здесь @var{form}  выражение которое должно быть вычислено
при первом использовании @code{font-lock-keywords} в буфере.
Значением должно быть одна из форм описанных в таблице.
@end table

@strong{Warning:} Не стоит проектировать элемент
@code{font-lock-keywords} для совпадения с текстом который переходит
через строку, так как такие элементы работают не надежно см.
@xref{Multiline Font Lock}.

Можно использовать @var{case-fold} в @code{font-lock-defaults}
для задания @code{font-lock-keywords-case-fold-search},
который указывает должна ли подсветка выполнятся с игнорированием
регистра.

@defvar font-lock-keywords-case-fold-search
Не-@code{nil} означает, что поиск регулярных выражений
@code{font-lock-keywords} должен выполняться без
учета регистра.
@end defvar

@node Customizing Keywords
@subsection Customizing Search-Based Fontification

  Настройка ключевых слов.

  Можно использовать @code{font-lock-add-keywords} для добавления
правил подсветки основанной на поиске в основной режим,
и @code{font-lock-remove-keywords}, для удаления
правил.

@defun font-lock-add-keywords mode keywords &optional how
Функция добавляет @var{keywords} для подсветки, для текущего
буфера или для основного режима @var{mode}. Аргумент @var{keywords}
должен быть списком с тем же форматом, что и
@code{font-lock-keywords}.

Если @var{mode} символ команды основного режима, как
@code{c-mode}, при включении Font Lock в @var{mode},
@var{keywords} будут добавлены в @code{font-lock-keywords}.
Вызов с не-@code{nil} значением @var{mode} верно, только
в @file{~/.emacs}.

Если @var{mode} @code{nil}, функция добавляет @var{keywords} в
@code{font-lock-keywords} текущего буфера.  Такой способ вызова
@code{font-lock-add-keywords} как правило используется в перехватчиках
режимов.

По умолчанию, @var{keywords} добавляются в начало
@code{font-lock-keywords}.  Если необязательный аргумент @var{how}
равен @code{set}, то значения @code{font-lock-keywords} заменяются.
Если @var{how} любое другое не-@code{nil} значение, то @var{keywords}
добавляются в конец @code{font-lock-keywords}.

Некоторые режимы предоставляют дополнительные возможности которые
можно использовать для подсветки.  Например переменные
@code{c-font-lock-extra-types}, @code{c++-font-lock-extra-types},
@code{java-font-lock-extra-types}.

@strong{Warning:} Команда основного режима не должна вызывать даже не
явно @code{font-lock-add-keywords}, кроме как через перехватчик
режима. (Так как это приведет к некорректному поведению некоторых
дополнительных режимов.) Основной режим должен задавать правила
подсветки основанной на поиске через @code{font-lock-keywords}.
@end defun

@defun font-lock-remove-keywords mode keywords
Функция удаляет @var{keywords} из @code{font-lock-keywords} для
текущего буфера или основного режима @var{mode}.  Как и в
@code{font-lock-add-keywords}, @var{mode} должно быть командой
основного режима или @code{nil}.  Все предупреждения и требования для
@code{font-lock-add-keywords} применимы и для этой функций.  Аргумент
@var{keywords} должны точно совпадать с теми который использовались в
@code{font-lock-add-keywords}.
@end defun

  Например, следующий код добавляет два шаблона подсветки для C
режима: один подсвечивает @samp{FIXME}, даже в комментария, и другой
подсвечивает @samp{and}, @samp{or} и @samp{not} как ключевые слова.

@smallexample
(font-lock-add-keywords 'c-mode
 '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
   ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))
@end smallexample

@noindent
Данный пример влияет только на C режим. Для добавления этого
шаблона в C режим @emph{and} (и) все его дочерние режимы, нужно:

@smallexample
(add-hook 'c-mode-hook
 (lambda ()
  (font-lock-add-keywords nil
   '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
     ("\\<\\(and\\|or\\|not\\)\\>" .
      font-lock-keyword-face)))))
@end smallexample

@node Other Font Lock Variables
@subsection Other Font Lock Variables

Другие переменные режима Font Lock.

  Данный раздел описывает другие переменные, которые основной режим
может установить с помощью @var{other-vars} в
@code{font-lock-defaults} (@pxref{Font Lock Basics}).

@defvar font-lock-mark-block-function
Если значение не-@code{nil}, то оно должно быть функцией, вызываемой
без аргументов, и которая выбирает объемлющий регион текста, дял
пересчета подсветки по команде @kbd{M-o M-o}
(@code{font-lock-fontify-block}).

Функция сообщает о выборе путем размещения региона.  Регион нужно
выбрать так, чтобы пересчет подсветки дал хороший результат, но при
этом он не должен быть настолько большим, чтобы пересчет был
долгим. Обычно используется @code{mark-defun} для режимов
программирования или @code{mark-paragraph} для текстовых режимов.
@end defvar

@defvar font-lock-extra-managed-props
Переменная определяет дополнительные свойства (не те что
@code{font-lock-face}), которые должны контролироваться режимом Font
Lock. Значение используется @code{font-lock-default-unfontify-region},
которая иначе контролирует только @code{font-lock-face}
свойства. Дополнительные свойства для можно задавать как через
@var{facespec} в @code{font-lock-keywords}, так и добавляя их в список
данной переменной.  @xref{Search-based Fontification}.
@end defvar

@defvar font-lock-fontify-buffer-function
Функция для подсветки буфера. Значение по умолчанию
@code{font-lock-default-fontify-buffer}.
@end defvar

@defvar font-lock-unfontify-buffer-function
Функция для очистки подсветки буфера. Используется при выключении Font
Lock режима. Значение по умолчанию
@code{font-lock-default-unfontify-buffer}.
@end defvar

@defvar font-lock-fontify-region-function
Функция используется для подсветки региона. Функция должна принимать
два аргумента, начала и конца региона, и необязательный третий
аргумент @var{verbose}. Если @var{verbose} не-@code{nil}, функция
должна печатать статусное сообщение. Значение по умолчанию
@code{font-lock-default-fontify-region}.
@end defvar

@defvar font-lock-unfontify-region-function
Функция используется для снятия подсветки с региона. Должна получать 2
параметр начало и конец регион. Значение по умолчанию
@code{font-lock-default-unfontify-region}.
@end defvar

@defvar font-lock-flush-function
Функция используется для того, чтобы пометить, что подсветка регион
устарела. Должна получать 2 параметр начала и конец региона. Значение
по умолчанию @code{font-lock-after-change-function}.
@end defvar

@defvar font-lock-ensure-function
Функция гарантирует что подсветка региона буфера выполнена.
Должна получать 2 параметра начало и конце региона. Значение
по умолчанию вызывает @code{font-lock-default-fontify-buffer}
если подсветки в буфере нет; в результате выполняется
подсветка доступной части буфера.
@end defvar

@defun jit-lock-register function &optional contextual
Функция предписывает Font Lock режиму запускать 
@var{function} всегда когда делается или обновляется подсветка.
@var{function} вызывается до вызова основной функции подсветки,
и получает 2 аргумента @var{start} и @var{end} региона, для
которого выполняется подсветка.

Не обязательный аргумент @var{contextual}, если не-@code{nil},
предписывает Font Lock режиму всегда обновлять подсветку (основываясь
на синтаксисе) соответствующей части буфера, а не только измененных
строк. Аргумент как правило опускается.
@end defun

@defun jit-lock-unregister function
Если @var{function} была добавлена с использованием @code{jit-lock-register},
то эта функция выполняет обратное действие и убирает выполнение @var{function}.
@end defun

@node Levels of Font Lock
@subsection Levels of Font Lock

  Уровни Font Lock режима.

  Некоторые основные режимы поддерживают три уровня подсветки. Уровни
можно определять используя список символов в @var{keywords} в
@code{font-lock-defaults}. Каждый уровень определяет один уровень
подсветки; пользователь может выбрать один из уровней задавая
@code{font-lock-maximum-decoration} (@pxref{Font Lock,,, emacs, the
GNU Emacs Manual}). Выбранный символ используется для инициализации
@code{font-lock-keywords}.

  Ниже описаны соглашения по определению уровней подсветки:

@itemize @bullet
@item
Уровень 1: (level 1) подсветка определений функций, файловых директив
(include, import и другие), строки и комментарии.  Данный уровень
должен быт максимально быстрым, поэтому подсвечиваются только наиболее
важные компоненты.

@item
Уровень 2: (level 2) в дополнение к уровню 1, подсвечиваются все
ключевые слова языка программирования и значения именованных
констант. Цель данного режима подсветить ключевые слова
(синтаксические или семантические).

@item
Уровень 3: (level 3) в дополнение к уровню 2, подсвечивает символы
которые определены в определениях функций и переменных, и имена всех
встроенных функций.
@end itemize

@node Precalculated Fontification
@subsection Precalculated Fontification

  Предварительно посчитанная подсветка.

  Некоторые основные режимы, такие как @code{list-buffers} и
@code{occur} создают текст буфера программно. И в них проще
поддерживать Font Lock режим, если определять шрифты текста в момент
вставки текста в буфер.

  Это можно сделать путем определения шрифтов в тексте используя
свойство текста  @code{font-lock-face} (@pxref{Special
Properties}). Когда режим Font Lock активен, данное свойство
задает подсветку(отображение), как свойство @code{face}, если же
режим Font Lock отключен свойство @code{font-lock-face} никак
не влияет на отображение.

  В режиме можно использовать @code{font-lock-face} для части текста
совмещая с использованием обычных механизмов Font Lock режима. Но если
режим не использует обычные механизмы, он не должен задавать
@code{font-lock-defaults}.

@node Faces for Font Lock
@subsection Faces for Font Lock
@cindex faces for font lock
@cindex font lock faces

  Шрифты для Font Lock режима.

  Font Lock режим может выполнять подсветку используя любые шрифты, но
в Emacs определено несколько шрифтов специально для Font Lock. Эти
шрифты @dfn{Font Lock faces} рассматриваются ниже. Данные шрифты могут
использоваться основными режимами для синтаксической подсветки
(выделения) вне Font Lock режима (@pxref{Major Mode Conventions}).

 Каждый из рассматриваемых символов является именем шрифта и именем
переменной значением по умолчанию которой является сам символ.  Таким
образом, значением по умолчанию @code{font-lock-comment-face} является
@code{font-lock-comment-face}.

  Шрифты перечислены с описанием их назначения, и упорядочены в
порядке их заметности (prominence) от большего к меньшему. Если
синтаксические категории в режиме не соответствуют описанным
назначениям, можно использовать описанный порядок в качестве
руководства при назначении шрифтов.

@table @code
@item font-lock-warning-face
@vindex font-lock-warning-face
используется для необычных конструкций, или таких которые сильно
изменяют значение другого текста, такие как @samp{;;;###autoload} в
Emacs Lisp и @samp{#error} в C.

@item font-lock-function-name-face
@vindex font-lock-function-name-face
для определений и объявлений функций.

@item font-lock-variable-name-face
@vindex font-lock-variable-name-face
для определений и объявлений переменных.

@item font-lock-keyword-face
@vindex font-lock-keyword-face
для ключевых слов имеющих синтаксическое значение, например @samp{for} и
@samp{if} в C.

@item font-lock-comment-face
@vindex font-lock-comment-face
для комментариев.

@item font-lock-comment-delimiter-face
@vindex font-lock-comment-delimiter-face
для разделителей комментариев, например @samp{/*} и @samp{*/} в C@. Как правило
наследуется от @code{font-lock-comment-face}.

@item font-lock-type-face
@vindex font-lock-type-face
для имен пользовательских типов.

@item font-lock-constant-face
@vindex font-lock-constant-face
для имен констант, например @samp{NULL} в C.

@item font-lock-builtin-face
@vindex font-lock-builtin-face
для имен встроенных функций.

@item font-lock-preprocessor-face
@vindex font-lock-preprocessor-face
для команд препроцессора. Как правило, наследуется от
@code{font-lock-builtin-face}.

@item font-lock-string-face
@vindex font-lock-string-face
для строковых констант.

@item font-lock-doc-face
@vindex font-lock-doc-face
для строк документации в коде. Как правило наследуется от
@code{font-lock-string-face}.

@item font-lock-negation-char-face
@vindex font-lock-negation-char-face
для легко пропускаемых (видимо имеется ввиду не заметных)
символов отрицания.
@end table

@node Syntactic Font Lock
@subsection Syntactic Font Lock
@cindex syntactic font lock

 Подсветка основанная на синтаксисе (далее синтаксическая подсветка).

 Подсветка по синтаксису использует таблицу синтаксиса (@pxref{Syntax
Tables}) для нахождения и подсветки синтаксически значимого
текста. Если такая подсветка активна, она выполняется после подсветки
поиском. Переменная @code{font-lock-syntactic-face-function} описанная
ниже, определяет синтаксические конструкции для
подсветки. Предусмотрено несколько переменных для управления
синтаксической подсветкой. Устанавливать их нужно с использованием
@code{font-lock-defaults} (@pxref{Font Lock Basics}).


  Когда, Font Lock выполняет синтаксическую подсветку части текста,
первым делом вызывается функция задаваемая @code{syntax-propertize-function}.
Основные режимы могут использовать ее для применения 
@code{syntax-table}, чтобы переписать таблицу синтаксиса буфера,
если необходимо.  @xref{Syntax Properties}.

@defvar font-lock-keywords-only
Если значение переменной не-@code{nil}, Font Lock не выполняет
синтаксическую подсветку, только подсветку основанную на поиске по
@code{font-lock-keywords}. Обычно значение переменной устанавливается
Font Lock режимом по элементу @var{keywords-only} из
@code{font-lock-defaults}.
@end defvar

@defvar font-lock-syntax-table
Переменная хранит таблицу синтаксиса, используемую для подсветки
комментариев и строк. Обычно значение переменной устанавливается на
основе элемента @var{syntax-alist} из @code{font-lock-defaults}. Если
значение @code{nil}, синтаксическая подсветка использует синтаксическую
таблицу буфера (значение возвращается функцией @code{syntax-table}; @pxref{Syntax
Table Functions}).
@end defvar

@defvar font-lock-syntactic-face-function
Если значение не-@code{nil}, то оно должно быть функцией которая
определяет какой шрифт нужно использовать для данного элемента (может быть строка
или комментарий). Обычно значение устанавливается через  @var{other-vars} из
@code{font-lock-defaults}.

Функция вызывается с 1 аргументов, состоянием разбора в точке,
возвращаемого @code{parse-partial-sexp}, и должна возвращать шрифт.
По умолчанию используются @code{font-lock-comment-face} fдля
комментариев @code{font-lock-string-face} для строк (@pxref{Faces for
Font Lock}).
@end defvar

@node Multiline Font Lock
@subsection Multiline Font Lock Constructs
@cindex multiline font lock

  Подсветка много-строчных конструкций.
  
  Как правило, элементы @code{font-lock-keywords}, не должны выдавать
совпадений с переводом строки; они работают не корректно, потому
что Font Lock обычно обрабатывает только часть буфера, и может пропустить
много-строчную конструкцию которая находится на пересечении границ
сканирования.  (Как правило сканирование начинается с начала строки).

  Создание элементов, которые совпадают с много-строчными конструкция
и работают корректно требует: 1. правильных @emph{identification} (определения)
и 2. правильного @emph{rehighlighting} (обновления подсветки).
Первое требует, чтобы Font Lock находил все много-строчные конструкции.
Второе требует, чтобы Font Lock верно обновлял подсветку всего текста
имеющего отношение к конструкции, при изменении таких конструкций ---
например, если часть текста, которая была частью много-строчной конструкции
перестал быть ее частью. Эти два аспекта сильно связаны, и как правило
реализация одного из них, приводит к работе второго. Но, нужно проверить
оба.

  Есть 3 способа, удостоверится в корректной идентификации много-строчных
конструкций:

@itemize
@item
Добавить функцию в  @code{font-lock-extend-region-functions} которая
выполнит @emph{identification} (идентификацию) и расширит область сканирования
так, чтобы сканируемый текст, никогда не начинался или закачивался внутри
много-строчной конструкции.
@item
Использовать перехватчик @code{font-lock-fontify-region-function}
для расширения области сканирования, аналогично предыдущему пункту.
@item
Каким-то образом выполнять идентификацию много строчной конструкции
при добавлении в буфер (до того как font-lock попробует выполнить его
подсветку), и помечать ее @code{font-lock-multiline}, который будет
указывать font-lock, что не нужно начинать или останавливать сканирование
внутри этой конструкции.
@end itemize

  Есть 3 способа, обновить подсветку много-строчных конструкций:

@itemize
@item
Поместить @code{font-lock-multiline} свойство на конструкцию. Что
приведет к обновлению подсветки всей конструкции если любая ее часть
изменится. В некоторых случаях это можно сделать автоматически,
установкой переменной @code{font-lock-multiline},  (which see ??)
@item
Проверить, что @code{jit-lock-contextually} установлена и доверить
ей такую работу. Она будет выполнять обновление части конструкции
которая связана с произведенными изменениями, и выполняется с
небольшой задержкой. Такой способ работает, только если
подсветка разных частей много-строчной конструкции не зависит
от следующих строк. Так как @code{jit-lock-contextually} активно
по умолчанию, данное решение может быть удобным.
@item
Поместить @code{jit-lock-defer-multiline} свойство на конструкцию.
Данный способ работает только если используется @code{jit-lock-contextually}
и с некоторой задержкой перед обновлением подсветки, но как и
@code{font-lock-multiline} он работает в ситуации когда подсветка зависит от
следующих строк.

(Под следующими строками возможно подразумеваются внутренние строки
конструкции).
@end itemize

@menu
* Font Lock Multiline::         Разметка много-строчных конструкций с использованием свойств текста.
* Region to Refontify::         Настройка региона обновления подсветки при изменении буфера.
@end menu

@node Font Lock Multiline
@subsubsection Font Lock Multiline

  Подсветка для много-строчных конструкций.

  Одним и способов гарантировать обновление подсветки много-строчной
конструкции является маркировка такой конструкции текстовым свойством @code{font-lock-multiline}. Свойство должно быть задано и не-@code{nil} для текста являющегося
частью много-строчной конструкции.

  Когда Font Lock собирается выполнить подсветку части текста,
сначала он расширяет границу области подсветки чтобы она
не попадала на текст помеченный свойством @code{font-lock-multiline}.
Затем режим удаляет @code{font-lock-multiline} свойства из
области и выполняет подсветку. Спецификация подсветки требует
пере-установки данного свойства всякий раз, когда необходимо.

  @strong{Warning:} не стоит использовать свойство @code{font-lock-multiline} 
для больших областей текста, так как это сильно замедлит выполнение подсветки.

@defvar font-lock-multiline
Если значение переменной @code{font-lock-multiline}  @code{t}, Font
Lock попытается добавить свойство @code{font-lock-multiline} 
автоматически на много-строчные конструкции. Решение не универсальное,
и отчасти замедляет Font Lock. Кроме того, некоторые много-строчные конструкции
могут быть пропущены, или помечены более большие или более маленькие области
чем требуется.

Для элементов @var{matcher} у которых функция, функция должна
удостоверится что в совпадение 0, попадает вся много-строчная
конструкция, даже если только малая часть должна быть подсвечена.
Часто проще добавить @code{font-lock-multiline} вручную.
@end defvar

   Свойство @code{font-lock-multiline} предназначено, для корректного
обновление подсветки, оно не идентифицирует много-строчные конструкции
автоматически.  Идентификация требует чтобы Font Lock режим работал
над достаточно большими областями текста за раз. Во многих случаях так
и будет, что дает ощущение, что много-строчные конструкции магическим
образом работают. Если @code{font-lock-multiline}, то такое ощущение
усилится, так как найденные конструкции будут потом обновляться.  Но
все же корректно они не работают.


  Для правильного нахождения много-строчных конструкций, нужно вручную
разместить свойство @code{font-lock-multiline} для текста, до того как
Font Lock его обработает или использовать функцию
@code{font-lock-fontify-region-function}.

@node Region to Refontify
@subsubsection Region to Fontify after a Buffer Change

  Область для обновления подсветки.

  При изменении буфера, по умолчанию регион для которого Font Lock должен
обновить подсветку определяется минимальным количеством целых строк, которые
были затронуты изменением. Хотя такой способ хорошо, работает
для большинства случаем, иногда он не срабатывает --- например, когда
изменение меняет синтаксическое значение текста предыдущей строки.

  Можно увеличить (или даже уменьшить) регион для обновления установкой
следующей переменной:

@defvar font-lock-extend-after-change-region-function
Это локальная для буфера переменная должна быть @code{nil} или функцией
которую Font Lock вызовет для определения региона обновления подсветки.

Функция получает три параметра, стандартные для региона @var{beg},
@var{end}, и @var{old-len} из @code{after-change-functions}
(@pxref{Change Hooks}). Функция должна вернуть cons ячейку из начальной
и конечной позиций буфера (в таком порядке) региона для обновления
подсветки, или @code{nil} (что значит выбрать регион обычным способом).
Функции нужно сохранить курсор (точку), данные по совпадению и
текущее ограничение. Возвращаемый регион может начинаться или
заканчивать в середине строки.

Так как функция вызывается при любом изменении буфера, она должна быть
быстрой.
@end defvar

@node Auto-Indentation
@section Automatic Indentation of code

Автоматическая расстановка отступов.

 Для языков программирования, важной функцией основного режима является
автоматическая расстановка отступов. Расстановка состоит из 2-х частей:
определение корректного отступа для строки, и определения когда нужно
выполнить пересчет отступа для строки. По умолчанию, Emacs выполняет
пересчет при вводе символа из множества @code{electric-indent-chars}, которое
по умолчанию содержит только символ перевода строки. Основные режимы
могут добавлять символы в @code{electric-indent-chars} в соответствие
с синтаксисом языка.

 Определение корректного отступа контролируется функцией
@code{indent-line-function} (@pxref{Mode-Specific Indent}).
Для некоторых режимов, корректный отступ не может быть точно
определен, потому что являются значимой (синтаксически, например блоки в python),
в результате чего разная расстановка отступов оказывается верной,
но имеет разные значения. В этом случае, режим должен установить
@code{electric-indent-inhibit}, чтобы гарантировать, что
отступы не будут изменяться, пока пользователь не запросит их
явно.

Написание хорошей функции расстановки отступов, может быть в большей степени
это является темным искусством. Многие авторы основных режимов начинают с
написания простой функции расстановки отступов, работающей для простых случаев,
например путем сравнения с отступом предыдущей строки. Для большинства языков
программирования, которые не основаны на строках, такая функция плохо
масштабируется и добавление поддержки новых случаев делает функцию
все более и более сложной, и в результате получается большая сложная,
не поддерживаемая  функция которую все боятся трогать.

Хорошая функция расстановки отступов как правило требует разбора текста, в
соответствии с синтаксисом языка. К счастью, не требуется детально разбирать
текст, как это выполняет компилятор, но при этом парсер используемый
в функции расстановки отступов должен быть снисходителен
к синтаксически не верному коду.

Хорошо поддерживаемые функции расстановки отступов разделяются на 2 категории,
те что выполняют разбор вперед с некоторой безопасной точки
до требуемой позиции и те что выполняют разбор назад от требуемой
точки. Не одна из категорий не является более хорошей чем другая,
разбор назад как правило более сложный чем разбор вперед потому что языки
программирования проектируются для разбора вперед, но для задач
расстановки отступов большим плюсом является отсутствие необходимости
угадывать безопасную начальную точку, и как правило требует меньше
текста для вычисления отступа, поэтому расчет будет меньше подвержен
влиянию ошибок в более ранней не связанной части кода. Разбор вперед
с другой стороны как правило легче и имеет возможность эффективно выполнить 
пересчет отступов для целого региона за один разбор.

Вместо того, чтобы писать свою функцию расстановки отступов с нуля,
как правило стоит попытаться использовать какую-нибудь из имеющихся
или воспользоваться общим движком расстановки отступов. К сожалению
таких движков не много. Код расстановки отступов CC-режимов (используемый
 C, C++, Java, Awk и некоторыми другими) был обобщен за годы, поэтому
если требуемый язык выглядит схожим образом с одним из этих языков,
стоит попробовать использовать этот движок.
@c FIXME: documentation?
Другой движок SMIE, использующий подход в духе Lisp выражений и
адаптированный для не-Lisp языков.

@menu
* SMIE::                        Простой движок расстановки отступов.
@end menu

@node SMIE
@subsection Simple Minded Indentation Engine
@cindex SMIE

SMIE пакет который предоставляет общую навигацию и движок расстановки
отступов. Основанный на простом парсере использующем простую грамматика с
предшествующим оператором(грамматику с приоритетом оператора)
(см. wiki operator precedence grammar), который позволяет основным режимам
расширять основанную на sexp навигацию Lisp на не-Lisp языки
и предоставляет простую в использовании но надежную автоматическую
расстановку отступов.

Грамматика с предшествующим оператором очень простая технология для
разбора в сравнении с другими общими техниками используемым в компиляторах.
Она имеет следующие характеристики: возможность парсинга очень ограничена,
как правило не может определить ошибки, но она является алгоритмически
эффективной и может парсится (разбираться) как вперед так и назад. На
практике это означает, что SMIE можно использовать для расстановки
отступов с парсингом в обратном порядке, предоставляя при этом
функциональность @code{forward-sexp} и @code{backward-sexp}, и может
относительно легко использоваться с синтаксически не корректным кодом.
Недостатком однако является, что большинство языков программирования не могут
быть корректно распаршены (разобраны) с использованием SMIE, как минимум
без применения специальных приемов (@pxref{SMIE Tricks}).

@menu
* SMIE setup::                  SMIE остановка и возможности.
* Operator Precedence Grammars::  Очень простая техника разбора (парсинга).
* SMIE Grammar::                Определения грамматики языка.
* SMIE Lexer::                  Определение знаков (токенов).
* SMIE Tricks::                 Обход ограничений парсера.
* SMIE Indentation::            Определения правил отступа.
* SMIE Indentation Helpers::    Вспомогательные функции для правил отступа.
* SMIE Indentation Example::    Типовые правила отступа.
* SMIE Customization::          Настройка отступов.
@end menu

@node SMIE setup
@subsubsection SMIE Setup and Features

Установка SMIE.

SMIE должен быть универсальным средством навигации по структуре
и реализации других возможностей основанных на синтаксической структуре кода,
в частности автоматической расстановки отступов. Главная точка входа
@code{smie-setup}  является функцией как правило вызываемой при
установке основного режима.

@defun smie-setup grammar rules-function &rest keywords
Устанавливает SMIE навигацию и расстановку отступов.
@var{grammar} таблица грамматики, генерированная @code{smie-prec2->grammar}.
@var{rules-function} множество правил для расстановки отступов используемое
@code{smie-rules-function}.
@var{keywords} дополнительные аргументы, которые могут включать следующие
ключевые слова:
@itemize
@item
@code{:forward-token} @var{fun}: Определяет использование лексер с прямым порядком.
@item
@code{:backward-token} @var{fun}: Определяет использование лексера с обратным порядком.
@end itemize
(Прим. ) Видимо имеется ввиду порядок разбора текста с начала к концу или с конца к началу.
@end defun

Вызова данной функции достаточно, чтобы команды
@code{forward-sexp}, @code{backward-sexp}, и @code{transpose-sexps}
могли правильно обработать структурные элементы, отличные от
парных скобок, которые могут быть обработаны с использованием синтаксических
таблиц. Например, если предоставленная грамматика, достаточно точная,
@code{transpose-sexps} , сможет корректно поменять местами
аргументы оператора @code{+}, учитывая правило приоритета в языке.

Вызова @code{smie-setup} достаточно чтобы работала расстановка отступов по TAB,
бала заполнена переменная @code{blink-matching-paren} для работы с элементами
наподобие @code{begin...end}, и были предоставлены некоторые команды
которые можно привязать в раскладке основного режима.

@deffn Command smie-close-block
Команда закрывает самый крайний открытый (и еще не закрытый) блок.
@end deffn

@deffn Command smie-down-list &optional arg
Команда аналогична @code{down-list}, но она обращает внимание
на вложенность токенов (прим. видимо части на которые разбирает текст лексер)
отличных от скобок, таких как @code{begin...end}.
@end deffn

@node Operator Precedence Grammars
@subsubsection Operator Precedence Grammars

Грамматика с приоритетом оператора просто задает для
каждого токена пару приоритетов: левый и правый.
Считается что @code{T1 < T2} если правый приоритет токена
@code{T1} меньше чем левый приоритет токена @code{T2}. Хорошим
способом прочитать @code{<} является запись с круглыми скобками,
если найдено  @code{... T1 something
T2 ...}, тогда оно должно быть разобрано как @code{... T1 (something T2 ...}
вместо @code{... T1 something) T2 ...}. Крайняя интерпретация
может относится к случаю @code{T1 > T2}. Если @code{T1 = T2},
это значит что токен T2 следует за T1 в одной синтаксической
конструкции, так как правило @code{"begin" = "end"}.
Такие пары приоритетов достаточны для выражения левой-ассоциативности
и правой-ассоциативности инфиксных операторов, вложенных
токенов таких как скобки и многих других случаев.

@c Let's leave this undocumented to leave it more open for change!
@c @defvar smie-grammar
@c The value of this variable is an alist specifying the left and right
@c precedence of each token.  It is meant to be initialized by using one of
@c the functions below.
@c @end defvar

@defun smie-prec2->grammar table
Функция получает @emph{prec2} грамматическую @var{table} и возвращает
ассоциативный список пригодный для использования в @code{smie-setup}.
@emph{prec2} @var{table} в свою очередь должна быть построена с
использованием одной из функций описанных ниже.
@end defun

@defun smie-merge-prec2s &rest tables
Функция получает несколько @emph{prec2} @var{tables} и объединяет их
в новую @emph{prec2} таблицу.
@end defun

@defun smie-precs->prec2 precs
Функция создает таблицу @emph{prec2}, из таблицы предшествования
@var{precs}. @var{precs} должна быть списком, отсортированным
по предшествованию (например @code{"+"} будет перед @code{"*"}), элементов
форм @code{(@var{assoc} @var{op} ...)}, где каждый @var{op} это
токен который действует как оператор; @var{assoc} ассоциативность которая может быть
@code{left}, @code{right}, @code{assoc}, или @code{nonassoc}.
Все операторы в заданном элементе относятся к одному
уровню предшествования и ассоциативности.
@end defun

@defun smie-bnf->prec2 bnf &rest resolvers
Функция позволяет определить грамматику используя BNF нотацию.
Она принимает описание @var{bnf} вместе с множеством правил
разрешения конфликтов @var{resolvers}, и возвращает
@emph{prec2} таблицу.

@var{bnf} список нетерминальных определений форм
@code{(@var{nonterm} @var{rhs1} @var{rhs2} ...)} где каждый @var{rhs}
не пустой список терминалов (токенов) или не-терминалов.

Не все грамматики допустимы:
@itemize
@item
@var{rhs} не может быть пустым списком (пустой список не нужен так как
SMIE позволяет любому нетерминалу совпасть с пустой строкой).
@item
@var{rhs} не может иметь 2 последовательных не терминала: каждая
пара не-терминалов должна быть разделена терминалом (токеном).
Это фундаментальное требование для оператора грамматики предшествования.
@end itemize

Кроме того, могут быть конфликты:
@itemize
@item
Возвращаемая таблица @emph{prec2} хранит ограничение между парами токенов, и
для любой пары может быть представлено только 1 ограничение:
T1 < T2,
T1 = T2, или T1 > T2.
@item
Токен может быть @code{opener} (открыватель) (что-то вроде открывающей скобки),
@code{closer} (закрыватель) (как закрывающая скобка), или @code{neither} (ничего) из двух
(как инфиксный оператор или токен как @code{"else"}).
@end itemize

Конфликты предшествования могут быть разрешены с помощью @var{resolvers},
которые должны быть списком таблиц @emph{precs} (см. @code{smie-precs->prec2}):
для каждого конфликта предшествования, в которых таблицы @code{precs}
определяют подробные ограничения, затем конфликты разрешаются с использованием
этих ограничений вместо конфликтных, иначе сообщается о конфликте и
произвольно выбирается одно из конфликтных ограничений, а остальные просто игнорируются.
@end defun

@node SMIE Grammar
@subsubsection Defining the Grammar of a Language
@cindex SMIE grammar
@cindex grammar, SMIE

Грамматика SMIE
Основной способ определения SMIE грамматики языка через
определение новой глобальной переменной которая хранит таблицу
предшествования полученную по заданному множеству правил BNF.
Например, определение грамматики для маленького Pascal-подобного
языка может выглядеть следующим образом:
@example
@group
(require 'smie)
(defvar sample-smie-grammar
  (smie-prec2->grammar
   (smie-bnf->prec2
@end group
@group
    '((id)
      (inst ("begin" insts "end")
            ("if" exp "then" inst "else" inst)
            (id ":=" exp)
            (exp))
      (insts (insts ";" insts) (inst))
      (exp (exp "+" exp)
           (exp "*" exp)
           ("(" exps ")"))
      (exps (exps "," exps) (exp)))
@end group
@group
    '((assoc ";"))
    '((assoc ","))
    '((assoc "+") (assoc "*")))))
@end group
@end example

@noindent
Несколько замечаний:

@itemize
@item
Вышеописанная грамматика не явно упоминает синтаксис вызова функции:
SMIE автоматически разрешит все последовательности sexps, такие
как идентификаторы, балансировка скобок или блоков @code{begin ... end}
для применения где угодно когда угодно.
@item
Категория @code{id} не содержит правой части: что не значит, что
возможно совпадение только с пустой строки, как было сказано
выше любая последовательность sexps может появится когда
угодно где угодно.
@item
Так как не терминалы не могут появится последовательно в грамматике BNF,
сложно корректно обработать токены терминаторы, поэтому вышеописанная грамматика
использует @code{";"} в качестве разделителя выражений, с которым
SMIE может справится хорошо.
@item
Разделители используемые в последовательностях
(такие как @code{","} и @code{";"} выше) лучше всего определяются
в BNF правилах вроде @code{(foo (foo "separator" foo) ...)}
которые приводят к конфликтам предшествования, которые потом можно
разрешить явными правилами @code{(assoc "separator")}.
@item
Правило  @code{("(" exps ")")} не нужно для соединения скобок в пары, так
как SMIE соединит в пары все символы, которые отмечены как имеющие
синтаксис пар в таблице синтаксиса. Вместо этого данное правило (вместе с
определением @code{exps}) реализует ограничение для @code{","},
которые должны появляться только внутри скобок.
@item
Предпочтительно задавать несколько таблиц @emph{precs} разрешения
конфликтов, чтобы BNF часть грамматики могла определить связанные
предшествования где возможно.
(при. не очень понятно, что имеется ввиду)
@item
Если нет хорошей причины для предпочтения @code{left} или
@code{right}, стоит помечать операторы как ассоциативные,
используя @code{assoc}. По этой причине @code{"+"} и @code{"*"}
выше определены как @code{assoc}, хотя формально в языке они определяются
как лево-ассоциативные.
@end itemize

@node SMIE Lexer
@subsubsection Defining Tokens
@cindex SMIE lexer
@cindex defining tokens, SMIE

  SMIE лексер(лексический анализатор).

SMIE содержит лексический анализатор, который использует синтаксические
таблицы следующим образом: любая последовательность
символов, которые имеют синтаксис слова или символа рассматриваются
как токены, и любые последовательности символов
Такой лексер является хорошей начальной точкой, но
редко на самом деле правильно работает для любого
заданного языка. Например, оно будет рассматривать @code{"2,+3"}
как композицию из 3 токенов @code{"2"}, @code{",+"}, и @code{"3}".

Для описания правил лексера для требуемого языка в SMIE, понадобится
2 функции, одна для получения следующего токена, и вторая для получения
предыдущего токена. Эти функции как правило пропускают пробелы и комментарии.
Функция просто возвращает по 1 токену и смещается по тексту.
Возвращаемый токен как правило является просто строкой, но
в принципе может быть чем угодно.
Например:
@example
@group
(defvar sample-keywords-regexp
  (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
@end group
@group
(defun sample-smie-forward-token ()
  (forward-comment (point-max))
  (cond
   ((looking-at sample-keywords-regexp)
    (goto-char (match-end 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-forward "w_")
              (point))))))
@end group
@group
(defun sample-smie-backward-token ()
  (forward-comment (- (point)))
  (cond
   ((looking-back sample-keywords-regexp (- (point) 2) t)
    (goto-char (match-beginning 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-backward "w_")
              (point))))))
@end group
@end example

Обратите внимание, что эти лексеры возвращают пустую строку
перед скобками. Так происходит потому, что SMIE автоматически
заботится о скобках определенных в синтаксической таблице.
Точнее, если лексер возвращает @code{nil} или пустую строку,
SMIE пытается обработать соответствующий текст, как sexp в
соответствии с синтаксической таблицей.

@node SMIE Tricks
@subsubsection Living With a Weak Parser

Хитрые приемы работы со SMIE

Техника разбора (парсинга) используемая SMIE не позволяет
токенам вести себя по разному в разных ситуациях. Для большинства
языков программирования, это выражается в конфликты приоритета при конвертировании
BNF грамматики.

Время от времени, такие конфликты можно обойти путем выражения
грамматики немного по другому. Например, для Modula-2
естественно выглядящая грамматика может выглядеть
следующим образом:

@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (cases (cases "|" cases)
         (caselabel ":" insts)
         ("ELSE" insts))
  ...
@end example

Но при этом возникнет конфликт для @code{"ELSE"}: с другой стороны,
правило IF подразумевает (среди прочего), что @code{"ELSE" = "END"};
но с другой стороны, если @code{"ELSE"}, с другой стороны поскольку
@code{"ELSE"} встречается в @code{cases}, который появляется слева от END
получаем, что @code{"ELSE" > "END"}. Этот конфликт можно решить
используя:
@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ("CASE" exp "OF" cases "ELSE" insts "END")
        ...)
  (cases (cases "|" cases) (caselabel ":" insts))
  ...
@end example
или
@example
  ...
  (inst ("IF" exp "THEN" else "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (else (insts "ELSE" insts))
  (cases (cases "|" cases) (caselabel ":" insts) (else))
  ...
@end example

Переработка грамматика с целью разрешить конфликты имеет недостатки, потому что,
SMIE полагает что грамматика отражает логическую структуру кода, более
предпочтительно держать BNF близкой к предполагаемому синтаксическому дереву.

В другой раз, после тщательного рассмотрения можно решить, что
конфликт не серьезен и просто разрешить их через аргумент @var{resolvers}
@code{smie-bnf->prec2}. Обычно из-за того что грамматика неоднозначная, конфликты
не влияют на множество программ описываемых грамматикой, а только на
то, как программа будет разобрана (распаршена). Такая ситуация
типичная для разделителей и ассоциативных инфиксных операторов, где
напрашивается добавление чего-то наподобие @code{'((assoc "|"))}
для разрешения конфликта. Бывает и конфликты которые
не могут быть разрешены, но на практике маловероятно, что это
станет проблемой.

В заключение, во многих случаях конфликты останутся, несмотря на все
усилия по реструктуризации грамматики. Но не стоит отчаиваться, хотя
парсер и не получается сделать более ``умным'', лексер можно
сделать настолько ``умным'', насколько нужно. Таким образом, решением
будет посмотреть на токены затронутые конфликтом и разделить один из
них на 2 (или более) различных токенов. Например, если в грамматике
нужно различить два несовместимых использования токена @code{"begin"},
можно сделать чтобы лексер возвращал разные токены (например @code{"begin-fun"} и @code{"begin-plain"})
в зависимости от найденного вида @code{"begin"}. Таким
образом работа различия случаев будет переложена на лексер, которому
придется учитывать окружающий текст для определения конкретного случая.

@node SMIE Indentation
@subsubsection Specifying Indentation Rules
@cindex indentation rules, SMIE

SMIE для расстановки отступов

Основываясь на предоставленной грамматике, SMIE может автоматически
выполнять расстановку отступов без дополнительных усилий. Но на практике,
автоматически полученный механизм не будет достаточно хорошим и его
придется  до-настраивать.

Расстановка отступов SMIE основывается на идее, что расстановка
отступов должна быть максимально локальной. Для этого используется
идея виртуальных (@emph{virtual}) отступов, которая заключается в том
что для каждой точки программы вычисляется виртуальный отступ, который
бы был у точки, если бы она стояла в начале строки. При этом,
если точная находится в начале строки, то ее виртуальный отступ
совпадает с ее реальным отступом. Например, для правила расстановки
отступов SMIE после @code{@{} в C не учитывает, находится ли @code{@{}
на отдельной строке или нет, эти оба случая рассматриваются с учетом
вычисленного виртуального отступа перед @code{@{}.

Другой важной концепцией является понятие родителя @emph{parent}:
Родитель @emph{parent} токена, это главный (головной) токен ближайшей
синтаксической конструкции содержащей текущий токен. Например, родителем
@code{else} будет @code{if}, к которому он относится, а родителем
@code{if} будет ведущий (главный) токен содержащей его конструкции.
Команда @code{backward-sexp} перемещается от токена на его родителя, но
есть нюанс: для открывающих @emph{openers} токенов (которые начинают
конструкцию например @code{if}, @code{begin}), нужно перейти на точку перед
токеном, а для других токенов на точку за токеном.
@code{backward-sexp} останавливается на точке перед родительским токено
если он открывающий токен для интересуемого токена, и в точке за родителем
в другом случае.

Расстановка отступов SMIE определяется функцией которая получает
2 аргумента @var{method} и @var{arg}, где значение @var{arg} и ожидаемое
возвращаемое значение зависит от @var{method}.

@var{method} может быть:
@itemize
@item
@code{:after}, в этом случае @var{arg} токен и функция должна
возвращать @var{offset} который должен быть отступом после @var{arg}.
@item
@code{:before}, в этом случае @var{arg} токен и функция
должна вернуть @var{offset} который будет отступом для @var{arg}.
@item
@code{:elem}, в этом случае функция должна вернуть или отступ
для использования для отступов аргументов функции (если @var{arg}
символ @code{arg}) или базовый шаг отступа (если  @var{arg} символ
@code{basic}).
@item
@code{:list-intro}, в этом случае @var{arg} токен и функция должна
возвращать не-@code{nil} если за токеном следует список выражений
(не разделенных другими токенами), а не за выражением.
@end itemize

Когда @var{arg} токен, функция вызывается в точке, непосредственно
перед токеном.  Возвращаемое значение @code{nil} всегда означает возврат к 
поведению по умолчанию, поэтому функция должна возвращать @code{nil} для
аргументов которые она не поддерживает.

@var{offset} может быть:
@itemize
@item
@code{nil}: использовать правило расстановки отступов по умолчанию.
@item
@code{(column . @var{column})}: indent to column @var{column}.
@item
@var{number}: смещение на @var{number}, относительно базового токена который
текущий токен для @code{:after} и родительский для @code{:before}.
@end itemize

@node SMIE Indentation Helpers
@subsubsection Helper Functions for Indentation Rules

Вспомогательные функции для правил расстановки отступов.

SMIE предоставляет разные функции спроектированный специально
для использования для правил расстановки отсупов (некоторые из
них ломаются при использовании в других контекстах). Имена этих
функций начинаются с префикса @code{smie-rule-}.

@defun smie-rule-bolp
Возвращает не-@code{nil} если текущий токен первый в строке.
@end defun

@defun smie-rule-hanging-p
Возвращает не-@code{nil} если текущий токен подвешенный @emph{hanging}.
Токен подвешенный @emph{hanging}, если он крайний в строке и
перед ним есть другие токены, одиночный токен в строке не является
подвешенным.
@end defun

@defun smie-rule-next-p &rest tokens
Возвращает не-@code{nil} если следующий токен среди @var{tokens}.
@end defun

@defun smie-rule-prev-p &rest tokens
Возвращает не-@code{nil} если предыдущий токен среди @var{tokens}.
@end defun

@defun smie-rule-parent-p &rest parents
Возвращает не-@code{nil} если текущий токен среди @var{parents}.
@end defun

@defun smie-rule-sibling-p
Возвращает не-@code{nil} если родитель текущего токена
его является предыдущим. Такое случай происходит например, когда
родитель @code{","}, просто предыдущая @code{","}.
@end defun

@defun smie-rule-parent &optional offset
Возвращает правильное смещение для выравнивания текущего
токена относительно родителя.
Если не-@code{nil}, @var{offset} должно быть натуральным числом
соответствующим требуемому смещению.
@end defun

@defun smie-rule-separator method
Сделать отступ текущего токена, рассматривая его как разделитель @emph{separator}.

Под разделителем @emph{separator}, понимается токен, чья единственная
задача разделять разные элементы внутри объемлющей синтаксической конструкции, и
которые не имеют какого-то семантического значения (т.е. такой токен
не будет присутствовать в абстрактном синтаксическом дереве).

Ожидается, что такой токен будет иметь ассоциативный синтаксис и будет
сильно привязан к своему синтаксическому родителю. Типичный пример
@code{","}  в списке аргументов (заключенного в скобки), или @code{";"}
в последовательности инструкций (заключенных в @code{@{...@}}
или @code{begin...end} блок).

@var{method} должен быть методом имя которого будет передано в
@code{smie-rules-function}.
@end defun

@node SMIE Indentation Example
@subsubsection Sample Indentation Rules

Пример функции расстановки отступов:

@example
(defun sample-smie-rules (kind token)
  (pcase (cons kind token)
    (`(:elem . basic) sample-indent-basic)
    (`(,_ . ",") (smie-rule-separator kind))
    (`(:after . ":=") sample-indent-basic)
    (`(:before . ,(or `"begin" `"(" `"@{")))
     (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "if")
     (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
          (smie-rule-parent)))))
@end example

@noindent
Несколько замечаний:

@itemize
@item
Первый случай означает, что будет использовать базовый способ вычисления отступа.
Если @code{sample-indent-basic} @code{nil}, тогда SMIE использует глобальную
@code{smie-indent-basic}. Основной режима напротив может установить
@code{smie-indent-basic} локально для буфера, но так делать не рекомендуется.


@item
Правило для токена @code{","} означает, что SMIE нужно попытаться
поступить умнее, если разделитель запятой помещен в начало строк.
Будет сделана попытка сделать отступ для разделителя, чтобы подравнять
код после запятой; например:

@example
x = longfunctionname (
        arg1
      , arg2
    );
@end example

@item
Правило для отступа после @code{":="} существует потому, что иначе
SMIE будет рассматривать @code{":="} как инфиксный оператор и будет
выравнивать правый аргумент с левым.

@item
Правило для отступа перед @code{"begin"} пример использования
виртуальной расстановки отступов: Данное правило используется когда
@code{"begin"} висящий hanging, что случается только, если begin не в
начале строки. Поэтому данное правило не используется когда для вычисления
отступа @code{"begin"}, а для вычисления отступа чего-то относительно
@code{"begin"}. В частности, данное правило изменяет отступ с:

@example
    if x > 0 then begin
            dosomething(x);
        end
@end example
на
@example
    if x > 0 then begin
        dosomething(x);
    end
@end example

@item
Привило для вычисления отступа перед @code{"if"} похоже на
правило для @code{"begin"}, но в этом правиле нужно рассматривать
@code{"else if"} как целый элемент, 
The rule for indentation before @code{"if"} is similar to the one for
@code{"begin"}, but where the purpose is to treat @code{"else if"},
чтобы выровнять как последовательность проверок, а не выполнять вложение
каждого if в предыдущий с отступом вправо. Данная функция выполняется
только если @code{"if"} не размещается на отдельной строке, для чего
используется проверка @code{smie-rule-bolp}.

Если известно что, @code{"else"} всегда выравнивается со своим @code{"if"}
и всегда помещается в начало строки, можно использовать более
эффективное правило:
@example
((equal token "if")
 (and (not (smie-rule-bolp))
      (smie-rule-prev-p "else")
      (save-excursion
        (sample-smie-backward-token)
        (cons 'column (current-column)))))
@end example

Преимуществом этого метода является то что выполняется повторное
использование отступа предыдущего @code{"else"}, вместо того, чтобы
проходить весь путь до @code{"if"} из последовательности.
@end itemize

@c In some sense this belongs more in the Emacs manual.
@node SMIE Customization
@subsubsection Customizing Indentation

Настройка SMIE

Если используется режим, отступы в котором выполняются с
использованием SMIE, можно выполнить настройку расчета отступа в
соответствии со своими предпочтениями. Можно выполнить настройку для
режима (используя @code{smie-config}), или для файла (используя
@code{smie-config-local} в локальной для файла переменной).

@defopt smie-config
Данная опция позволяет настроить расчет отступов для режима.
Значением будет ассоциативный список с элементами в форме
@code{(@var{mode} . @var{rules})}.  Справку по точной форме правил
можно найти в документации по переменной, или можно воспользоваться
командой @code{smie-config-guess}.
@end defopt

@deffn Command smie-config-guess
Команда пытается создать подходящие настройки для предпочитаемого
стиля отступов. Нужно просто вызвать команду находясь в файле в
котором уже заданы отступы в соответствии с предпочтениями.
@end deffn

@deffn Command smie-config-save
Данная команды вызывается после @code{smie-config-guess}, для
сохранения настроек в следующих сессиях.
@end deffn

@deffn Command smie-config-show-indent &optional move
Команда показывает правила, которые используются для вычисления
отступов в текущей строке.
@end deffn

@deffn Command smie-config-set-indent
Команда добавляет локальное правило для подгонки отступа в текущей строке. 
@end deffn

@defun smie-config-local rules
Функция добавляет @var{rules} в качестве правил расстановки отступов
в текущий буфер. Команда добавляет правила во все специфичные для
режима правила, определенные через @code{smie-config}.
Для определения специальных правил для определенного файла, нужно
добавить запись в локальную переменную файла в форме:
@code{eval: (smie-config-local '(@var{rules}))}.
@end defun


@node Desktop Save Mode
@section Desktop Save Mode
@cindex desktop save mode

Режим сохранения рабочего стола.

@dfn{Desktop Save Mode} это режим, позволяющий выполнять сохранения
состояние Emacs между сессиями.  Пользовательские команды используемые
в Desktop Save Mode описаны в GNU Emacs Manual (@pxref{Saving Emacs
Sessions,,, emacs, the GNU Emacs Manual}). Режимам, буферы которых
открывают файлы, поддерживают данный режим (возможность) по умолчанию.

Для буферов которые не открывают файлы (прим. содержимое в которых
генерируется) для сохранения состояния нужно, установить локальную для
буфера переменную @code{desktop-save-buffer} в не-@code{nil} значение.

@defvar desktop-save-buffer
Если данная локальная переменная для буфера не-@code{nil}, состояние
буфера будет сохранено в файл сохранения при выполнении сохранения
состояния Emacs. Если значение функция, то она вызывается при
сохранении состояния Emacs с параметром @var{desktop-dirname}, и
полученное значение сохраняется в файл сохранения вместе с состоянием
буфера (прим. может быть имеется ввиду что это и будет рассматриваться
как состояние). Если вместе с дополнительной информацией возвращаются
имена файлов, то они должны быть отформатированы с использованием
вызова:

@example
(desktop-file-name @var{file-name} @var{desktop-dirname})
@end example

@end defvar

Для буферов которые не открывают файлов, чтобы выполнить
восстановление основной режим должен определить функцию которая его
выполнит, и данная функция должна быть помещена в ассоциативный список
@code{desktop-buffer-mode-handlers}.

@defvar desktop-buffer-mode-handlers
Ассоциативный список с элементами:

@example
(@var{major-mode} . @var{restore-buffer-function})
@end example

Функция @var{restore-buffer-function} должна вызываться
с аргументами

@example
(@var{buffer-file-name} @var{buffer-name} @var{desktop-buffer-misc})
@end example

и должна возвращать восстановленный режим.
В примере @var{desktop-buffer-misc} значение возвращаемое функцией
такой как @code{desktop-save-buffer}.
@end defvar
