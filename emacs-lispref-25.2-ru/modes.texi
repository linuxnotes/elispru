@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2017 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@documentencoding UTF-8
@documentlanguage ru
@c@documentencoding UTF-8

@c\usepackage{babel}
@c\usepackage[utf8]{inputenc}
@c\usepackage[russian]{babel}

@node Modes
@chapter Основные и Второстепенные режимы
@cindex mode

  Режим (@dfn{mode}) это набор определений который добавляет в Emacs полезные функции.
Различают 2 вида режимов: второстепенные режимы @dfn{minor modes},
которые предоставляют функции которые можно включить и выключить во время редактирования;
и Основные режимы @dfn{major modes}, которые используются для редактирования или взаимодействия
с определенным видом текста. Буфер может иметь равно один Основной @dfn{major
mode} в каждый момент времени (основной режим можно менять).

Данная глава описывает как писать Основные и Второстепенные режимы, как показывать их
в строке режимов, и как режимы выполняют функции перехватчики (hook) предоставленные пользователем.
Связанные темы раскладки и синтаксические таблицы описаны в разделах:
@ref{Keymaps}, и @ref{Syntax Tables}.

@menu
* Hooks::             Как использовать функции перехватчики; как написать код который предоставляет перехватчики.
* Major Modes::       Определение Основных режимов.
* Minor Modes::       Определение Второстепенных режимов.
* Mode Line Format::  Настройка отображения текста для строки режимов.
* Imenu::             Предоставление menu для определений из буфера.
* Font Lock Mode::    Подсветка синтаксиса в режиме.
* Auto-Indentation::  Как научить Emacs выполнять отступы в Основном режиме.
* Desktop Save Mode:: Как режимы могут сохранять состояние буфера между сессиями Emacs.
@end menu

@node Hooks
@section Hooks Перехватчики (Ловушки)
@cindex hooks

  Перехватчик @dfn{hook} это переменная которая может хранить функцию
или функции, которые могут быть вызваны в определенном случае
выполняемой программой. В Emacs перехватчики используются для
настройки. Как правило, перехватчики задаются в init файле
(@pxref{Init File}), но Lisp программы тоже могут задавать
перехватчики.  В @xref{Standard Hooks}, описывается часть стандартных
переменных перехватчиков.

@cindex normal hook
@cindex Обыкновенный перехватчик
  Большинство перехватчиков являются обыкновенными @dfn{normal
hooks}. Это переменные, которые содержат списки функций вызываемых без
аргументов. По соглашению, если имя перехватчика оканчивается на
@samp{-hook}, это означает что перехватчик является обыкновенным. Мы
пытаемся сделать все перехватчики обыкновенными, насколько это
возможно, чтобы их можно было использовать единообразно.

  Команда каждого основного режима (например list-mode), поддерживает
выполнение обыкновенного перехватчика, называемого перехватчик
@dfn{mode hook}, как часть завершающего шага инициализации. Это
позволяет просто настроить режим переназначив уже заданные для буфера
значения локальных переменных.  (первоначально они устанавливаются
при включении режима, после чего в перехватчике они могут быть
переопределены). Большинство вспомогательных режимов так же выполняют
перехватчик режима при включении. Перехватчики могут использоваться и в другом
контексте. Например перехватчик @code{suspend-hook} выполняется перед
тем как Emacs остановит (suspend) свою работу (@pxref{Suspending Emacs}).

  Рекомендуется добавлять функции перехватчики к перехватчику путем
вызова @code{add-hook} (@pxref{Setting Hooks}). Функция перехватчик
может быть любым из допустимых функций для которых поддерживается
вызов @code{funcall} (@pxref{What Is a Function}). Большинство
переменных обычных перехватчиков имеют начальное значение void; и
@code{add-hook} умеет обрабатывать данную ситуацию. Используя
@code{add-hook} можно добавлять перехватчики как глобально, так и
локально для буфера.

@cindex abnormal hook
@cindex Необычный перехватчик
  Если имя переменной перехватчика не оканчивается на @samp{-hook},
это является признаком того, что данная переменная @dfn{abnormal hook}
(необычный перехватчик).  Это означает, что функции перехватчика
вызываются с аргументами, или их возвращаемые значение каким-то
образом используются. Документация перехватчика описывает как функции
вызываются.  Можно использовать @code{add-hook} для добавления функций
к необычному перехватчику, но функция должна быть написана в
соответствии с соглашением по вызову.  Условлено, что имена для
необычных перехватчиков оканчиваются на @samp{-functions}.

@cindex single-function hook
@cindex перехватчик с одной функцией
Если имя переменной заканчивается на @samp{-function} это значит что
значение переменной просто одна функция, а не список
функций. @code{add-hook} не может быть использована для изменения
таких перехватчиков @emph{single function hook}.  Для изменения таких
перехватчиков нужно использовать @code{add-function} (@pxref{Advising Functions}).

@menu
* Running Hooks::    Как выполнить перехватчик.
* Setting Hooks::    Как поместить и удалить функцию в перехватчик.
@end menu

@node Running Hooks
@node Запуск перехватчиков
@subsection Running Hooks

  В данном разделе рассматривается функция @code{run-hooks}, которая используется
для запуска обыкновенных перехватчиков. А так же функции для запуска
различных видов необычных перехватчиков.

@defun run-hooks &rest hookvars
Функция принимает одно или более имя переменной обычного перехватчика,
и запускает все перехватчики по очереди. Каждый аргумент должен быть
символом который является переменной обычного перехватчика. Аргументы обрабатываются
согласно их порядку.

Если переменная перехватчик non-@code{nil} (не @code{nil}) значение переменной
должно быть списком функций. @code{run-hooks} вызывает все функции по очереди без
аргументов.

Значение переменной перехватчика может быть отдельная функция, как
лямбда выражение так и символ с определенной функцией, которые @code{run-hooks}
вызовет. Но такое использование устарело.

Если переменная перехватчик локальная для буфера, будет использовано локальное
для буфера значение. Но, если локальная переменная содержит элемент @code{t}, то будут
вызваны функции и из глобальной переменной.
@end defun

@defun run-hook-with-args hook &rest args
Данная функция запускает необычные перехватчика путем вызова всех функций перехватчика
@var{hook}, с передачей каждому параметров @var{args}.
@end defun

@defun run-hook-with-args-until-failure hook &rest args
Функция запускает необычный перехватчик путем вызова всех функций
перехватчика по очереди, если какая-то из функций вернет @code{nil}
то, выполнение перехватчика прекратится и оставшиеся функции вызваны
не будут. Каждая функция вызывается с аргументами @var{args}.  Если
функция останавливается из-за того, что какая-то из функций
перехватчика не выполнилась, то функция возвращает @code{nil} иначе
не-@code{nil} значение.
@end defun

@defun run-hook-with-args-until-success hook &rest args
Функция запускает необычный перехватчик путем вызова всех функций
перехватчика по очереди, с остановкой если она из них вернет
не-@code{nil} значение.  Каждая функция вызывается с аргументами
@var{args}.  Если функция остановилась потому что одна из функций
вернула не-@code{nil} значение, то это значение и возвращается, иначе
возвращается @code{nil}.
@end defun

@node Setting Hooks
@node Установка перехватчиков
@subsection Setting Hooks

  Ниже приведет пример использования перехватчика для режима для включения Auto Fill режима
при включении Lisp Interaction режима:

@example
(add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)
@end example

@defun add-hook hook function &optional append local
Функция предоставляет удобный способ добавить функцию @var{function} к перехватчику @var{hook}.
@var{function} может быть любой Lisp функцией которая может принимать правильное для @var{hook}
количество аргументов.  Например,

@example
(add-hook 'text-mode-hook 'my-text-hook-function)
@end example

@noindent
добавляет @code{my-text-hook-function} к перехватчику с именем @code{text-mode-hook}.

Если @var{function} уже есть в перехватчике @var{hook} (сравнение выполняется с использованием функции
@code{equal}), тогда @code{add-hook} не выполняет второе добавление.

Если @var{function} содержит не-@code{nil} свойство
@code{permanent-local-hook}, тогда @code{kill-all-local-variables} (или смена основного режима)
не будет удалять ее из локальных значений переменной перехватчика.

Для обычного перехватчика, функции перехватчики должно быть написаны
так, чтобы порядок их вызова не имел значения. Зависимость от порядка
может привести к проблемам.  Однако порядок выполнения предсказуем:
обычно @var{function} помещается в начала списка перехватчика, поэтому
она выполняется первой (barring another @code{add-hook} call). Если
необязательный параметр @var{append} не-@code{nil}, новая функция
перехватчик добавляется в конец списка и выполняется после других.

@code{add-hook} обрабатывает случаи когда @var{hook} void или
значение одна функция, она устанавливает или изменяет значение на
список функций.

Если @var{local}  не-@code{nil}, тогда @var{function} добавляется к локальному
для буфера списку перехватчика, а не к глобальному. При этом создается перехватчик локальный для буфера
и добавляется @code{t} к локальному перехватчику, чтобы вызывались и функции из глобального (см. run-hook).
@end defun

@defun remove-hook hook function &optional local
Функция удаляет @var{function} из переменной перехватчика
@var{hook}.  Функция сравнивает @var{function} с элементами @var{hook}
используя @code{equal}, поэтому это работает для символов и лямбда выражения.

Если @var{local} не-@code{nil}, то @var{function} удаляется из локального для буфера перехватчика,
а не из глобального списка перехватчика.
@end defun

@node Major Modes
@section Major Modes (Основные режимы)
@cindex major mode
@cindex основной режим

@cindex major mode command
@cindex команда основного режима
  Основной режим настраивает Emacs для редактирования и взаимодействия
с определенным видом текста. Каждый буфер имеет ровно один основной
режим в каждый момент времени. Каждый основной режим связан с
@dfn{major mode command} (командой основного режима), чье имя должно
оканчиваться на @samp{-mode}. Такая команда выполняет переключение на
соответствующий режим текущего буфера, путем установки различных
локальных для буфера переменных таких как локальная раскладка(keymap).
@xref{Major Mode Conventions}. Стоит отметить, что в отличие от
вспомогательных режимов основные режимы не возможно ``выключить'',
можно только переключиться на другой основной режим.

  Наименее специализированный основной режим называется
@dfn{Fundamental mode}, который не содержит каких-то определений или
настроек переменных.

@deffn Command fundamental-mode
Это команда переключения в основной режим Fundamental. В отличие от
других команд режимов, она @emph{не} запускает никаких перехватчиков
(@pxref{Major Mode Conventions}), поскольку не предполагается
настройка данного режима.
@end deffn

Проще всего создать основной режим, если воспользоваться макросом
@code{define-derived-mode}, который создаст новый режим как вариант
уже существующего основного режима. @xref{Derived
Modes}. Рекомендуется использовать @code{define-derived-mode} даже в
том случае если новый режим не является очевидной производной другого
режима, так как макрос автоматически обеспечивает выполнения множества
соглашений по кодированию. @xref{Basic Major Modes}, for common modes
to derive from.

Стандартное дерево каталогов GNU Emacs Lisp содержит код для нескольких
основных режимов, в таких файлах как @file{text-mode.el},
@file{texinfo.el}, @file{lisp-mode.el}, и @file{rmail.el}. Вы можете
изучить эти библиотеки, чтобы разобраться как пишутся режимы.

@defopt major-mode
Локальное для буфера значение данной переменной хранит символ текущего
основного режима. Значением по умолчанию является режим по умолчанию
для новых буферов. Обычное значение по умолчанию
@code{fundamental-mode}.

Если значение по умолчанию @code{nil}, тогда при создании нового буфера,
например с таким образом @kbd{C-x b} (@code{switch-to-buffer}), для нового
буфера устанавливается основной режим такой же как у предыдущего выбранного буфера.
За исключением случаев, если символ основного режима предыдущего буфера содержит
свойство @code{mode-class} со значением @code{special}, тогда для нового буфера
основным режимом выставляется Fundamental (@pxref{Major Mode Conventions}).
@end defopt

@menu
* Major Mode Conventions::  Соглашения по кодированию .
* Auto Major Mode::         Как Emacs автоматически выбирает основной режим.
* Mode Help::               Получение справки по использованию режима.
* Derived Modes::           Определение основного режима на основе другого основного режима.
* Basic Major Modes::       Режимы на основе которых наиболее часто строятся другие режимы.
* Mode Hooks::              Перехватчики запускаемые в конце функций режимов.
* Tabulated List Mode::     Родительский режим для буферов с табличными данными..
* Generic Modes::           Определение простого основного режима с поддержкой комментариев
                            и Font Lock режимом (режим выполняющий подсветку некоторых конструкций).
* Example Major Modes::     Текстовые и Lisp режимы.
@end menu

@node Major Mode Conventions
@node Соглашения по основным режимам
@subsection Major Mode Conventions
@cindex major mode conventions
@cindex соглашения по основным режимам
@cindex conventions for writing major modes
@cindex соглашения по написанию основных режимов

  Код каждого основного режима должен следовать ряду соглашений,
включающих соглашения по инициализации локальной раскладки (local
keymap) и синтаксической таблицы (syntax table), именах функций,
переменных, и перехватчиков.

  Если используется @code{define-derived-mode}, он берет на себя заботу о
выполнении многих из соглашений автоматически. @xref{Derived Modes}. Отметим
также, что режим Fundamental является исключением для многих из соглашений,
потому что представляет состояние Emacs по умолчанию.

Далее приводится частичный список соглашений. Каждый основной режим
должен стремиться к согласованности с остальными основными режимами, так
как это делает Emacs в целом более последовательным и понятным. Не возможно
перечислить все возможные моменты где могут возникнуть вопросы согласованности;
в случае если разработчики Emacs укажут где ваш режим отклоняется от соглашений,
пожалуйста сделайте свой режим совместимым.

@itemize @bullet
@item
Определяйте команду основного режима оканчивающейся на @samp{-mode}.
Вызываемая без аргументов команда должна переключать текущий буфер в в
новый режим устанавливая раскладку (keymap), синтаксическую таблицу, и
локальные для буфера переменные. Команда не должна изменять содержимое
буфера.

@item
Напишите комментарий(документацию) для команды, которая описывает команды доступные в
данном режиме. @xref{Mode Help}.

Строка документации может включать особые подстроки, @samp{\[@var{command}]},
@samp{\@{@var{keymap}@}}, и
@samp{\<@var{keymap}>}, которые позволяют справке автоматически определять и показывать
пользовательские настройки привязки клавиш.  @xref{Keys in
Documentation}.

@item
Команда основного режима должна начинаться вызовом
@code{kill-all-local-variables}.  Который запускает обычный перехватчик
@code{change-major-mode-hook}, который уничтожает переменные буфера предыдущего
основного режима.  @xref{Creating Buffer-Local}.

@item
Команда основного режима должна присвоить переменной @code{major-mode}
символ команды основного режима. На основе этого значения @code{describe-mode}
определяет какая документация должна быть показана.

@item
Команда основного режима должна присвоить переменной @code{mode-name}
``удобное''(``pretty'') название режима, обычно являющееся строкой
(см. @ref{Mode Line Data}, с описание других возможных вариантов).
Это имя режима будет отображаться в строке режима.

@item
@cindex functions in modes
@cindex функции в режимах
Поскольку все глобальные имена находятся в одном пространстве имен, все
глобальные переменные, константы, и функции которые относятся к режиму должны
иметь имена, которые начинаются с имени режима (или с его сокращения если имя
длинное). @xref{Coding Conventions}.

@item
В основном режиме предназначенном для редактирования структурированного текста,
например программ, отступы соответствующие структуре вероятно будет полезными.
Поэтому стоит установит для @code{indent-line-function} переменной подходящее
значение, и вероятно настроить другие переменные отвечающие
за расстановку отступов. @xref{Auto-Indentation}.

@item
@cindex keymaps in modes
@cindex привязки клавиш в режимах
Основной режим как правило должен иметь свою собственную раскладку, которая
используется как локальная для всех буферов с данным режимом. Команда
основного режима должная вызывать @code{use-local-map} для установки
локальной раскладки. @xref{Active Keymaps} для получения
более полной информации.

Данная раскладка должна быть перманентно загруженной в глобальной
переменной с именем @code{@var{modename}-mode-map}. Как правило библиотека
определяющая режим устанавливает эту переменную.

@xref{Tips for Defining}, для получения советов по установки
значения переменной отвечающей за раскладку в режиме.

@item
Комбинации клавиш в основном режиме обычно должно начинаться с
@kbd{C-c}, за которым следует контрольный символ или цифра, или @kbd{@{},
@kbd{@}}, @kbd{<}, @kbd{>}, @kbd{:} или и@kbd{;}. Другие символы пунктуации
зарезервированы для второстепенных режимов, и обычные буквы зарезервированы
для пользователей.

Основной режим можно так же переназначить @kbd{M-n}, @kbd{M-p} и
@kbd{M-s}. Привязки @kbd{M-n} и @kbd{M-p} должны быть разновидностями
движения вперед и назад, что однако, не обязательно означает перемещение
курсора.

В основном режиме допускается переопределение стандартных комбинаций
если предоставляемые команды делают схожие действия но более подходят
для текста с которым должен работать режим. Например, основной режим
для редактирования программ может переопределить @kbd{C-M-a} для перехода
в начало функции способом который подходит для редактируемого языка.

Кроме того допускается переопределять редко используемые в данном
режиме клавиши. Например, режим минибуфера переопределяет @kbd{M-r},
чье обычное назначение (прим. @code{move-to-window-line-top-bottom})
редко может быть использовано в минибуфере. Основные режимы такие как
Dired или Rmail которые не выполняют непосредственную работу с текстом
могут вполне обосновано переопределять буквы и другие печатные символы
для выполнения команд.

@item
Основные режимы для редактирования текста не должны определять для @key{RET}
действия отличные от вставки новой строки. Однако, вполне нормально для
специальных режимов в которых не выполняется редактирование текста, таких
как Dired, переопределить @key{RET} для выполнения совершенно
других действий.

@item
Основной режим не должен изменять параметр, которые должен определить
пользователь в соответствии со своими предпочтениями, такие как
использование Auto-Fill режима. Оставьте это на усмотрение пользователя.
Однако, основной режим должен настроить другие переменные таким образом,
чтобы режим Auto-Fill был полезен в случае @emph{если} (@emph{if}) пользователь
решит его использовать.

@item
@cindex syntax tables in modes
@cindex синтаксические таблицы в режимах
Режим может использовать свою собственную синтаксическую таблицу или
использовать общую вместе с другими связанными режимами. Если режим
имеет собственную таблицу, то она должна хранится в переменной
@code{@var{modename}-mode-syntax-table}.  @xref{Syntax Tables}.

@item
В режимах для языков которые содержат комментарии, нужно установить
переменные которые определяют синтаксис комментариев. @xref{Options for
Comments,, Options Controlling Comments, emacs, The GNU Emacs Manual}.

@item
@cindex abbrev tables in modes
@cindex Таблицы сокращений в режимах
Режим может содержать свою таблицу сокращений или использовать общую с
другими связанными режимами. Если режим имеет собственную таблицу, то
она должна хранится в переменной  @code{@var{modename}-mode-abbrev-table}.
Если команда основного режима определяет какие-то сокращения должен быть
установлен в @code{t} аргумент флаг @var{system-flag} функции
@code{define-abbrev} используемой для определения сокращений.
@xref{Defining Abbrevs}.

@item
Режим должен определять как подсвечивать режим Font Lock, путем
установки локальной для буфера переменной @code{font-lock-defaults}
(@pxref{Font Lock Mode}).

@item
Каждый начертание шрифта(face, дальше просто начертание) который
определят режим, должен наследоваться, если это возможно, от
существующего в Emacs начертания.
@xref{Basic Faces}, и @ref{Faces for Font Lock}.

@item
Режим должен определить как Imenu будет находить определение разделов
буфера, путем установки локальной (для буфера) переменных
@code{imenu-generic-expression}, и
@code{imenu-prev-index-position-function} и
@code{imenu-extract-index-name-function} или переменной
@code{imenu-create-index-function} (@pxref{Imenu}).

@item
Режим может задать локальное значение для @code{eldoc-documentation-function},
чтобы определить как режим ElDoc будет обрабатывать данный режим.

@item
Режим может определить как завершать разные ключевые слова добавив один или
более локальных перехватчиков в специальный перехватчик
@code{completion-at-point-functions}.  @xref{Completion in Buffers}.

@item
@cindex buffer-local variables in modes
@cindex локальные (для буфера) переменные в режимах
Что бы сделать переменную локальной для буфера, следует использовать
@code{make-local-variable} в основной функции режима, а не
@code{make-variable-buffer-local}. @code{make-variable-buffer-local}
делает переменную локальной для всех буферов в которых она устанавливается,
что будет влиять и на буферы в других режимах. Такой глобальный эффект
является не желательным для режима. @xref{Buffer-Local Variables}.

За редким исключением, единственный оправданный способ использования
@code{make-variable-buffer-local} в Lisp пакете для переменных, которые
используются только в этом пакете. Использование этой функции на переменных
используемых другими пакетами может приводить к конфликтам.

@item
@cindex mode hook
@cindex major mode hook
@cindex перехватчик режима
@cindex основной перехватчик режима
Каждый основной режим должен иметь нормальный  @dfn{mode hook} с именем
@code{@var{modename}-mode-hook}. В конце команда режима должна вызывать
команда @code{run-mode-hooks}. Которая вызывает обыкновенный перехватчик
@code{change-major-mode-after-body-hook}, перехватчик режима, после которого
нормальный перехватчик @code{after-change-major-mode-hook}.
@xref{Mode Hooks}.

@item
Команда основного режима может может начинаться с вызова нескольких
команд других основных режимов (называемых @dfn{parent mode} родительские)
после чего изменить некоторые из их настроек. Выполняющий это ражим
называется @dfn{derived mode} (дочерний). Рекомендуется, но не требуется
делать дочерние режимы путем использования макроса
@code{define-derived-mode}. Такой режим должен вызывать команду родительского
режима внутри формы @code{delay-mode-hooks}. (При использовании
@code{define-derived-mode} это делается автоматически.) @xref{Derived
Modes}, and @ref{Mode Hooks}

@item
В случае необходимости выполнения каких-то специфичных действий при
переключении на другой режим, данный режим должен установить локальную
(для буфера) переменную @code{change-major-mode-hook}
(@pxref{Creating Buffer-Local}).

@item
Если режим предназначен для работы только со специальным текстом созданным
самим режимом (не как обычно набранного пользователем или внешнего файла),
тогда для символа команды основного режима должно быть задано свойство
@code{mode-class} со значением @code{special}.
Код для задания:

@kindex mode-class @r{(property)}
@cindex @code{special} modes
@example
(put 'funny-mode 'mode-class 'special)
@end example

@noindent
Таким образом указав Emacs, что новые буферы созданные из буфера в режиме
Funny mode не нужно запускать в режиме Funny mode, даже если значение
по умолчанию свойства @code{major-mode}  @code{nil}. Значение
@code{nil} для свойства @code{major-mode} предполагает использование
основного режима текущего буфера при создании новых буферов
(@pxref{Auto Major Mode}), но для специальных
@code{special} режимов вместо этого используется Fundamental mode.
Режимы такие как Dired, Rmail, и Buffer List используют данную особенность.

Функция @code{view-buffer} не включает дополнительный режим View для
буферов у которых mode-class задан как special, потому что такие режимы
обычно предоставляют свои привязки для просмотра (см. View mode).

Макрос @code{define-derived-mode} автоматически помечает дочерний режим
как специальный если родительский режим специальный.
@xref{Basic Major Modes}.

@item
С помощью добавления элемента в @code{auto-mode-alist}
можно задать определения имен файлов для которых режим будет
использоваться по умолчанию (@pxref{Auto Major Mode}). Если
режим загружается через autoload, нужно поместить добавление
элемента в @code{auto-mode-alist}, в тот же файл где вызывается @code{autoload}.
Если используются autoload cookie для команды режима, так же нужно использовать
autoload cookie для формы добавления элемента (@pxref{autoload cookie}).
Если autoload не используется, добавление в @code{auto-mode-alist} можно
выполнить в файле с определением режима.

@item
@cindex mode loading
@cindex Загрузка режима
Форма первого уровня (top-level) файла в котором определяется режим,
должна позволять многократное выполнение без негативных последствий.
Например, стоит использовать @code{defvar} или @code{defcustom} для установки
переменных режима, таким образом значения переменных не будут переопределены
если они уже имеют значения (@pxref{Defining Variables}).

@end itemize

@node Auto Major Mode
@node Автоматический выбор основного режима
@subsection How Emacs Chooses a Major Mode
@subsection Как Emacs выбирает основной режим
@cindex major mode, automatic selection
@cindex основной режим, автоматический выбор

Когда Emacs открывает файл, оно автоматически выбирает основной режим
основываясь на информации об имени файла или информации в самом файле.
Также обрабатываются локальные переменные определенные в тексте файла.

@deffn Command normal-mode &optional find-file
Функция устанавливает подходящий основной режим и значение локальных переменных
для текущего буфера. В этой функции сначала вызывается @code{set-auto-mode}
(см. ниже), затем запускается функция @code{hack-local-variables}, которая
разбирает и затем связывает или вычисляет локальные переменные файла
(@pxref{File Local Variables}).

Если значение параметра @var{find-file} функии @code{normal-mode} не @code{nil},
тогда @code{normal-mode} считает, что она была вызвана из @code{find-file} и в этом
случае выполняется обработка локальных переменных в @samp{-*-} и в конце файла.
Переменная @code{enable-local-variables} включает или выключает данный
функционал. @xref{File
Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}, для получения
информации по синтаксису секции описания локальных переменных.

В случае интерактивного запуска @code{normal-mode}, аргумент @var{find-file}
по умолчанию @code{nil}. В этом случае @code{normal-mode} безусловно
обрабатывает все локальные переменные файла.

Функция вызывает @code{set-auto-mode} для выбора основного режима.
Если режим не был определен, основной режим остается равным значению
основного режима по умолчанию @code{major-mode} см. ниже.

@cindex file mode specification error
@cindex Ошибка определения основного режима
@code{normal-mode} вызывает команду режима внутри @code{condition-case}, поэтому
ошибки ловятся и о них сообщается как @samp{File
mode specification error} следующей за полученным сообщением об ошибке.
@end deffn

@defun set-auto-mode &optional keep-mode-if-same
@cindex visited file mode
@cindex режим для посещенного файла
 Функция выбирает основной режим который подходит для текущего буфера.
Выбор основывается на (в порядке предшествования) строке @w{@samp{-*-}},
на любой @samp{mode:} (используется @code{interpreter-mode-alist}) в
районе завершения файла, @w{@samp{#!}}
(используется @code{magic-mode-alist}) в тексте в начале файла, и
в заключение имени файла (используется auto-mode-alist). @xref{Choosing Modes, ,
How Major Modes are Chosen, emacs, The GNU Emacs Manual}. Если @code{enable-local-variables}
равно @code{nil}, @code{set-auto-mode} не проверяет @w{@samp{-*-}} или окончание файла, для
любого тега режима. (TODO: тут перевод не очень получился)

@vindex inhibit-local-variables-regexps
Для некоторых типов файлов не выполняется сканирование содержимого
для определения режима. Например, tar архив может содержать файл,
который имеет секцию с локальными переменными в конце, определяющими
режим для этого файла. Но они не будут применены ко всему tar файлу.
Аналогично, tiff файл изображения может иметь первую строку соответствующую
шаблону @w{@samp{-*-}}. По этой причини, файлы с таким расширением находятся
в списке @code{inhibit-local-variables-regexps}. Добавление шаблона в этот
список предотвращает поиск Emacs-ом поиск локальных переменных (не только
определяющих режима) в файлах соответствующих шаблону.

Если переменная @var{keep-mode-if-same} не @code{nil}, функция не
вызывает команду режима если буфер уже имеет подходящий основной режим.
Например @code{set-visited-file-name}, выставляет данную переменную в
@code{t}, чтобы предотвратить уничтожение локальных переменных, которые
пользователь мог установить
@end defun

@defun set-buffer-major-mode buffer
Функция устанавливает основной режим @var{buffer} в значение по умолчанию
определяемое @code{major-mode}; если оно @code{nil}, используется
основной режим текущего режима (если он подходит). Если имя буфера
@file{*scratch*}, то для него устанавливается режим определяемый значением
@code{initial-major-mode}.

Низкоуровневые простые функции для создания буфера не используют
это функцию, но команды среднего уровня такие как @code{switch-to-buffer} и
@code{find-file-noselect} используют ее как только они создадут
буфер.
@end defun

@defopt initial-major-mode
@cindex @file{*scratch*}
Значение этой переменной определяет основной режим буфера @file{*scratch*}.
Значение должно быть символом который является командой основного
режима. Значение по умолчанию @code{lisp-interaction-mode}.
@end defopt

@defvar interpreter-mode-alist
Переменная определяет основной режим, который будет использоваться для
скриптов для которых задан командный интерпретатор в @samp{#!} строке.
Переменная представляет собой ассоциативный список (alist) с элементами
в форме @code{(@var{regexp} . @var{mode})}, что указывает использовать
режим @var{mode} если в файле указано использование интерпретатора,
удовлетворяющее регулярному выражению @code{\\`@var{regexp}\\'}. Например
по умолчанию есть такое соответствие: @code{("python[0-9.]*" . python-mode)}.
@end defvar

@defvar magic-mode-alist
Значением переменной является ассоциативный список (alist) в форме:
@code{(@var{regexp} .  @var{function})}.
@var{regexp} - регулярное выражение,
@var{function} - функция или @code{nil}.
При посещении файла (открытии) @code{set-auto-mode} вызывает @var{function}
если текст в начале буфера удовлетворяет @var{regexp} и функция
@var{function} не-@code{nil}, если @var{function} @code{nil}, то
режим определяется на основе значения переменной @code{auto-mode-alist}.
@end defvar

@defvar magic-fallback-mode-alist
Данная переменная работает так же как @code{magic-mode-alist}, за исключением
того что она используется только если @code{auto-mode-alist} не определило
режим для данного файла.
@end defvar

@defvar auto-mode-alist
Переменная содержит ассоциативный список @code{(@var{regexp} .  @var{mode-function})},
@code{(@var{regexp} - регулярное выражение,
    которому должно удовлетворять имя файла.
@var{mode-function})} - функция режима которая будет выполнена если
имя соответствует регулярному выражению.
Как правило @code{(@var{regexp}} проверяет расширение имени файла,
например @samp{.el} или @samp{.c}, но не обязательно.

Например,

@smallexample
@group
(("\\`/tmp/fol/" . text-mode)
 ("\\.texinfo\\'" . texinfo-mode)
 ("\\.texi\\'" . texinfo-mode)
@end group
@group
 ("\\.el\\'" . emacs-lisp-mode)
 ("\\.c\\'" . c-mode)
 ("\\.h\\'" . c-mode)
 @dots{})
@end group
@end smallexample

Когда открывается файла чье полное имя (@pxref{File Name
Expansion}) с удаленными номерами версии и расширениями резервных копий
@code{file-name-sans-versions} (@pxref{File Name Components}), соответствует
регулярному выражению @var{regexp}, @code{set-auto-mode} вызывает
соответствующую @var{mode-function}. Данная способность позволяет Emacs
выбирать подходящий режим для большинства файлов.

Если элемент списка @code{auto-mode-alist} имеет форму @code{(@var{regexp}
@var{function} t)}, тогда после вызова функции @var{function}, Emacs
выполняет поиск в @code{auto-mode-alist} снова, для получения соответствия
для части имени файла которая не могла совпасть ранее.
Данная возможность полезна например для пакетов архивов, запись @code{("\\.gz\\'"
@var{function} t)} позволяет распаковать файл и открыть распакованный файл
в режиме соответствующем части перед @samp{.gz}.

Пример создания правил задания режимов @code{auto-mode-alist}:
(Такие выражения можно использовать в init файле)

@smallexample
@group
(setq auto-mode-alist
  (append
   ;; @r{File name (within directory) starts with a dot.}
   '(("/\\.[^/]*\\'" . fundamental-mode)
     ;; @r{File name has no dot.}
     ("/[^\\./]*\\'" . fundamental-mode)
     ;; @r{File name ends in @samp{.C}.}
     ("\\.C\\'" . c++-mode))
   auto-mode-alist))
@end group
@end smallexample
@end defvar

@node Mode Help
@node Справка по режиму
@subsection Getting Help about a Major Mode
@cindex mode help
@cindex help for major mode
@cindex documentation for major mode
@cindex справка по режиму
@cindex помощь по основному режиму
@cindex документация по основному режиму

Функция @code{describe-mode} предоставляет информацию по
основному режиму. Как правило она вызывается комбинацией @kbd{C-h m}.
Функция использует значение переменной @code{major-mode} (@pxref{Major Modes}).
Поэтому каждая команда основного режима должна устанавливать эту переменную.

@deffn Command describe-mode &optional buffer
Команда отображает документацию по основному и вспомогательным режимам
текущего буфера. Команда использует функцию @code{documentation} для
нахождения строк документации команд основного и вспомогательных режимов
@pxref{Accessing Documentation}).

Если вызывается из Lisp cо значением аргумента @var{buffer} не-@code{nil},
функция отображает документацию для основного и вспомогательного режимов
указанного буфера, а не текущего буфера.
@end deffn

@node Derived Modes
@node Дочерние режимы
@subsection Defining Derived Modes
@cindex derived mode
@cindex дочерние режимы

  Рекомендуемым способом определения основного режима является создание
дочернего режима для одного из уже существующих с использованием
@code{define-derived-mode}. В случае если нет подходящего режима, стоит
наследоваться от @code{text-mode}, @code{special-mode}, или @code{prog-mode}.
@xref{Basic Major Modes}. Если и не один из этих режимов не подходит
стоит наследоваться от @code{fundamental-mode} (@pxref{Major Modes}).

@defmac define-derived-mode variant parent name docstring keyword-args@dots{} body@dots{}
Макрос определяет @var{variant} как команду основного режима,
используя @var{name} в качестве имени режима. @var{variant} и @var{parent} должны
быть символами без кавычки (без цитирования).

Новая команда @var{variant} определяется как вызов функции родителя
@var{parent} с последующем переопределением некоторых частей
родительского режима:

@itemize @bullet
@item
Новый режим имеет пустую раскладку, которая называется
@code{@var{variant}-map}. @code{define-derived-mode} задает
раскладку родительского режима, родителем новой раскладки, если
только @code{@var{variant}-map} еще не задан и уже имеет родителя.

@item
Новый режим содержит свою собственную синтаксическую таблицу,
хранящуюся в переменной @code{@var{variant}-syntax-table}, если
только она не переопределяется явно с использованием ключевого
слова @code{:syntax-table} (см. ниже). Команда @code{define-derived-mode}
устанавливает родителя синтаксической таблицы равным синтаксической
таблице родительского режима, если только @code{@var{variant}-syntax-table}
еще не установлена и не содержит родителя отличающегося от стандартного.

@item
Новый режим содержит свою таблицу аббревиатур(abbrev table), хранящуюся
в @code{@var{variant}-abbrev-table}, если ее не переопределили с использованием
ключевого слова @code{:abbrev-table} (см. ниже).

@item
Новый режим содержит свой перехватчик (mode hook), @code{@var{variant}-hook}.
Режим запускает этот перехватчик после перехватчиков предков, используя
@code{run-mode-hooks}, в конце выполнения команды режима. @xref{Mode Hooks}.
@end itemize

Кроме того можно переопределить другие части родителей @var{parent}
используя @var{body}. Команда @var{variant} выполняет формы (выражения)
@var{body} после установки всех обычных переопределений, непосредственно
перед вызовом перехватчиков (hooks).

Если @var{parent} содержит non-@code{nil} @code{mode-class} свойство
символа, тогда @code{define-derived-mode} устанавливает @code{mode-class}
свойство @var{variant} в это же значение. Это позволяет обеспечить, например то,
что если @var{parent} специальный режим, то и @var{variant} будет специальным
режимом (@pxref{Major Mode Conventions}).

Можно также задать значение @var{parent} равным @code{nil}. Что приведет
к создания нового режима без родителя. Тогда @code{define-derived-mode}
все равно будет действовать как описано выше, при этом пропуская действия
связанные с родителем (@var{parent}).

Аргумент @var{docstring} определяет строку документации для нового режима.
@code{define-derived-mode} добавляет общую информацию о перехватчиках и раскладках
режима, в конец данной строки документации. Если пропустить @var{docstring},
@code{define-derived-mode} сгенерирует строку документации.

@var{keyword-args} это пары ключ значение. Значения вычисляются.
Поддерживаются следующие ключевые слова:

@table @code
@item :syntax-table
Аргумент позволяет явно задать синтаксическую таблицу для нового режима.
Если значение @code{nil}, новый режим будет использовать ту же таблицу
синтаксиса что и @var{parent} или стандартную таблицу синтаксиса если
@var{parent} тоже @code{nil}. (Заметьте что это @emph{не} соответствует
соглашению для не ключевых слов, для которых значение @code{nil} равносильно
отсутствию аргумента).

@item :abbrev-table
Аргумент позволяет явно задать таблицу аббревиатур для нового режима.
Если задать значение @code{nil}, новый режим будет использовать
туже таблицу что и режим родитель(@var{parent}) или
@code{fundamental-mode-abbrev-table}
если @var{parent} тоже @code{nil}. (Снова значение @code{nil} @emph{не}
соответствует отсутствию аргумента).

@item :group
Если значение задано, то оно должно быть группой настройки(customization group).
Не у всех режимов такая группа есть. Команда @code{customize-mode} использует
данную переменную. @code{define-derived-mode} @emph{не} задает
по умолчанию данную переменную.
@end table

Предположительный пример:

@example
(defvar hypertext-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [down-mouse-3] 'do-hyper-link)
    map))

(define-derived-mode hypertext-mode
  text-mode "Hypertext"
  "Major mode for hypertext."
  (setq-local case-fold-search nil))
@end example

Не стоит писать @code{interactive} в определении, @code{define-derived-mode}
добавит его автоматически.
@end defmac

@defun derived-mode-p &rest modes
Функция возвращает не-@code{nil} если текущий основной режим
является дочерним к режиму заданному символами @var{modes}.
@end defun

@node Basic Major Modes
@node Базовые основные режимы
@subsection Basic Major Modes

Кроме Fundamental, есть три основных режима которые другие основные
режимы используют как родительские: Text, Prog и Special режимы.
В отличие от Text режима, который сам является режимом для файлов
с расширением @file{.txt}, Prog и Special предназначены главным
образом для того, чтобы другие режимы могли наследоваться от них.

@vindex prog-mode-hook
  Там где это возможно, новые основные режимы должны быть дочерними напрямую
или нет для этих трех режимов. Одной из причин для этого является возможность
настройки пользователем одного и того же перехватчика режима,
  As far as possible, new major modes should be derived, either directly
or indirectly, from one of these three modes.  One reason is that this
allows users to customize a single mode hook (например, @code{prog-mode-hook})
для всего семейства соответствующего режиму (например, для всех режимов работы с языками программирования).

@deffn Command text-mode
Режим Text, является основным режимом для редактирования текстов естественных языков
(human languages). Он определяет символы @samp{"} и @samp{\} как символы
пунктуации (@pxref{Syntax Class Table}) и задана привязка @kbd{M-@key{TAB}} для
@code{ispell-complete-word} автодополнения (@pxref{Spelling,,, emacs, The GNU Emacs
Manual})

HTML режим является примером режима дочернего к Text.
@xref{HTML Mode,,SGML and HTML Modes, emacs, The GNU Emacs Manual}.
@end deffn

@deffn Command prog-mode
Режим Prog является базовым для режимов редактирования исходных кодов
на различных языках программирования. Большинство режимов Emacs являются
наследниками данного режима.

Режим Prog делает устанавливает @code{parse-sexp-ignore-comments} в @code{t}
(@pxref{Motion via Parsing})
и @code{bidi-paragraph-direction} в @code{left-to-right}
(@pxref{Bidirectional Display}).
@end deffn

@deffn Command special-mode
Режим Special является основным режимом для буферов текст в которым
специальным образом генерируется самим Emacs-ом, а не берется из файла
(например dired)
Основные являющиеся дочерними к Special имеют свойство @code{mode-class}
равное @code{special} (@pxref{Major Mode Conventions}).

Режим Special устанавливает буфер в режим только чтение (read-only).
Таблица привязки клавиш (keymap) определяет несколько общих привязок,
таких как @kbd{q} - @code{quit-window} и @kbd{g} - @code{revert-buffer}.
(@pxref{Reverting}).


Например Buffer Menu является основном режимом дочерним к Special.
Данный режим используется буфером @file{*Buffer List*}. @xref{List
Buffers,,Listing Existing Buffers, emacs, The GNU Emacs Manual}.
@end deffn

  Режимы с табличными данными могут наследоваться от режима Tabulated List,
который в свою очередь является дочерним для Special режима.
@xref{Tabulated List Mode}.

@node Mode Hooks
@node Перехватчики режима
@subsection Mode Hooks

Каждая команда основного режима должна заканчиваться запуском не зависимым от
режима обычным перехватчиком @code{change-major-mode-after-body-hook}, вызовом
перехватчиком режима и вызовом обычного перехватчика @code{after-change-major-mode-hook}.
Что выполняется через вызов @code{run-mode-hooks}. Если основной режим
является дочерним, тогда команда вызывает родительский основной режим в
теле команды режима, вызов делается через @code{delay-mode-hooks}, чтобы родитель
не вызвал свои перехватчики самостоятельно. При это в дочернем режиме при
вызове @code{run-mode-hooks} выполняются перехватчики родительских режимов тоже.
Таким образом выполняются сначала все body режимом, потом перехватчики режимов.
@xref{Major Mode Conventions}.

  Emacs версий до 22, не имел @code{delay-mode-hooks}.
Версии до 24 не имеют @code{change-major-mode-after-body-hook}.
Когда пользовательские основные режимы не используют @code{run-mode-hooks} и
не были обновлены для использования этих новых возможностей, они не полностью
соответствуют текущим соглашениям, они могут запустить родительский перехватчик
слишком рано или не запустить @code{after-change-major-mode-hook}. В случае
использования или встречи с таким режимом рекомендуется исправить его.

При определении основного режима с использованием @code{define-derived-mode},
указанные соглашения соблюдаются автоматически. Если же режим определяется
в ручном режима (``by hand``), без использования @code{define-derived-mode},
стоит использовать следующие функции для автоматического выполнения соглашений.

@defun run-mode-hooks &rest hookvars
Основной режим должен выполнять свои перехватчики используя эту функцию.
Функция схожа с @code{run-hooks} (@pxref{Hooks}), но она так же запускает
@code{change-major-mode-after-body-hook} и
@code{after-change-major-mode-hook}.

Когда функция вызывается в рамкам выполнения формы @code{delay-mode-hooks},
она не выполняет перехватчики сразу. Напротив, она делает так чтобы они были вызваны
при следующем вызове @code{run-mode-hooks}.
@end defun

@defmac delay-mode-hooks body@dots{}
Когда один основной режим вызывает другой, такой вызов должен выполняться
внутри @code{delay-mode-hooks}.

Такой макрос выполняет тело @var{body}, но не выполняет вызовы перехватчиков
внутри @code{run-mode-hooks}. Такие перехватчики будут выполнены
при следующем выполнении @code{run-mode-hooks}, после завершения действия
конструкции @code{delay-mode-hooks}.
@end defmac

@defvar change-major-mode-after-body-hook
Это обычный перехватчик запускаемый @code{run-mode-hooks}. Он выполняется до
перехватчика режима.
@end defvar

@defvar after-change-major-mode-hook
Обыкновенный перехватчик запускаемый @code{run-mode-hooks}. Перехватчик
запускается в конце функции режима, если она правильно написана.
@end defvar

@node Tabulated List Mode
@node Режим табличных списков
@subsection Tabulated List mode
@cindex Tabulated List mode
@cindex режим табулированного списка

  Режим табличных списков (Tabulated List) основной режим для
отображения табличных данных, т.е. данных состоящих из @dfn{entries}
(@dfn{записей}), каждая запись это одна строка текста разделенная на
колонки. Табличный режим предоставляет возможности для красивой печати
строк и колонок, сортировки строк в соответствии со значениями в
колонках. Данный режим является дочерним для Special режима
(@pxref{Basic Major Modes}.

Табличный режим предназначен для использования как родительский для
множества специальных основных режимов. Например режимы Меню Процессов
(Process Menu), (@pxref{Process Information}) и Меню Пакетов (Package
Menu) (@pxref{Package Menu,,, emacs, The GNU Emacs Manual}).

@findex tabulated-list-mode
  Дочерний режим должен использовать @code{define-derived-mode} как
обычно, задав @code{tabulated-list-mode} вторым аргументом
(@pxref{Derived Modes}).  Тело @code{define-derived-mode} должно
определять формат табличных данных, путем задания значения переменных
описанных ниже, функция @code{tabulated-list-init-header} может быть
вызвана для заполнения заголовка именами колонок.

Дочерний режим должен определить @dfn{listing command}. Это не команда
режима, а команда вызываемая аналогично (e.g., @kbd{M-x
list-processes}).
Команда должна создавать или переключать буфер, включать дочерний режим,
определять табличные данные и в заключение вызывать @code{tabulated-list-print}
для заполнения буфера.

@defvar tabulated-list-format
Данная локальная для буфера (buffer-local) переменная определяет формат
данных табличного списка. Значение должно быть вектором. Каждый элемент
вектора представляет колонку данных, и должен быть списком
@code{(@var{name} @var{width} @var{sort})}, где

@itemize
@item
@var{name} имя колонки (строка).

@item
@var{width} ширина колонки (число). Данный параметр не используется для
крайней колонки которая занимает все оставшееся место.

@item
@var{sort} задает правило сортировки записей по колонкам. Если
@code{nil}, колонка не будет использоваться для сортировки. Если
@code{t}, колонка сортируется как строковая. В другом случае,
нужно задать функцию предикат @code{sort} (@pxref{Rearrangement}),
которая принимает 2 аргумента того же вида что и элементы
@code{tabulated-list-entries} (см. ниже).
@end itemize
@end defvar

@defvar tabulated-list-entries
Данная локальная для буфера (buffer-local) переменная записи отображаемые
в Табличном режиме. Значение должно быть списком или функцией.

Если значение список, каждый элемент соответствует одной записи,
и должен иметь форму @w{@code{(@var{id} @var{contents})}}, где

@itemize
@item
@var{id} либо @code{nil}, либо Lisp объект идентифицирующий запись.
В случае объекта, курсор будет оставаться на той же записи при
пересортировке. Сравнение выполняется с использованием @code{equal}.

@item
@var{contents} это вектор с тем же количеством элементов, что и
@code{tabulated-list-format}. Каждый элемент вектора либо строка,
которая вставляется в буфер как есть, либо список @code{(@var{label}.
@var{properties})}, который предполагает вставку текстовой кнопки
вызовом @code{insert-text-button} с @var{label} и @var{properties}
в качестве аргументов (@pxref{Making Buttons}).

Переводов строк не в одной из строк быть не должно.
@end itemize

Если значение функция, то она должна возвращать список описанной выше
формы при вызове без аргументов.
@end defvar

@defvar tabulated-list-revert-hook
Обыкновенный перехватчик выполняемые как правило для перезагрузки
буфера с табличным списком. Дочерний режим может добавить функцию
в этот перехватчик для пересчета
@code{tabulated-list-entries}.
@end defvar

@defvar tabulated-list-printer
Значение данное переменной должно быть функцией вызываемой для вставки
записи в точке, включая символ перевода строки. Функция должна
принимать два аргумента @var{id} и @var{contents} (id и содержимое),
такие же как для @code{tabulated-list-entries}. Значение по умолчанию
функция вставляющая запись как есть, режимы использующие табличный
список более сложным образом могут задавать другую функцию.
@end defvar

@defvar tabulated-list-sort-key
Значение этой переменной определяет значение текущего ключа для сортировки
в буфере. Если значение @code{nil}, сортировка не выполняется.
Значение должно быть в форме @code{(@var{name} . @var{flip})}, где
@var{name} строка соответствующая имени одной из колонок в
@code{tabulated-list-format}, и @var{flip} если не-@code{nil},
задает сортировку в обратном порядке.
@end defvar

@defun tabulated-list-init-header
Функция вычисляет и устанавливает @code{header-line-format} для
буфера с табличным списком (@pxref{Header Lines}), и присваивает
обработчики кнопок для строки заголовков, чтобы было возможном
сортировать записи по клику на заголовке колонки.

Режимы дочерние к режиму Табличных списков, должны вызывать
данную функцию после установки вышеописанных переменных,
(в особенности после установки @code{tabulated-list-format}).
@end defun

@defun tabulated-list-print &optional remember-pos update
Функция заполняет текущий буфер записями. Она должна вызываться
командой листинга (listing-command). Функция очищает буфер, сортирует
записи заданные @code{tabulated-list-entries} в соответствии с
@code{tabulated-list-sort-key}, а затем вызывает функцию определенную
@code{tabulated-list-printer} для вставки каждой записи.

Если необязательный аргумент @var{remember-pos} не-@code{nil}, функция
смотрит на @var{id} текущей записи, и пытается спозиционироваться
на ту же запись после того как все записи будут (пере)вставлены ((re)inserted).

Если необязательный аргумент @var{update} не-@code{nil}, функция
будет удалять и вставлять только записи, которые изменились со
времени предыдущей печати. Такое поведение может быть в несколько
раз быстрее если большинство записей не изменились с предыдущего вызова
функции. Единственная разница в результатах, заключается в том, что
теги выставленные через @code{tabulated-list-put-tag}, не будут удалены
для записей которые не изменились (обычно все теги удаляются).
@end defun

@node Generic Modes
@node Общие режимы
@subsection Generic Modes
@cindex generic mode
@cindex Общие режимы

  @dfn{Generic modes} Общие режимы это простые основные режимы с базовой
поддержкой синтаксиса комментариев и подсветкой синтаксиса (Font Lock mode).
См. @file{generic-x.el} чтобы изучить примеры использования @code{define-generic-mode}.

@defmac define-generic-mode mode comment-list keyword-list font-lock-list auto-mode-list function-list &optional docstring
Макрос определяет команду общего режима с именем @var{mode}
(символ без кавычки (not quoted)).
Не обязательный аргумент @var{docstring} документация для команды режима.
Если опущено, то @code{define-generic-mode} сгенерирует значение по умолчанию.

Аргумент @var{comment-list} список в котором каждый элемент это
символ, строка из одного или двух символов, или cons ячейка.
Символ или строка установлены в таблице синтаксиса режима как
начало комментария. Если запись является cons ячейкой, то @sc{car}
является началом комментария, а @sc{cdr} завершением комментария.
(Стоит использовать @code{nil} в качестве @sc{cdr} если нужно чтобы комментарии
заканчивались в конце строки.)
Стоит учитывать, что синтаксическая таблица
имеет накладывает ограничения на то что может быть началом
и концом комментария.

@xref{Syntax Tables}.

Аргумент @var{keyword-list} это список ключевых слов которые должны
выделяться шрифтом @code{font-lock-keyword-face}. Каждое ключевое
слово должно быть строкой.  Кроме того, @var{font-lock-list}
это список дополнительных выражений для выделения. Каждый элемент
этого списка должен иметь ту же форму что и элементы @code{font-lock-keywords}.
@xref{Search-based Fontification}.

Аргумент @var{auto-mode-list} это список регулярных выражений для добавления
в переменную @code{auto-mode-alist}. Они добавляются при выполнении
формы @code{define-generic-mode}, а не при раскрытии макроса.

Переменная @var{function-list} является списком функций которые
выполняются при выполнении команды режима для задания дополнительных
настроек. Данные функции выполняет непосредственно перед вызовом
перехватчиков из переменной @code{@var{mode}-hook}.
@end defmac

@node Example Major Modes
@node Пример основных режимов
@subsection Major Mode Examples

  Текстовый (Text) режим вероятно самый простой режим после Fundamental
режима. Приведем отрывок из @file{text-mode.el} иллюстрирующий многие
из вышеописанных соглашений.

@smallexample
@group
;; @r{Create the syntax table for this mode.}
(defvar text-mode-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?\" ".   " st)
    (modify-syntax-entry ?\\ ".   " st)
    ;; Add 'p' so M-c on 'hello' leads to 'Hello', not 'hello'.
    (modify-syntax-entry ?' "w p" st)
    st)
  "Syntax table used while in `text-mode'.")
@end group

;; @r{Create the keymap for this mode.}
@group
(defvar text-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\t" 'ispell-complete-word)
    map)
  "Keymap for `text-mode'.
Many other modes, such as `mail-mode', `outline-mode' and
`indented-text-mode', inherit all the commands defined in this map.")
@end group
@end smallexample

  Далее выполняется определение команды режима:

@smallexample
@group
(define-derived-mode text-mode nil "Text"
  "Major mode for editing text written for humans to read.
In this mode, paragraphs are delimited only by blank or white lines.
You can thus get the full benefit of adaptive filling
 (see the variable `adaptive-fill-mode').
\\@{text-mode-map@}
Turning on Text mode runs the normal hook `text-mode-hook'."
@end group
@group
  (set (make-local-variable 'text-mode-variant) t)
  (set (make-local-variable 'require-final-newline)
       mode-require-final-newline)
  (set (make-local-variable 'indent-line-function) 'indent-relative))
@end group
@end smallexample

@noindent
(Крайняя строка в настоящее время избыточна, так как @code{indent-relative}
это значение по умолчанию, и стоит удалить ее в будущих версиях.)

@cindex @file{lisp-mode.el}
  Следующие 3 Lisp режима (Lisp режим, Emacs Lisp режим и Lisp Interaction режим)
имеют больше особенностей чем Text режим и код данных режимов
более сложный. Далее приводится выдержка из @file{lisp-mode.el}, которая
иллюстрирует как данные режимы написаны.

  Так определяются таблица синтаксиса и аббревиатур:

@cindex syntax table example
@cindex пример синтаксической таблицы
@smallexample
@group
;; @r{Create mode-specific table variables.}
(defvar lisp-mode-abbrev-table nil)
(define-abbrev-table 'lisp-mode-abbrev-table ())

(defvar lisp-mode-syntax-table
  (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table)))
    (modify-syntax-entry ?\[ "_   " table)
    (modify-syntax-entry ?\] "_   " table)
    (modify-syntax-entry ?# "' 14" table)
    (modify-syntax-entry ?| "\" 23bn" table)
    table)
  "Syntax table used in `lisp-mode'.")
@end group
@end smallexample

  Три режима для Lisp разделяются большую часть кода. Например,
все вызывают следующую функцию для установки переменных:

@smallexample
@group
(defun lisp-mode-variables (&optional syntax keywords-case-insensitive)
  (when syntax
    (set-syntax-table lisp-mode-syntax-table))
  (setq local-abbrev-table lisp-mode-abbrev-table)
  @dots{}
@end group
@end smallexample

@noindent
Среди прочего, функция устанавливает переменную @code{comment-start}
для обработки Lisp комментариев:

@smallexample
@group
  (make-local-variable 'comment-start)
  (setq comment-start ";")
  @dots{}
@end group
@end smallexample

  Каждый из различных Lisp режимов имеет немного отличающуюся
привязку клавиш (keymap, раскладку). Например в Lisp режиме по
@kbd{C-c C-z} выполняется @code{run-lisp}, а в других Lisp
режимах нет. Однако, все Lisp режимы имеют часть общих команд.
Общие команды устанавливаются следующим кодом:

@smallexample
@group
(defvar lisp-mode-shared-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\C-q" 'indent-sexp)
    (define-key map "\177" 'backward-delete-char-untabify)
    map)
  "Keymap for commands shared by all sorts of Lisp modes.")
@end group
@end smallexample

@noindent
Далее приводится код для установки раскладки Lisp режима:

@smallexample
@group
(defvar lisp-mode-map
  (let ((map (make-sparse-keymap))
	(menu-map (make-sparse-keymap "Lisp")))
    (set-keymap-parent map lisp-mode-shared-map)
    (define-key map "\e\C-x" 'lisp-eval-defun)
    (define-key map "\C-c\C-z" 'run-lisp)
    @dots{}
    map)
  "Keymap for ordinary Lisp mode.
All commands in `lisp-mode-shared-map' are inherited by this map.")
@end group
@end smallexample

@noindent
Далее приводится команда основного режима, для  Lisp режима:

@smallexample
@group
(define-derived-mode lisp-mode prog-mode "Lisp"
  "Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
Commands:
Delete converts tabs to spaces as it moves back.
Blank lines separate paragraphs.  Semicolons start comments.

\\@{lisp-mode-map@}
Note that `run-lisp' may be used either to start an inferior Lisp job
or to switch back to an existing one.
@end group

@group
Entry to this mode calls the value of `lisp-mode-hook'
if that value is non-nil."
  (lisp-mode-variables nil t)
  (set (make-local-variable 'find-tag-default-function)
       'lisp-find-tag-default)
  (set (make-local-variable 'comment-start-skip)
       "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
  (setq imenu-case-fold-search t))
@end group
@end smallexample

@node Minor Modes
@node Дополнительные режимы
@section Minor Modes
@cindex minor mode
@cindex дополнительные режимы

  Дополнительный @dfn{minor mode} режим предоставляется необязательные
функции, которые пользователи могут включать или выключать не зависимо от
основного режима. Дополнительные режимы могут включаться по отдельности
или в некоторой комбинации.

  Большинство дополнительных режимов реализуют функционал, который не зависит
от основного режима, и таким образом могут быть использованы с большинством
основных режимов. Например, Auto Fill (режим автозаполнения) может работать
с любым текстовым режимом который поддерживает вставку текста. Некоторые
дополнительные режимы, однако, специализированы для определенных основных
режимов. Например, Diff Auto Refine дополнительный режим предназначен
только для использования с Diff режимом.

  В идеале, дополнительный режим не должен оказывать влияния на другие
дополнительные режимы. Должно быть возможно включать и выключать дополнительные
режимы в любом порядке.

@defvar minor-mode-list
Значение этой переменной это список всех команд вспомогательных режимов
@end defvar

@menu
* Minor Mode Conventions::      Tips for writing a minor mode. (Советы по написанию дополнительных режимов)
* Keymaps and Minor Modes::     How a minor mode can have its own keymap. (Раскладки для вспомогательных режимов)
* Defining Minor Modes::        A convenient facility for defining minor modes. (Средства ддля упрощения определения дополнительных режимов)
@end menu

@node Minor Mode Conventions
@node Соглашения по дополнительным режимам
@subsection Conventions for Writing Minor Modes
@cindex minor mode conventions
@cindex соглашения по дополнительным режимам
@cindex conventions for writing minor modes
@cindex соглашения по написанию дополнительных режимов

  Как и для основных режимов, для дополнительных существуют соглашения
по их написанию. Указанные соглашения будут описаны ниже. Использование
макроса @code{define-minor-mode} простейший способ следовать этим
соглашениям.
@xref{Defining Minor Modes}.

@itemize @bullet
@item
@cindex mode variable
Переменная режима определяется переменной, чье имя оканчивается на
@samp{-mode}. Данную переменную будем называть @dfn{mode variable}.
Команда дополнительного режима должна устанавливать данную переменную.
Значение должно быть @code{nil} если режим не активен(disabled)
и не-@code{nil} если режим активен (enabled). Переменная должна быть
локальной для буфера (buffer-local) если дополнительный режим локальный
для буфера (buffer-local).

Данная переменная используется для в списке @code{minor-mode-alist}, для
отображения имени дополнительного режима в строке режима. Так же данная
переменная определяет является ли раскладка режима активной, через
@code{minor-mode-map-alist} (@pxref{Controlling Active Maps}). Другие
команды и перехватчики тоже могут проверять значение данной переменной.

@item
Нужно определить команду, называемую @dfn{mode command}, имя которой такое
же как имя переменной режима. Задача данной команды установить значение
переменной режима и выполнить другие действия включения и выключения
функций режима.

Команда режима должна принимать один необязательный параметр.
Если команда вызывается интерактивно, она должна переключать
состояние режима (включать если выключен и наоборот). Если она
вызывается интерактивно с prefix аргументом
(задается при помощи C-u <значение>), то режим нужно включить если
значение аргумента положительное и выключить в другом случае.

Если команда режима вызывается из Lisp (т.е не-интерактивно), тогда
команда должна включить режим если аргумент не задан или @code{nil};
должна переключить режима если аргумент символ @code{toggle};
иначе аргумент должен обработаться аналогично интерактивному поведению.

Дальше приводится пример как реализовать такое поведение (код схож
с кодом генерируемым макросом @code{define-minor-mode}):

@example
(interactive (list (or current-prefix-arg 'toggle)))
(let ((enable (if (eq arg 'toggle)
                  (not foo-mode) ; @r{this mode's mode variable}
                (> (prefix-numeric-value arg) 0))))
  (if enable
      @var{do-enable}
    @var{do-disable}))
@end example

Причина такого отчасти сложного поведения в том, что пользователю
нужно предоставить удобный способ включения дополнительного режима
интерактивно и из перехватчиков, например так:

@example
(add-hook 'text-mode-hook 'foo-mode)
@end example

@noindent
Данный код работает корректно в не зависимости от того включен ли
уже режим @code{foo-mode} или нет, так как @code{foo-mode} безусловно
включит дополнительный режим при вызове из Lisp без аргументов.
Выключение режима в перехватчике выглядит немного хуже:

@example
(add-hook 'text-mode-hook (lambda () (foo-mode -1)))
@end example

@noindent
Но, данный вызов используется не часто.

@item
В @code{minor-mode-alist} должен быть добавлен элемент
для каждого дополнительного режима (@pxref{Definition of minor-mode-alist}),
если дополнительный режим должен отображаться в строке режимов.
Элемент должен быть списком следующей формы:

@smallexample
(@var{mode-variable} @var{string})
@end smallexample

Где @var{mode-variable} переменная определяющая активность дополнительного
режима, а @var{string} короткая строка начинающаяся с пробела, которая
будет описывать режим в строке режимов. Данная строка должна быть короткой
так как пространство для описания всех режимов ограничено и одно на всех.

При добавлении элемента в @code{minor-mode-alist}, стоит использовать
@code{assq} чтобы избежать дублирования.
Например:

@smallexample
@group
(unless (assq 'leif-mode minor-mode-alist)
  (push '(leif-mode " Leif") minor-mode-alist))
@end group
@end smallexample

@noindent
или например, использовать @code{add-to-list} (@pxref{List Variables}):

@smallexample
@group
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end group
@end smallexample
@end itemize

  Часть соглашений для основных режимов хорошо подходят и для
дополнительных: например касающиеся имен глобальных символов,
использования функций в завершении функции инициализации режима, и
использования таблицы раскладок и других таблиц.

Дополнительный режима должен, если это возможно, поддерживать
включение и выключение через Custom (режим графической настройки)
(@pxref{Customization}). Чтобы это реализовать, переменная режима
должна быть определена через @code{defcustom}, обычно с
@code{:type 'boolean}. Если простое установление значения не
достаточно для включения режима, нужно определить метод @code{:set}
который включит режим вызовом команды режима. Стоит отметить, что
строка документации заданная не через Custom будет игнорироваться.
(примю
@code{autoload cookie} это магический комментарий @code{;;;###autoload},
который понимается командой @code{update-file-autoloads} и записывает
соответствующий autoload код в специальный файл @code{loaddefs.el}
)
Также можно пометить определение с использованием
autoload cookie (@pxref{autoload cookie}),
и добавить @code{:require}, чтобы изменение переменной
загружала соответствующую библиотеку с определением режима.
Например:

@smallexample
@group
;;;###autoload
(defcustom msb-mode nil
  "Toggle msb-mode.
Setting this variable directly does not take effect;
use either \\[customize] or the function `msb-mode'."
  :set 'custom-set-minor-mode
  :initialize 'custom-initialize-default
  :version "20.4"
  :type    'boolean
  :group   'msb
  :require 'msb)
@end group
@end smallexample

@node Keymaps and Minor Modes
@node Раскладки и дополнительные режимы
@subsection Keymaps and Minor Modes

  Дополнительный режим может иметь свою собственную раскладку, которая
активна когда режим включен. Для установки раскладки дополнительного режима
нужно добавить элемент в alist @code{minor-mode-map-alist}.
@xref{Definition of minor-mode-map-alist}.

@cindex @code{self-insert-command}, minor modes
@cindex @code{self-insert-command}, дополнительные режимы
  Одно из применений раскладок второстепенных режимов изменение поведения
символов (self-inserting characters символы вставляющие себя), чтобы
они делали еще что-то кроме вставки себя. (Другой способ настроить
@code{self-insert-command} использовать @code{post-self-insert-hook}. Кроме того,
настройка @code{self-insert-command} ограничена особыми случаями для
аббревиатур и режимом автозаполнения (Auto Fill mode)). Не нужно пытаться
заменить своим определением стандартное. Так как цикл редактора
обработает их специальным образом.)

Дополнительные режимы могут выполнять привязку к последовательности
@kbd{C-c} + знак пунктуации. Но @kbd{C-c} и следующим @kbd{@{@}<>:;} или
управляющим символом или цифрой зарезервированы для основных режимов.
Так же @kbd{C-c @var{letter}} зарезервировано для пользователей.
@xref{Key Binding Conventions}.
(Прим. То ест почти не с чем использовать нельзя.)

@node Defining Minor Modes
@node Определение дополнительного режима
@subsection Defining Minor Modes
@subsection Определение дополнительного режима

  Макрос @code{define-minor-mode} является удобным способом
определения режима.

@defmac define-minor-mode mode doc [init-value [lighter [keymap]]] keyword-args@dots{} body@dots{}
Макрос определяет новый дополнительный режим чье имя @var{mode}
(символ (a symbol)). Макрос определяет команду @var{mode} для
включения/выключения дополнительного режима, с @var{doc} в
качестве документации.

Команда переключения получает 1 необязательный (prefix) аргумент.
Если команда вызывается интерактивно без аргументов то она переключает
состояние режима с включенного на выключенное и наоборот.
Положительный prfix включает режим, любой другой prefix выключает.
При вызове из Lisp, аргумент @code{toggle} переключает режим, а
отсутствие аргумента или @code{nil} аргумент включает режим.
Такое поведение позволяет легко включить дополнительный режим в перехватчике
основного режима, например.
Если @var{doc} @code{nil}, макрос предоставляют строку документации
по умолчанию описанную выше.

По умолчанию, так же определяется переменная с именем @var{mode}, которая
устанавливается в @code{t} и @code{nil} при включении или выключении режима.
Переменная инициализируется значением @var{init-value}. За исключением
особых случаем (см. ниже), такое значение должно быть @code{nil}.

Параметр @var{lighter} определяет то, что будет отображаться в
строке режима, когда режим включен; если значение @code{nil},
режим не отображается в строке режима.

Не обязательный аргумент @var{keymap} определяет раскладку для
дополнительного режима. Если не-@code{nil}, то значение должно
быть именем переменной, чье значение это раскладка, или alist (ассоциативный массив)
в форме

@example
(@var{key-sequence} . @var{definition})
@end example

@noindent
где @var{key-sequence} и @var{definition} аргументы пригодные для
команды @code{define-key} (@pxref{Changing Key
Bindings}). Если @var{keymap} это раскладка или alist, то в макросе
будет этим будет определена переменная @code{@var{mode}-map}.

Три вышеописанных аргумента @var{init-value}, @var{lighter}, и
@var{keymap} могут быть (частично) опущены когда используется
@var{keyword-args}. Некоторые ключевые слова имеют
специальное значение:

@table @code
@item :group @var{group}
Специальное имя группы, которое будет использоваться во всех
формах @code{defcustom}.
По умолчанию @var{mode}, @samp{-mode}.
@strong{Warning:} не стоит использовать это имя по умолчанию,
если вы не определили использовали @code{defgroup} для
правильного определения группы. @xref{Group Definitions}.

@item :global @var{global}
Если значение не-@code{nil}, то режим будет глобальным,
а не локальным для буфера. Значение по умолчанию @code{nil}.

Одним из эффектов глобального дополнительного режима, является
то что переменная режима @var{mode} становится переменной
настройки (customization variable). Переключение ее значения
через интерфейс настройки (Customize interface) включает
и выключает режим, и данное значение может быть сохранено
для следующих сессий Emacs. (@pxref{Saving
Customizations,,, emacs, The GNU Emacs Manual}. Чтобы
сохранение переменной работало, нужно проверить, что
форма @code{define-minor-mode} выполняется каждый раз когда
Emacs запускается; для пакетов не являющихся частью
Emacs использование ключевого слова @code{:require}
является простейшим способом сделать это.

@item :init-value @var{init-value}
Эквивалентно позиционному @var{init-value}.

@item :lighter @var{lighter}
Эквивалентно позиционному @var{lighter}.

@item :keymap @var{keymap}
Эквивалентно позиционному @var{keymap}.

@item :variable @var{place}
Данная переменная заменяет переменную по умолчанию @var{mode},
используемую для хранения состояния режима. Если задать
это значение @var{mode} не определяется, и любой
@var{init-value} аргумент не будет использоваться. @var{place}
может быть другой именованной переменной (которую должна быть определена),
или чем угодно что может быть использовано с функцией @code{setf}
(@pxref{Generalized Variables}).
@var{place} может быть cons ячейкой @code{(@var{get} . @var{set})},
где @var{get} выражение возвращающее текущее значение, а
@var{set} функция одного аргумента устанавливающая значение.

@item :after-hook @var{after-hook}
Параметр определяет одну Lisp форму, которая выполняется после
того как выполнится перехватчик режима. Форма не должна быть
цитированием (quoted).
@end table

Все другие аргументы заданные с ключевыми словами передаются
непосредственно в @code{defcustom} сгенерированной для
переменной @var{mode}.

Команда с именем @var{mode} сначала выполняет стандартные действия
такие как установку переменной @var{mode} и затем выполняет формы @var{body},
если они заданы. Затем вызывается перехватчик режима @code{@var{mode}-hook},
и в завершении выполняется форма @code{:after-hook}.
@end defmac

  Начальное значение должно быть @code{nil} за исключением случаев
где (1) режим предварительно загружен в Emacs, или (2) загрузка режима
""безболезненна"" даже если пользователь ее не запрашивал. Например если
режим не оказывает эффекта, пока еще что-то не включено, тогда он будет
загружен для этого чего-то. Это особые случаи. Обычно начальное
значение @code{nil}.

@findex easy-mmode-define-minor-mode
  Имя @code{easy-mmode-define-minor-mode} является псевдонимом для
макроса.

  Пример использования @code{define-minor-mode}:

@smallexample
(define-minor-mode hungry-mode
  "Toggle Hungry mode.
Interactively with no argument, this command toggles the mode.
A positive prefix argument enables the mode, any other prefix
argument disables it.  From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

When Hungry mode is enabled, the control delete key
gobbles all preceding whitespace except the last.
See the command \\[hungry-electric-delete].

   Переключение Hunrgy режима.
Интерактивно без аргументов, команда переключает режим.
Положительный префикс аргумент включает режим, а любой другой
выключает. Из Lisp, отсутствие аргумента или nil включает режим, `toggle'
переключает состояние.

Когда Hungry режим включен, control + delete удаляет все
предшествующие пробелы кроме 1.
См. команду \\[hungry-electric-delete].
"
 ;; The initial value. Начальное значение
 nil
 ;; The indicator for the mode line. Текст для строки режима.
 " Hungry"
 ;; The minor mode bindings. Привязка клавиш дополнительно режима.
 '(([C-backspace] . hungry-electric-delete))
 :group 'hunger)
@end smallexample

@noindent
В примере определяется дополнительный режим ``Hungry mode'', команда
для переключения @code{hungry-mode}, переменная @code{hungry-mode},
которая указывает на состояние режима, и переменная @code{hungry-mode-map},
которая содержит раскладку, которая хранит привязки клавиш, которые
активны, когда активен режим. Создается раскладка с привязкой для
@kbd{C-@key{DEL}}. Переменная @code{hungry-mode} помещается в группу
настройки @code{hunger}. Форма @var{body} отсутствует --- многие
дополнительные режимы в ней не нуждаются.

  Эквивалентный вариант записи:

@smallexample
(define-minor-mode hungry-mode
  "Toggle Hungry mode.
...rest of documentation as before..."
 ;; The initial value. Начальное значение
 :init-value nil
 ;; The indicator for the mode line. Текст для строки режима
 :lighter " Hungry"
 ;; The minor mode bindings. Раскладка дополнительного режима.
 :keymap
 '(([C-backspace] . hungry-electric-delete)
   ([C-M-backspace]
    . (lambda ()
        (interactive)
        (hungry-electric-delete t))))
 :group 'hunger)
@end smallexample

@defmac define-globalized-minor-mode global-mode mode turn-on keyword-args@dots{}
Определяет глобальный переключатель @var{global-mode}, назначение
которого выключать или включать локальный для буфера дополнительный режим
@var{mode} во всех буферах. Для включения дополнительного режима
в буфере используется функция @var{turn-on}, для выключения вызов
@var{mode} с аргументом @minus{}1.

Глобальное включение режима так же сказывается на буферах созданных
при открытии файлов в дальнейшем, и буферах которые используют
основной режим отличный от Fundamental режима; но не обнаруживается
создание новых буферов в Fundamental режиме.

Макросом определяется опция настройки @var{global-mode} (@pxref{Customization}),
которая может быть изменена через интерфейс настройки (Customize interface).
Как и с @code{define-minor-mode}, нужно проверять, что
@code{define-globalized-minor-mode} вычисляется при каждом
запуске Emacs, например используя ключевое слово @code{:require}.

Чтобы задать группу настройки можно использовать @code{:group @var{group}}
@var{keyword-args}.

В общем, когда определяется глобальный доп. режим, так же нужно
определить не глобальную версию, чтобы люди могли использовать (или отключать)
режим в отдельных буферах. Кроме того это позволит
им отключить глобально включенный доп. режим в заданных основных
режимах, используя перехватчики этих режимов.
@end defmac


@node Mode Line Format
@node Формат строки режима
@section Mode Line Format
@section Формат строки режима
@cindex mode line
@cindex строка режима

  Каждое Emacs окно (за исключением окна минибуфера) как правило
имеет строку режима внизу, на которой отображается информация о буфере
отображаемом в окне. Строка режима содержит информацию о буфере, такую
как имя файла, глубину рекурсивного редактирования, основной и
дополнительные режимы. Окно может также иметь @dfn{header line},
которая такая же как строка режима только сверху окна.

Данный раздел описывает как управлять содержимым строки состояния и
строкой заголовка (header line). Данный раздел включен в эту главу,
потому что основная часть информации строки состояния связана с
основным или вспомогательным режимом.

@menu
* Base: Mode Line Basics.       Основные идеи управления строкой режима.
* Data: Mode Line Data.         Структура данных управляющая строкой режима.
* Top: Mode Line Top.           Переменная верхнего уровня, mode-line-format.
* Mode Line Variables::         Переменные используемые в структуре данных строки режима.
* %-Constructs::                Размещение информации в строке режима.
* Properties in Mode::          Использования свойств текста в строке режим.
* Header Lines::                Как строка режима только сверху.
* Emulating Mode Line::         Форматирование текста в стиле строке режима (эмулирование).
@end menu

@node Mode Line Basics
@subsection Mode Line Basics

  Содержимое строки режима определяется локальной переменной буфера
@code{mode-line-format} (@pxref{Mode Line Top}).  Эта переменная
хранит @dfn{mode line construct}: шаблон, который определяет
что отображается на строке режима. Значение переменной
@code{header-line-format} определяет строку заголовка точно
аналогично. Все окна одного буфера используют одни и теже
@code{mode-line-format} и @code{header-line-format}.
  a template that controls what is
displayed on the buffer's mode line.  The value of
@code{header-line-format} specifies the buffer's header line in the same

Для повышения производительности, Emacs не всегда пересчитывает
строку режима и строку заголовка окна. Пересчет выполняется если
при ряде условие, таких как переключение буферов, сжатие или расширение
буфера, прокрутка, или изменение буфера. Если изменить переменные
@code{mode-line-format} или
@code{header-line-format} (@pxref{Mode Line Variables}), или любые
другие структуры данных которые влияют на отображение текста
(@pxref{Display}), нужно воспользоваться функцией
@code{force-mode-line-update} для обновления.

@defun force-mode-line-update &optional all
Функция заставляет Emacs обновить строку режима и строку заголовка
текущего буфера, на основе значений всех связанных переменных.
Если необязательный аргумент @var{all} не-@code{nil}, обновляются
все строки режима и заголовки.

Функция так же заставляет обновить строку меню и заголовок фрейма.
@end defun

  Строка выбранного окна, как правило отображается другим цветом,
используя шрифт @code{mode-line}. Строки других окон отображаются
шрифтом @code{mode-line-inactive}. @xref{Faces}.

@node Mode Line Data
@subsection The Data Structure of the Mode Line
@cindex mode line construct

  Строка режима задается при помощи структуры
@dfn{mode line construct}  состоящей из списков, строк, символов, и
чисел хранящихся в локальных переменных буфера. Каждый тип данных
имеет особое значение в строке режима, как описано ниже. Такие же
структуры данных используются для задания заголовка фрейма
(@pxref{Frame Titles}) и строки заголовка буфера (@pxref{Header Lines}).

 Строка режима может просто фиксированной строкой текста, но
как правило задается как в виде комбинации строки и значений
переменных для задания текста. Многие такие переменные сами
так определены специально для использования в строке режима.
(Many of these variables are themselves
defined to have mode line constructs as their values.)


 Далее описание значение типов данных в качестве частей строки режима:

@table @code
@cindex percent symbol in mode line
@item @var{string}
Строки в строке режима отображаются без изменений, за исключением
@dfn{@code{%}-constructs}. В такие конструкции выполняется
подстановка других данных.
@ref{%-Constructs}.

Если часть строки содержит @code{face} свойства, они управляют
текстом так же как в буфере. Любые символы  которые не содержат
@code{face} отображаются шрифтом по умолчанию @code{mode-line} или
@code{mode-line-inactive}. @code{help-echo} и @code{keymap}
свойства @var{string} имеют особое значение. @xref{Properties in Mode}.

@item @var{symbol}
Символ в строке режима добавляет свое значение. Значение @var{symbol}
используется как часть конструкции строки режима. Но @code{t} и @code{nil}
игнорируются, как и символы со значением void.

Есть 1 исключение: если значение @var{symbol} строка, то текст
вставляется как есть и подстановка @code{%}-constructs не выполняется.

Если символ не помечен как @var{symbol} рискованный (т.е
свойство @code{risky-local-variable} не-@code{nil}),
все текстовые свойства строк в переменной символа @var{symbol},
игнорируются, как и все @code{:eval} и @code{:propertize}
формы. (Это делается ради безопасности: не опасные переменные
могут быть установлены автоматически из переменных файла
без запроса у пользователя).
(Не очень понятно, что тут имеется ввиду. Оригинальный вариант:).
Unless @var{symbol} is marked as risky (i.e., it has a
non-@code{nil} @code{risky-local-variable} property), all text
properties specified in @var{symbol}'s value are ignored.  This includes
the text properties of strings in @var{symbol}'s value, as well as all
@code{:eval} and @code{:propertize} forms in it.  (The reason for this
is security: non-risky variables could be set automatically from file
variables without prompting the user.)

@item (@var{string} @var{rest}@dots{})
@itemx (@var{list} @var{rest}@dots{})
Список с первым элементом строкой, указывает что нужно обработать
все элементы рекурсивно и соединить результаты. Это наиболее
частая форма конструкции строки режима.

@item (:eval @var{form})
Список первым элементом которого является символ @code{:eval},
говорит вычислить @var{form}, и использовать результат как строку
для отображения. Вычисление не должно загружать файлы, так как
это может привести к бесконечной рекурсии.

@item (:propertize @var{elt} @var{props}@dots{})
Список первый элемент которого символ @code{:propertize} говорит
обработать @var{elt} рекурсивно, после чего добавить свойства текста
заданные @var{props} к результату. Аргумент @var{props} должен
состоять из 0 или более пар @var{text-property} @var{value}.

@item (@var{symbol} @var{then} @var{else})
Список с первым аргументом являющемся не ключевым символом обрабатывается
в зависимости от значения @var{symbol}. Если значение @var{symbol}
не-@code{nil}, второй элемент @var{then} обрабатывается рекурсивно
как элемент строки режима, иначе, третий аргумент @var{else},
обрабатывается рекурсивно. @var{else} можно опустить, тогда
в строке режима ничего не будет отображено если значение
@var{symbol} @code{nil} или void.

@item (@var{width} @var{rest}@dots{})
Список с первым элементом числом определяет максимальную
ширину для результата @var{rest}. @var{rest} обрабатывается
рекурсивно, как части строки режима и соединяются вместе.
Когда @var{width} положительное, если ширина вычисления
меньше @var{rest}, справа добавляются пробелы. Когда
@var{width} отрицательное, результат обрезается до
@minus{}@var{width} если ширина больше @minus{}@var{width}.

Например, обычный способ показать сколько процентов буфера находится
выше использовать: @code{(-3 "%p")}.
@end table

@node Mode Line Top
@subsection The Top Level of Mode Line Control

Переменная верхнего уровня.
 Переменная для задания всей строки режима
называется @code{mode-line-format}.


@defopt mode-line-format
Значение переменной элемент (конструкт) строки режима, задающий
содержимое строки режима. Как правило это локальная для буфера
переменная.

Если значение переменной установить в @code{nil}, строки режима
у буфера не будет. (Окна высотой в 1 строку так же не имеют
строки режима).
@end defopt

Значение по умолчанию @code{mode-line-format} проектируется с
использованием значением таких переменных как @code{mode-line-position} и
@code{mode-line-modes} (которые объединяют значение переменных
@code{mode-name} и @code{minor-mode-alist}). Совсем немногим
режимам требуется изменение @code{mode-line-format} самостоятельно.
В большинстве случаев, достаточно задать какие-то переменные
которые влияют на @code{mode-line-format}.

Если вы изменяете @code{mode-line-format}, новое
значение должно использовать те же переменные что и в
оригинальном значении (@pxref{Mode Line Variables}),
вместо дублирования их значений или использования другого
способа отображения информации. Такой способ, позволяет
оставить возможность настройки через переменные пользователем или
Lisp программой (как @code{display-time} и основными режимами).

Ниже гипотетический пример @code{mode-line-format}, который
может использоваться для Shell режима (в реальности, Shell режим, не
задает @code{mode-line-format}).

@example
@group
(setq mode-line-format
  (list "-"
   'mode-line-mule-info
   'mode-line-modified
   'mode-line-frame-identification
   "%b--"
@end group
@group
   ;; @r{Отметим, что это вычисляется при построении списка.}
   ;; @r{Получается  конструкт строки режима который является строкой.}
   (getenv "HOST")
@end group
   ":"
   'default-directory
   "   "
   'global-mode-string
   "   %[("
   '(:eval (mode-line-mode-name))
   'mode-line-process
   'minor-mode-alist
   "%n"
   ")%]--"
@group
   '(which-func-mode ("" which-func-format "--"))
   '(line-number-mode "L%l--")
   '(column-number-mode "C%c--")
   '(-3 "%p")))
@end group
@end example

@noindent
(Переменные @code{line-number-mode}, @code{column-number-mode}
и @code{which-func-mode} включают соответствующие дополнительные режимы; как правило,
имена этих переменных являются именами команд дополнительных режимов.)

@node Mode Line Variables
@subsection Variables Used in the Mode Line

Переменные строки режима.
  Данная секция содержит описание переменных объединяющихся в
значение строки режима для стандартного значения @code{mode-line-format}.
Ничем существенно особенным эти переменные не являются; но некоторые
переменные могут иметь определенное влияние не строку режима,
если значение @code{mode-line-format} изменено, так чтобы они
использовались. Но, различные части Emacs устанавливают значения
данных переменных, считая, что влияют на строку режима; таким образом;
важно чтобы строка режима их использовала. См. @ref{Optional Mode Line,,,
emacs, The GNU Emacs Manual}.
(Суть в том, что если изменяется @code{mode-line-format}, стоит
оставить в ней использование описанных ниже переменных, так как
другой Lisp код считает что они используются).

@defvar mode-line-mule-info
Переменная в строке режима определяет отображение информации
о языке, кодировке буфера, и текущем методе ввода.
@xref{Non-ASCII Characters}.
@end defvar

@defvar mode-line-modified
Переменная отвечает за информации о том, был ли буфер изменен.
Типичные значения: @samp{**} -- буфер изменен, @samp{--} -- не
изменен, @samp{%%} -- буфер только для чтения, @samp{%*} -- буфер
только для чтения, но при этом изменен.

Изменение этой переменной, не приводит к немедленному обновлению
строки режима.
@end defvar

@defvar mode-line-frame-identification
Переменная определяет отображение информации о текущем фрейме.
Значение по умолчанию:
@code{" "} -- если используется система окон, которая
может отображать множество фреймов, или @code{"-%F "} на
терминалах, которые могут отображать только один фрейм за раз.
@end defvar

@defvar mode-line-buffer-identification
Переменная отвечает за отображение информации о буфере. Значение по умолчанию
предполагает отображение имени буфера расширенное пробелами до минимальных
12 символов.
@end defvar

@defvar mode-line-position
Переменная определяет отображение позиции в буфере. Значение по умолчанию
отображает часть буфера сверху в процентах, и опционально размер
буфера, номер строки и столбца курсора.
@end defvar

@defvar vc-mode
Переменная @code{vc-mode} локальная для буфера, определяет,
поддерживается для контроль версий для файла буфера, и если да
то какая система контроля версий. Значение переменной строка,
которая отображается в строке режима или @code{nil} если
система контроля версий не используется.
@end defvar

@defvar mode-line-modes
Переменная определяет отображение основного и дополнительных режимов.
Значение по умолчанию также отображает уровень рекурсивного редактироавния
(recursive editing level), информацию о статусе процесса и используется
ли сужение (narrow).
(narrow -- такая штука когда, выделяется часть буфера, нажимается
C-x n n (narrow-to-region) и редактируется только часть буфера,
потом нажимается C-x n w (widen) и опять видим весь буфер).
@end defvar

@defvar mode-line-remote
Переменная определяет отображение удаленности @code{default-directory}.
То есть является ли текущий каталог удаленным (прим. например ssh.).
@end defvar

@defvar mode-line-client
Переменная отображает @code{emacsclient} фреймов.
@end defvar

  Три следующих переменных используются в @code{mode-line-modes}:

@defvar mode-name
 Локальная для буфера переменная хранит ``pretty'' (удобное) имя
основного режима. Каждый основной режим устанавливает данную переменную.
Значение не обязано быть строкой, но может использовать все типы данных
конструктов (частей) строки режима (@pxref{Mode Line Data}).
Для вычисления строки, которая появится в строки режима можно
использовать @code{format-mode-line} (@pxref{Emulating Mode Line}).
@end defvar

@defvar mode-line-process
Локальная для буфера переменная содержит информацию о статусе
процесса в режимах используемых для связи с подпроцессами.
Значение отображается сразу за именем основного режима.
Например в буфере @file{*shell*} используется значение @code{(":%s")},
которое позволяет оболочке (shell) отображать статус вместе
с основным режимом как: @samp{(Shell:run)}.
Обычно значение переменной @code{nil}.
@end defvar

@defvar mode-line-front-space
Значение данной переменной отображается в начале строки режима, за
исключением наличия memory-full сообщения.
@end defvar

@defvar mode-line-end-spaces
Значение данной переменной отображается в конце строки режима.
@end defvar

@defvar mode-line-misc-info
Переменная используется для отображения дополнительно информации.
По умолчанию, переменная отображает информации заданную
@code{global-mode-string}.
@end defvar

@defvar minor-mode-alist
@anchor{Definition of minor-mode-alist}
Переменная содержит ассоциативный список элементы которого определяют
как должно отображаться в строке режима активность соответствующего
дополнительного режима. Каждый элемент @code{minor-mode-alist}
должен быть 2-х элементным списком:

@example
(@var{minor-mode-variable} @var{mode-line-string})
@end example


В общем, @var{mode-line-string} может быть любым конструктом
строки режима. Значение появляется в строке режима, когда
@var{minor-mode-variable}  не-@code{nil}. Строки должна
начинаться с пробела, чтобы названия режимов не сливались.
Традиционно, переменная @var{minor-mode-variable} режима не-@code{nil}
когда дополнительный режим активен.

@code{minor-mode-alist} не локальная для буфера. Но переменные
используемые в списке, должны быть локальными для буфера, если
дополнительный режим может включаться-выключаться в отдельных буферах.
@end defvar

@defvar global-mode-string
This variable holds a mode line construct that, by default, appears in
the mode line just after the @code{which-func-mode} minor mode if set,
else after @code{mode-line-modes}.  The command @code{display-time} sets
@code{global-mode-string} to refer to the variable
@code{display-time-string}, which holds a string containing the time and
load information.

The @samp{%M} construct substitutes the value of
@code{global-mode-string}, but that is obsolete, since the variable is
included in the mode line from @code{mode-line-format}.
@end defvar

Here is a simplified version of the default value of
@code{mode-line-format}.  The real default value also
specifies addition of text properties.

@example
@group
("-"
 mode-line-mule-info
 mode-line-modified
 mode-line-frame-identification
 mode-line-buffer-identification
@end group
 "   "
 mode-line-position
 (vc-mode vc-mode)
 "   "
@group
 mode-line-modes
 (which-func-mode ("" which-func-format "--"))
 (global-mode-string ("--" global-mode-string))
 "-%-")
@end group
@end example

@node %-Constructs
@subsection @code{%}-Constructs in the Mode Line

  Strings used as mode line constructs can use certain
@code{%}-constructs to substitute various kinds of data.  The
following is a list of the defined @code{%}-constructs, and what they
mean.

  In any construct except @samp{%%}, you can add a decimal integer
after the @samp{%} to specify a minimum field width.  If the width is
less, the field is padded to that width.  Purely numeric constructs
(@samp{c}, @samp{i}, @samp{I}, and @samp{l}) are padded by inserting
spaces to the left, and others are padded by inserting spaces to the
right.

@table @code
@item %b
The current buffer name, obtained with the @code{buffer-name} function.
@xref{Buffer Names}.

@item %c
The current column number of point.

@item %e
When Emacs is nearly out of memory for Lisp objects, a brief message
saying so.  Otherwise, this is empty.

@item %f
The visited file name, obtained with the @code{buffer-file-name}
function.  @xref{Buffer File Name}.

@item %F
The title (only on a window system) or the name of the selected frame.
@xref{Basic Parameters}.

@item %i
The size of the accessible part of the current buffer; basically
@code{(- (point-max) (point-min))}.

@item %I
Like @samp{%i}, but the size is printed in a more readable way by using
@samp{k} for 10^3, @samp{M} for 10^6, @samp{G} for 10^9, etc., to
abbreviate.

@item %l
The current line number of point, counting within the accessible portion
of the buffer.

@item %n
@samp{Narrow} when narrowing is in effect; nothing otherwise (see
@code{narrow-to-region} in @ref{Narrowing}).

@item %p
The percentage of the buffer text above the @strong{top} of window, or
@samp{Top}, @samp{Bottom} or @samp{All}.  Note that the default mode
line construct truncates this to three characters.

@item %P
The percentage of the buffer text that is above the @strong{bottom} of
the window (which includes the text visible in the window, as well as
the text above the top), plus @samp{Top} if the top of the buffer is
visible on screen; or @samp{Bottom} or @samp{All}.

@item %s
The status of the subprocess belonging to the current buffer, obtained with
@code{process-status}.  @xref{Process Information}.

@item %z
The mnemonics of keyboard, terminal, and buffer coding systems.

@item %Z
Like @samp{%z}, but including the end-of-line format.

@item %*
@samp{%} if the buffer is read only (see @code{buffer-read-only}); @*
@samp{*} if the buffer is modified (see @code{buffer-modified-p}); @*
@samp{-} otherwise.  @xref{Buffer Modification}.

@item %+
@samp{*} if the buffer is modified (see @code{buffer-modified-p}); @*
@samp{%} if the buffer is read only (see @code{buffer-read-only}); @*
@samp{-} otherwise.  This differs from @samp{%*} only for a modified
read-only buffer.  @xref{Buffer Modification}.

@item %&
@samp{*} if the buffer is modified, and @samp{-} otherwise.

@item %[
An indication of the depth of recursive editing levels (not counting
minibuffer levels): one @samp{[} for each editing level.
@xref{Recursive Editing}.

@item %]
One @samp{]} for each recursive editing level (not counting minibuffer
levels).

@item %-
Dashes sufficient to fill the remainder of the mode line.

@item %%
The character @samp{%}---this is how to include a literal @samp{%} in a
string in which @code{%}-constructs are allowed.
@end table

The following two @code{%}-constructs are still supported, but they are
obsolete, since you can get the same results with the variables
@code{mode-name} and @code{global-mode-string}.

@table @code
@item %m
The value of @code{mode-name}.

@item %M
The value of @code{global-mode-string}.
@end table

@node Properties in Mode
@subsection Properties in the Mode Line
@cindex text properties in the mode line

  Certain text properties are meaningful in the
mode line.  The @code{face} property affects the appearance of text; the
@code{help-echo} property associates help strings with the text, and
@code{keymap} can make the text mouse-sensitive.

  There are four ways to specify text properties for text in the mode
line:

@enumerate
@item
Put a string with a text property directly into the mode line data
structure.

@item
Put a text property on a mode line %-construct such as @samp{%12b}; then
the expansion of the %-construct will have that same text property.

@item
Use a @code{(:propertize @var{elt} @var{props}@dots{})} construct to
give @var{elt} a text property specified by @var{props}.

@item
Use a list containing @code{:eval @var{form}} in the mode line data
structure, and make @var{form} evaluate to a string that has a text
property.
@end enumerate

  You can use the @code{keymap} property to specify a keymap.  This
keymap only takes real effect for mouse clicks; binding character keys
and function keys to it has no effect, since it is impossible to move
point into the mode line.

  When the mode line refers to a variable which does not have a
non-@code{nil} @code{risky-local-variable} property, any text
properties given or specified within that variable's values are
ignored.  This is because such properties could otherwise specify
functions to be called, and those functions could come from file
local variables.

@node Header Lines
@subsection Window Header Lines
@cindex header line (of a window)
@cindex window header line

  A window can have a @dfn{header line} at the top, just as it can have
a mode line at the bottom.  The header line feature works just like the
mode line feature, except that it's controlled by
@code{header-line-format}:

@defvar header-line-format
This variable, local in every buffer, specifies how to display the
header line, for windows displaying the buffer.  The format of the value
is the same as for @code{mode-line-format} (@pxref{Mode Line Data}).
It is normally @code{nil}, so that ordinary buffers have no header line.
@end defvar

@defun window-header-line-height &optional window
This function returns the height in pixels of @var{window}'s header
line.  @var{window} must be a live window, and defaults to the
selected window.
@end defun

  A window that is just one line tall never displays a header line.  A
window that is two lines tall cannot display both a mode line and a
header line at once; if it has a mode line, then it does not display a
header line.

@node Emulating Mode Line
@subsection Emulating Mode Line Formatting

  You can use the function @code{format-mode-line} to compute the text
that would appear in a mode line or header line based on a certain
mode line construct.

@defun format-mode-line format &optional face window buffer
This function formats a line of text according to @var{format} as if it
were generating the mode line for @var{window}, but it also returns the
text as a string.  The argument @var{window} defaults to the selected
window.  If @var{buffer} is non-@code{nil}, all the information used is
taken from @var{buffer}; by default, it comes from @var{window}'s
buffer.

The value string normally has text properties that correspond to the
faces, keymaps, etc., that the mode line would have.  Any character for
which no @code{face} property is specified by @var{format} gets a
default value determined by @var{face}.  If @var{face} is @code{t}, that
stands for either @code{mode-line} if @var{window} is selected,
otherwise @code{mode-line-inactive}.  If @var{face} is @code{nil} or
omitted, that stands for the default face.  If @var{face} is an integer,
the value returned by this function will have no text properties.

You can also specify other valid faces as the value of @var{face}.
If specified, that face provides the @code{face} property for characters
whose face is not specified by @var{format}.

Note that using @code{mode-line}, @code{mode-line-inactive}, or
@code{header-line} as @var{face} will actually redisplay the mode line
or the header line, respectively, using the current definitions of the
corresponding face, in addition to returning the formatted string.
(Other faces do not cause redisplay.)

For example, @code{(format-mode-line header-line-format)} returns the
text that would appear in the selected window's header line (@code{""}
if it has no header line).  @code{(format-mode-line header-line-format
'header-line)} returns the same text, with each character
carrying the face that it will have in the header line itself, and also
redraws the header line.
@end defun

@node Imenu
@section Imenu

@cindex Imenu
  @dfn{Imenu} is a feature that lets users select a definition or
section in the buffer, from a menu which lists all of them, to go
directly to that location in the buffer.  Imenu works by constructing
a buffer index which lists the names and buffer positions of the
definitions, or other named portions of the buffer; then the user can
choose one of them and move point to it.  Major modes can add a menu
bar item to use Imenu using @code{imenu-add-to-menubar}.

@deffn Command imenu-add-to-menubar name
This function defines a local menu bar item named @var{name}
to run Imenu.
@end deffn

  The user-level commands for using Imenu are described in the Emacs
Manual (@pxref{Imenu,, Imenu, emacs, the Emacs Manual}).  This section
explains how to customize Imenu's method of finding definitions or
buffer portions for a particular major mode.

  The usual and simplest way is to set the variable
@code{imenu-generic-expression}:

@defvar imenu-generic-expression
This variable, if non-@code{nil}, is a list that specifies regular
expressions for finding definitions for Imenu.  Simple elements of
@code{imenu-generic-expression} look like this:

@example
(@var{menu-title} @var{regexp} @var{index})
@end example

Here, if @var{menu-title} is non-@code{nil}, it says that the matches
for this element should go in a submenu of the buffer index;
@var{menu-title} itself specifies the name for the submenu.  If
@var{menu-title} is @code{nil}, the matches for this element go directly
in the top level of the buffer index.

The second item in the list, @var{regexp}, is a regular expression
(@pxref{Regular Expressions}); anything in the buffer that it matches
is considered a definition, something to mention in the buffer index.
The third item, @var{index}, is a non-negative integer that indicates
which subexpression in @var{regexp} matches the definition's name.

An element can also look like this:

@example
(@var{menu-title} @var{regexp} @var{index} @var{function} @var{arguments}@dots{})
@end example

Each match for this element creates an index item, and when the index
item is selected by the user, it calls @var{function} with arguments
consisting of the item name, the buffer position, and @var{arguments}.

For Emacs Lisp mode, @code{imenu-generic-expression} could look like
this:

@c should probably use imenu-syntax-alist and \\sw rather than [-A-Za-z0-9+]
@example
@group
((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Types*"
  "^\\s-*\
(def\\(type\\|struct\\|class\\|ine-condition\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2))
@end group
@end example

Setting this variable makes it buffer-local in the current buffer.
@end defvar

@defvar imenu-case-fold-search
This variable controls whether matching against the regular
expressions in the value of @code{imenu-generic-expression} is
case-sensitive: @code{t}, the default, means matching should ignore
case.

Setting this variable makes it buffer-local in the current buffer.
@end defvar

@defvar imenu-syntax-alist
This variable is an alist of syntax table modifiers to use while
processing @code{imenu-generic-expression}, to override the syntax table
of the current buffer.  Each element should have this form:

@example
(@var{characters} . @var{syntax-description})
@end example

The @sc{car}, @var{characters}, can be either a character or a string.
The element says to give that character or characters the syntax
specified by @var{syntax-description}, which is passed to
@code{modify-syntax-entry} (@pxref{Syntax Table Functions}).

This feature is typically used to give word syntax to characters which
normally have symbol syntax, and thus to simplify
@code{imenu-generic-expression} and speed up matching.
For example, Fortran mode uses it this way:

@example
(setq imenu-syntax-alist '(("_$" . "w")))
@end example

The @code{imenu-generic-expression} regular expressions can then use
@samp{\\sw+} instead of @samp{\\(\\sw\\|\\s_\\)+}.  Note that this
technique may be inconvenient when the mode needs to limit the initial
character of a name to a smaller set of characters than are allowed in
the rest of a name.

Setting this variable makes it buffer-local in the current buffer.
@end defvar

  Another way to customize Imenu for a major mode is to set the
variables @code{imenu-prev-index-position-function} and
@code{imenu-extract-index-name-function}:

@defvar imenu-prev-index-position-function
If this variable is non-@code{nil}, its value should be a function that
finds the next definition to put in the buffer index, scanning
backward in the buffer from point.  It should return @code{nil} if it
doesn't find another definition before point.  Otherwise it should
leave point at the place it finds a definition and return any
non-@code{nil} value.

Setting this variable makes it buffer-local in the current buffer.
@end defvar

@defvar imenu-extract-index-name-function
If this variable is non-@code{nil}, its value should be a function to
return the name for a definition, assuming point is in that definition
as the @code{imenu-prev-index-position-function} function would leave
it.

Setting this variable makes it buffer-local in the current buffer.
@end defvar

  The last way to customize Imenu for a major mode is to set the
variable @code{imenu-create-index-function}:

@defvar imenu-create-index-function
This variable specifies the function to use for creating a buffer
index.  The function should take no arguments, and return an index
alist for the current buffer.  It is called within
@code{save-excursion}, so where it leaves point makes no difference.

The index alist can have three types of elements.  Simple elements
look like this:

@example
(@var{index-name} . @var{index-position})
@end example

Selecting a simple element has the effect of moving to position
@var{index-position} in the buffer.  Special elements look like this:

@example
(@var{index-name} @var{index-position} @var{function} @var{arguments}@dots{})
@end example

Selecting a special element performs:

@example
(funcall @var{function}
         @var{index-name} @var{index-position} @var{arguments}@dots{})
@end example

A nested sub-alist element looks like this:

@example
(@var{menu-title} . @var{sub-alist})
@end example

It creates the submenu @var{menu-title} specified by @var{sub-alist}.

The default value of @code{imenu-create-index-function} is
@code{imenu-default-create-index-function}.  This function calls the
value of @code{imenu-prev-index-position-function} and the value of
@code{imenu-extract-index-name-function} to produce the index alist.
However, if either of these two variables is @code{nil}, the default
function uses @code{imenu-generic-expression} instead.

Setting this variable makes it buffer-local in the current buffer.
@end defvar

@node Font Lock Mode
@section Font Lock Mode
@cindex Font Lock mode

  @dfn{Font Lock mode} is a buffer-local minor mode that automatically
attaches @code{face} properties to certain parts of the buffer based on
their syntactic role.  How it parses the buffer depends on the major
mode; most major modes define syntactic criteria for which faces to use
in which contexts.  This section explains how to customize Font Lock for
a particular major mode.

  Font Lock mode finds text to highlight in two ways: through
syntactic parsing based on the syntax table, and through searching
(usually for regular expressions).  Syntactic fontification happens
first; it finds comments and string constants and highlights them.
Search-based fontification happens second.

@menu
* Font Lock Basics::            Overview of customizing Font Lock.
* Search-based Fontification::  Fontification based on regexps.
* Customizing Keywords::        Customizing search-based fontification.
* Other Font Lock Variables::   Additional customization facilities.
* Levels of Font Lock::         Each mode can define alternative levels
                                  so that the user can select more or less.
* Precalculated Fontification::  How Lisp programs that produce the buffer
                                  contents can also specify how to fontify it.
* Faces for Font Lock::         Special faces specifically for Font Lock.
* Syntactic Font Lock::         Fontification based on syntax tables.
* Multiline Font Lock::         How to coerce Font Lock into properly
                                  highlighting multiline constructs.
@end menu

@node Font Lock Basics
@subsection Font Lock Basics

  The Font Lock functionality is based on several basic functions.
Each of these calls the function specified by the corresponding
variable.  This indirection allows major and minor modes to modify the
way fontification works in the buffers of that mode, and even use the
Font Lock mechanisms for features that have nothing to do with
fontification.  (This is why the description below says ``should''
when it describes what the functions do: the mode can customize the
values of the corresponding variables to do something entirely
different.)  The variables mentioned below are described in @ref{Other
Font Lock Variables}.

@ftable @code
@item font-lock-fontify-buffer
This function should fontify the current buffer's accessible portion,
by calling the function specified by
@code{font-lock-fontify-buffer-function}.

@item font-lock-unfontify-buffer
Used when turning Font Lock off to remove the fontification.  Calls
the function specified by @code{font-lock-unfontify-buffer-function}.

@item font-lock-fontify-region beg end &optional loudly
Should fontify the region between @var{beg} and @var{end}.  If
@var{loudly} is non-@code{nil}, should display status messages while
fontifying.  Calls the function specified by
@code{font-lock-fontify-region-function}.

@item font-lock-unfontify-region beg end
Should remove fontification from the region between @var{beg} and
@var{end}.  Calls the function specified by
@code{font-lock-unfontify-region-function}.

@item font-lock-flush &optional beg end
This function should mark the fontification of the region between
@var{beg} and @var{end} as outdated.  If not specified or @code{nil},
@var{beg} and @var{end} default to the beginning and end of the
buffer's accessible portion.  Calls the function specified by
@code{font-lock-flush-function}.

@item font-lock-ensure &optional beg end
This function should make sure the region between @var{beg} and
@var{end} has been fontified.  The optional arguments @var{beg} and
@var{end} default to the beginning and the end of the buffer's
accessible portion.  Calls the function specified by
@code{font-lock-ensure-function}.
@end ftable

  There are several variables that control how Font Lock mode highlights
text.  But major modes should not set any of these variables directly.
Instead, they should set @code{font-lock-defaults} as a buffer-local
variable.  The value assigned to this variable is used, if and when Font
Lock mode is enabled, to set all the other variables.

@defvar font-lock-defaults
This variable is set by modes to specify how to fontify text in that
mode.  It automatically becomes buffer-local when set.  If its value
is @code{nil}, Font Lock mode does no highlighting, and you can use
the @samp{Faces} menu (under @samp{Edit} and then @samp{Text
Properties} in the menu bar) to assign faces explicitly to text in the
buffer.

If non-@code{nil}, the value should look like this:

@example
(@var{keywords} [@var{keywords-only} [@var{case-fold}
 [@var{syntax-alist} @var{other-vars}@dots{}]]])
@end example

The first element, @var{keywords}, indirectly specifies the value of
@code{font-lock-keywords} which directs search-based fontification.
It can be a symbol, a variable or a function whose value is the list
to use for @code{font-lock-keywords}.  It can also be a list of
several such symbols, one for each possible level of fontification.
The first symbol specifies the @samp{mode default} level of
fontification, the next symbol level 1 fontification, the next level 2,
and so on.  The @samp{mode default} level is normally the same as level
1.  It is used when @code{font-lock-maximum-decoration} has a @code{nil}
value.  @xref{Levels of Font Lock}.

The second element, @var{keywords-only}, specifies the value of the
variable @code{font-lock-keywords-only}.  If this is omitted or
@code{nil}, syntactic fontification (of strings and comments) is also
performed.  If this is non-@code{nil}, syntactic fontification is not
performed.  @xref{Syntactic Font Lock}.

The third element, @var{case-fold}, specifies the value of
@code{font-lock-keywords-case-fold-search}.  If it is non-@code{nil},
Font Lock mode ignores case during search-based fontification.

If the fourth element, @var{syntax-alist}, is non-@code{nil}, it should
be a list of cons cells of the form @code{(@var{char-or-string}
. @var{string})}.  These are used to set up a syntax table for syntactic
fontification; the resulting syntax table is stored in
@code{font-lock-syntax-table}.  If @var{syntax-alist} is omitted or
@code{nil}, syntactic fontification uses the syntax table returned by
the @code{syntax-table} function.  @xref{Syntax Table Functions}.

All the remaining elements (if any) are collectively called
@var{other-vars}.  Each of these elements should have the form
@code{(@var{variable} . @var{value})}---which means, make
@var{variable} buffer-local and then set it to @var{value}.  You can
use these @var{other-vars} to set other variables that affect
fontification, aside from those you can control with the first five
elements.  @xref{Other Font Lock Variables}.
@end defvar

  If your mode fontifies text explicitly by adding
@code{font-lock-face} properties, it can specify @code{(nil t)} for
@code{font-lock-defaults} to turn off all automatic fontification.
However, this is not required; it is possible to fontify some things
using @code{font-lock-face} properties and set up automatic
fontification for other parts of the text.

@node Search-based Fontification
@subsection Search-based Fontification

  The variable which directly controls search-based fontification is
@code{font-lock-keywords}, which is typically specified via the
@var{keywords} element in @code{font-lock-defaults}.

@defvar font-lock-keywords
The value of this variable is a list of the keywords to highlight.  Lisp
programs should not set this variable directly.  Normally, the value is
automatically set by Font Lock mode, using the @var{keywords} element in
@code{font-lock-defaults}.  The value can also be altered using the
functions @code{font-lock-add-keywords} and
@code{font-lock-remove-keywords} (@pxref{Customizing Keywords}).
@end defvar

  Each element of @code{font-lock-keywords} specifies how to find
certain cases of text, and how to highlight those cases.  Font Lock mode
processes the elements of @code{font-lock-keywords} one by one, and for
each element, it finds and handles all matches.  Ordinarily, once
part of the text has been fontified already, this cannot be overridden
by a subsequent match in the same text; but you can specify different
behavior using the @var{override} element of a @var{subexp-highlighter}.

  Each element of @code{font-lock-keywords} should have one of these
forms:

@table @code
@item @var{regexp}
Highlight all matches for @var{regexp} using
@code{font-lock-keyword-face}.  For example,

@example
;; @r{Highlight occurrences of the word @samp{foo}}
;; @r{using @code{font-lock-keyword-face}.}
"\\<foo\\>"
@end example

Be careful when composing these regular expressions; a poorly written
pattern can dramatically slow things down!  The function
@code{regexp-opt} (@pxref{Regexp Functions}) is useful for calculating
optimal regular expressions to match several keywords.

@item @var{function}
Find text by calling @var{function}, and highlight the matches
it finds using @code{font-lock-keyword-face}.

When @var{function} is called, it receives one argument, the limit of
the search; it should begin searching at point, and not search beyond the
limit.  It should return non-@code{nil} if it succeeds, and set the
match data to describe the match that was found.  Returning @code{nil}
indicates failure of the search.

Fontification will call @var{function} repeatedly with the same limit,
and with point where the previous invocation left it, until
@var{function} fails.  On failure, @var{function} need not reset point
in any particular way.

@item (@var{matcher} . @var{subexp})
In this kind of element, @var{matcher} is either a regular
expression or a function, as described above.  The @sc{cdr},
@var{subexp}, specifies which subexpression of @var{matcher} should be
highlighted (instead of the entire text that @var{matcher} matched).

@example
;; @r{Highlight the @samp{bar} in each occurrence of @samp{fubar},}
;; @r{using @code{font-lock-keyword-face}.}
("fu\\(bar\\)" . 1)
@end example

If you use @code{regexp-opt} to produce the regular expression
@var{matcher}, you can use @code{regexp-opt-depth} (@pxref{Regexp
Functions}) to calculate the value for @var{subexp}.

@item (@var{matcher} . @var{facespec})
In this kind of element, @var{facespec} is an expression whose value
specifies the face to use for highlighting.  In the simplest case,
@var{facespec} is a Lisp variable (a symbol) whose value is a face
name.

@example
;; @r{Highlight occurrences of @samp{fubar},}
;; @r{using the face which is the value of @code{fubar-face}.}
("fubar" . fubar-face)
@end example

However, @var{facespec} can also evaluate to a list of this form:

@example
(face @var{face} @var{prop1} @var{val1} @var{prop2} @var{val2}@dots{})
@end example

@noindent
to specify the face @var{face} and various additional text properties
to put on the text that matches.  If you do this, be sure to add the
other text property names that you set in this way to the value of
@code{font-lock-extra-managed-props} so that the properties will also
be cleared out when they are no longer appropriate.  Alternatively,
you can set the variable @code{font-lock-unfontify-region-function} to
a function that clears these properties.  @xref{Other Font Lock
Variables}.

@item (@var{matcher} . @var{subexp-highlighter})
In this kind of element, @var{subexp-highlighter} is a list
which specifies how to highlight matches found by @var{matcher}.
It has the form:

@example
(@var{subexp} @var{facespec} [@var{override} [@var{laxmatch}]])
@end example

The @sc{car}, @var{subexp}, is an integer specifying which subexpression
of the match to fontify (0 means the entire matching text).  The second
subelement, @var{facespec}, is an expression whose value specifies the
face, as described above.

The last two values in @var{subexp-highlighter}, @var{override} and
@var{laxmatch}, are optional flags.  If @var{override} is @code{t},
this element can override existing fontification made by previous
elements of @code{font-lock-keywords}.  If it is @code{keep}, then
each character is fontified if it has not been fontified already by
some other element.  If it is @code{prepend}, the face specified by
@var{facespec} is added to the beginning of the @code{font-lock-face}
property.  If it is @code{append}, the face is added to the end of the
@code{font-lock-face} property.

If @var{laxmatch} is non-@code{nil}, it means there should be no error
if there is no subexpression numbered @var{subexp} in @var{matcher}.
Obviously, fontification of the subexpression numbered @var{subexp} will
not occur.  However, fontification of other subexpressions (and other
regexps) will continue.  If @var{laxmatch} is @code{nil}, and the
specified subexpression is missing, then an error is signaled which
terminates search-based fontification.

Here are some examples of elements of this kind, and what they do:

@smallexample
;; @r{Highlight occurrences of either @samp{foo} or @samp{bar}, using}
;; @r{@code{foo-bar-face}, even if they have already been highlighted.}
;; @r{@code{foo-bar-face} should be a variable whose value is a face.}
("foo\\|bar" 0 foo-bar-face t)

;; @r{Highlight the first subexpression within each occurrence}
;; @r{that the function @code{fubar-match} finds,}
;; @r{using the face which is the value of @code{fubar-face}.}
(fubar-match 1 fubar-face)
@end smallexample

@item (@var{matcher} . @var{anchored-highlighter})
In this kind of element, @var{anchored-highlighter} specifies how to
highlight text that follows a match found by @var{matcher}.  So a
match found by @var{matcher} acts as the anchor for further searches
specified by @var{anchored-highlighter}.  @var{anchored-highlighter}
is a list of the following form:

@example
(@var{anchored-matcher} @var{pre-form} @var{post-form}
                        @var{subexp-highlighters}@dots{})
@end example

Here, @var{anchored-matcher}, like @var{matcher}, is either a regular
expression or a function.  After a match of @var{matcher} is found,
point is at the end of the match.  Now, Font Lock evaluates the form
@var{pre-form}.  Then it searches for matches of
@var{anchored-matcher} and uses @var{subexp-highlighters} to highlight
these.  A @var{subexp-highlighter} is as described above.  Finally,
Font Lock evaluates @var{post-form}.

The forms @var{pre-form} and @var{post-form} can be used to initialize
before, and cleanup after, @var{anchored-matcher} is used.  Typically,
@var{pre-form} is used to move point to some position relative to the
match of @var{matcher}, before starting with @var{anchored-matcher}.
@var{post-form} might be used to move back, before resuming with
@var{matcher}.

After Font Lock evaluates @var{pre-form}, it does not search for
@var{anchored-matcher} beyond the end of the line.  However, if
@var{pre-form} returns a buffer position that is greater than the
position of point after @var{pre-form} is evaluated, then the position
returned by @var{pre-form} is used as the limit of the search instead.
It is generally a bad idea to return a position greater than the end
of the line; in other words, the @var{anchored-matcher} search should
not span lines.

For example,

@smallexample
;; @r{Highlight occurrences of the word @samp{item} following}
;; @r{an occurrence of the word @samp{anchor} (on the same line)}
;; @r{in the value of @code{item-face}.}
("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))
@end smallexample

Here, @var{pre-form} and @var{post-form} are @code{nil}.  Therefore
searching for @samp{item} starts at the end of the match of
@samp{anchor}, and searching for subsequent instances of @samp{anchor}
resumes from where searching for @samp{item} concluded.

@item (@var{matcher} @var{highlighters}@dots{})
This sort of element specifies several @var{highlighter} lists for a
single @var{matcher}.  A @var{highlighter} list can be of the type
@var{subexp-highlighter} or @var{anchored-highlighter} as described
above.

For example,

@smallexample
;; @r{Highlight occurrences of the word @samp{anchor} in the value}
;; @r{of @code{anchor-face}, and subsequent occurrences of the word}
;; @r{@samp{item} (on the same line) in the value of @code{item-face}.}
("\\<anchor\\>" (0 anchor-face)
                ("\\<item\\>" nil nil (0 item-face)))
@end smallexample

@item (eval . @var{form})
Here @var{form} is an expression to be evaluated the first time
this value of @code{font-lock-keywords} is used in a buffer.
Its value should have one of the forms described in this table.
@end table

@strong{Warning:} Do not design an element of @code{font-lock-keywords}
to match text which spans lines; this does not work reliably.
For details, see @xref{Multiline Font Lock}.

You can use @var{case-fold} in @code{font-lock-defaults} to specify
the value of @code{font-lock-keywords-case-fold-search} which says
whether search-based fontification should be case-insensitive.

@defvar font-lock-keywords-case-fold-search
Non-@code{nil} means that regular expression matching for the sake of
@code{font-lock-keywords} should be case-insensitive.
@end defvar

@node Customizing Keywords
@subsection Customizing Search-Based Fontification

  You can use @code{font-lock-add-keywords} to add additional
search-based fontification rules to a major mode, and
@code{font-lock-remove-keywords} to remove rules.

@defun font-lock-add-keywords mode keywords &optional how
This function adds highlighting @var{keywords}, for the current buffer
or for major mode @var{mode}.  The argument @var{keywords} should be a
list with the same format as the variable @code{font-lock-keywords}.

If @var{mode} is a symbol which is a major mode command name, such as
@code{c-mode}, the effect is that enabling Font Lock mode in
@var{mode} will add @var{keywords} to @code{font-lock-keywords}.
Calling with a non-@code{nil} value of @var{mode} is correct only in
your @file{~/.emacs} file.

If @var{mode} is @code{nil}, this function adds @var{keywords} to
@code{font-lock-keywords} in the current buffer.  This way of calling
@code{font-lock-add-keywords} is usually used in mode hook functions.

By default, @var{keywords} are added at the beginning of
@code{font-lock-keywords}.  If the optional argument @var{how} is
@code{set}, they are used to replace the value of
@code{font-lock-keywords}.  If @var{how} is any other non-@code{nil}
value, they are added at the end of @code{font-lock-keywords}.

Some modes provide specialized support you can use in additional
highlighting patterns.  See the variables
@code{c-font-lock-extra-types}, @code{c++-font-lock-extra-types},
and @code{java-font-lock-extra-types}, for example.

@strong{Warning:} Major mode commands must not call
@code{font-lock-add-keywords} under any circumstances, either directly
or indirectly, except through their mode hooks.  (Doing so would lead to
incorrect behavior for some minor modes.)  They should set up their
rules for search-based fontification by setting
@code{font-lock-keywords}.
@end defun

@defun font-lock-remove-keywords mode keywords
This function removes @var{keywords} from @code{font-lock-keywords}
for the current buffer or for major mode @var{mode}.  As in
@code{font-lock-add-keywords}, @var{mode} should be a major mode
command name or @code{nil}.  All the caveats and requirements for
@code{font-lock-add-keywords} apply here too.  The argument
@var{keywords} must exactly match the one used by the corresponding
@code{font-lock-add-keywords}.
@end defun

  For example, the following code adds two fontification patterns for C
mode: one to fontify the word @samp{FIXME}, even in comments, and
another to fontify the words @samp{and}, @samp{or} and @samp{not} as
keywords.

@smallexample
(font-lock-add-keywords 'c-mode
 '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
   ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))
@end smallexample

@noindent
This example affects only C mode proper.  To add the same patterns to C
mode @emph{and} all modes derived from it, do this instead:

@smallexample
(add-hook 'c-mode-hook
 (lambda ()
  (font-lock-add-keywords nil
   '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
     ("\\<\\(and\\|or\\|not\\)\\>" .
      font-lock-keyword-face)))))
@end smallexample

@node Other Font Lock Variables
@subsection Other Font Lock Variables

  This section describes additional variables that a major mode can
set by means of @var{other-vars} in @code{font-lock-defaults}
(@pxref{Font Lock Basics}).

@defvar font-lock-mark-block-function
If this variable is non-@code{nil}, it should be a function that is
called with no arguments, to choose an enclosing range of text for
refontification for the command @kbd{M-o M-o}
(@code{font-lock-fontify-block}).

The function should report its choice by placing the region around it.
A good choice is a range of text large enough to give proper results,
but not too large so that refontification becomes slow.  Typical values
are @code{mark-defun} for programming modes or @code{mark-paragraph} for
textual modes.
@end defvar

@defvar font-lock-extra-managed-props
This variable specifies additional properties (other than
@code{font-lock-face}) that are being managed by Font Lock mode.  It
is used by @code{font-lock-default-unfontify-region}, which normally
only manages the @code{font-lock-face} property.  If you want Font
Lock to manage other properties as well, you must specify them in a
@var{facespec} in @code{font-lock-keywords} as well as add them to
this list.  @xref{Search-based Fontification}.
@end defvar

@defvar font-lock-fontify-buffer-function
Function to use for fontifying the buffer.  The default value is
@code{font-lock-default-fontify-buffer}.
@end defvar

@defvar font-lock-unfontify-buffer-function
Function to use for unfontifying the buffer.  This is used when
turning off Font Lock mode.  The default value is
@code{font-lock-default-unfontify-buffer}.
@end defvar

@defvar font-lock-fontify-region-function
Function to use for fontifying a region.  It should take two
arguments, the beginning and end of the region, and an optional third
argument @var{verbose}.  If @var{verbose} is non-@code{nil}, the
function should print status messages.  The default value is
@code{font-lock-default-fontify-region}.
@end defvar

@defvar font-lock-unfontify-region-function
Function to use for unfontifying a region.  It should take two
arguments, the beginning and end of the region.  The default value is
@code{font-lock-default-unfontify-region}.
@end defvar

@defvar font-lock-flush-function
Function to use for declaring that a region's fontification is out of
date.  It takes two arguments, the beginning and end of the region.
The default value of this variable is
@code{font-lock-after-change-function}.
@end defvar

@defvar font-lock-ensure-function
Function to use for making sure a region of the current buffer has
been fontified.  It is called with two arguments, the beginning and
end of the region.  The default value of this variable is a function
that calls @code{font-lock-default-fontify-buffer} if the buffer is
not fontified; the effect is to make sure the entire accessible
portion of the buffer is fontified.
@end defvar

@defun jit-lock-register function &optional contextual
This function tells Font Lock mode to run the Lisp function
@var{function} any time it has to fontify or refontify part of the
current buffer.  It calls @var{function} before calling the default
fontification functions, and gives it two arguments, @var{start} and
@var{end}, which specify the region to be fontified or refontified.

The optional argument @var{contextual}, if non-@code{nil}, forces Font
Lock mode to always refontify a syntactically relevant part of the
buffer, and not just the modified lines.  This argument can usually be
omitted.
@end defun

@defun jit-lock-unregister function
If @var{function} was previously registered as a fontification
function using @code{jit-lock-register}, this function unregisters it.
@end defun

@node Levels of Font Lock
@subsection Levels of Font Lock

  Some major modes offer three different levels of fontification.  You
can define multiple levels by using a list of symbols for @var{keywords}
in @code{font-lock-defaults}.  Each symbol specifies one level of
fontification; it is up to the user to choose one of these levels,
normally by setting @code{font-lock-maximum-decoration} (@pxref{Font
Lock,,, emacs, the GNU Emacs Manual}).  The chosen level's symbol value
is used to initialize @code{font-lock-keywords}.

  Here are the conventions for how to define the levels of
fontification:

@itemize @bullet
@item
Level 1: highlight function declarations, file directives (such as include or
import directives), strings and comments.  The idea is speed, so only
the most important and top-level components are fontified.

@item
Level 2: in addition to level 1, highlight all language keywords,
including type names that act like keywords, as well as named constant
values.  The idea is that all keywords (either syntactic or semantic)
should be fontified appropriately.

@item
Level 3: in addition to level 2, highlight the symbols being defined in
function and variable declarations, and all builtin function names,
wherever they appear.
@end itemize

@node Precalculated Fontification
@subsection Precalculated Fontification

  Some major modes such as @code{list-buffers} and @code{occur}
construct the buffer text programmatically.  The easiest way for them
to support Font Lock mode is to specify the faces of text when they
insert the text in the buffer.

  The way to do this is to specify the faces in the text with the
special text property @code{font-lock-face} (@pxref{Special
Properties}).  When Font Lock mode is enabled, this property controls
the display, just like the @code{face} property.  When Font Lock mode
is disabled, @code{font-lock-face} has no effect on the display.

  It is ok for a mode to use @code{font-lock-face} for some text and
also use the normal Font Lock machinery.  But if the mode does not use
the normal Font Lock machinery, it should not set the variable
@code{font-lock-defaults}.

@node Faces for Font Lock
@subsection Faces for Font Lock
@cindex faces for font lock
@cindex font lock faces

  Font Lock mode can highlight using any face, but Emacs defines several
faces specifically for Font Lock to use to highlight text.  These
@dfn{Font Lock faces} are listed below.  They can also be used by major
modes for syntactic highlighting outside of Font Lock mode (@pxref{Major
Mode Conventions}).

  Each of these symbols is both a face name, and a variable whose
default value is the symbol itself.  Thus, the default value of
@code{font-lock-comment-face} is @code{font-lock-comment-face}.

  The faces are listed with descriptions of their typical usage, and in
order of greater to lesser prominence.  If a mode's syntactic
categories do not fit well with the usage descriptions, the faces can be
assigned using the ordering as a guide.

@table @code
@item font-lock-warning-face
@vindex font-lock-warning-face
for a construct that is peculiar, or that greatly changes the meaning of
other text, like @samp{;;;###autoload} in Emacs Lisp and @samp{#error}
in C.

@item font-lock-function-name-face
@vindex font-lock-function-name-face
for the name of a function being defined or declared.

@item font-lock-variable-name-face
@vindex font-lock-variable-name-face
for the name of a variable being defined or declared.

@item font-lock-keyword-face
@vindex font-lock-keyword-face
for a keyword with special syntactic significance, like @samp{for} and
@samp{if} in C.

@item font-lock-comment-face
@vindex font-lock-comment-face
for comments.

@item font-lock-comment-delimiter-face
@vindex font-lock-comment-delimiter-face
for comments delimiters, like @samp{/*} and @samp{*/} in C@.  On most
terminals, this inherits from @code{font-lock-comment-face}.

@item font-lock-type-face
@vindex font-lock-type-face
for the names of user-defined data types.

@item font-lock-constant-face
@vindex font-lock-constant-face
for the names of constants, like @samp{NULL} in C.

@item font-lock-builtin-face
@vindex font-lock-builtin-face
for the names of built-in functions.

@item font-lock-preprocessor-face
@vindex font-lock-preprocessor-face
for preprocessor commands.  This inherits, by default, from
@code{font-lock-builtin-face}.

@item font-lock-string-face
@vindex font-lock-string-face
for string constants.

@item font-lock-doc-face
@vindex font-lock-doc-face
for documentation strings in the code.  This inherits, by default, from
@code{font-lock-string-face}.

@item font-lock-negation-char-face
@vindex font-lock-negation-char-face
for easily-overlooked negation characters.
@end table

@node Syntactic Font Lock
@subsection Syntactic Font Lock
@cindex syntactic font lock

Syntactic fontification uses a syntax table (@pxref{Syntax Tables}) to
find and highlight syntactically relevant text.  If enabled, it runs
prior to search-based fontification.  The variable
@code{font-lock-syntactic-face-function}, documented below, determines
which syntactic constructs to highlight.  There are several variables
that affect syntactic fontification; you should set them by means of
@code{font-lock-defaults} (@pxref{Font Lock Basics}).

  Whenever Font Lock mode performs syntactic fontification on a stretch
of text, it first calls the function specified by
@code{syntax-propertize-function}.  Major modes can use this to apply
@code{syntax-table} text properties to override the buffer's syntax
table in special cases.  @xref{Syntax Properties}.

@defvar font-lock-keywords-only
If the value of this variable is non-@code{nil}, Font Lock does not do
syntactic fontification, only search-based fontification based on
@code{font-lock-keywords}.  It is normally set by Font Lock mode based
on the @var{keywords-only} element in @code{font-lock-defaults}.
@end defvar

@defvar font-lock-syntax-table
This variable holds the syntax table to use for fontification of
comments and strings.  It is normally set by Font Lock mode based on the
@var{syntax-alist} element in @code{font-lock-defaults}.  If this value
is @code{nil}, syntactic fontification uses the buffer's syntax table
(the value returned by the function @code{syntax-table}; @pxref{Syntax
Table Functions}).
@end defvar

@defvar font-lock-syntactic-face-function
If this variable is non-@code{nil}, it should be a function to determine
which face to use for a given syntactic element (a string or a comment).
The value is normally set through an @var{other-vars} element in
@code{font-lock-defaults}.

The function is called with one argument, the parse state at point
returned by @code{parse-partial-sexp}, and should return a face.  The
default value returns @code{font-lock-comment-face} for comments and
@code{font-lock-string-face} for strings (@pxref{Faces for Font Lock}).
@end defvar

@node Multiline Font Lock
@subsection Multiline Font Lock Constructs
@cindex multiline font lock

  Normally, elements of @code{font-lock-keywords} should not match
across multiple lines; that doesn't work reliably, because Font Lock
usually scans just part of the buffer, and it can miss a multi-line
construct that crosses the line boundary where the scan starts.  (The
scan normally starts at the beginning of a line.)

  Making elements that match multiline constructs work properly has
two aspects: correct @emph{identification} and correct
@emph{rehighlighting}.  The first means that Font Lock finds all
multiline constructs.  The second means that Font Lock will correctly
rehighlight all the relevant text when a multiline construct is
changed---for example, if some of the text that was previously part of
a multiline construct ceases to be part of it.  The two aspects are
closely related, and often getting one of them to work will appear to
make the other also work.  However, for reliable results you must
attend explicitly to both aspects.

  There are three ways to ensure correct identification of multiline
constructs:

@itemize
@item
Add a function to @code{font-lock-extend-region-functions} that does
the @emph{identification} and extends the scan so that the scanned
text never starts or ends in the middle of a multiline construct.
@item
Use the @code{font-lock-fontify-region-function} hook similarly to
extend the scan so that the scanned text never starts or ends in the
middle of a multiline construct.
@item
Somehow identify the multiline construct right when it gets inserted
into the buffer (or at any point after that but before font-lock
tries to highlight it), and mark it with a @code{font-lock-multiline}
which will instruct font-lock not to start or end the scan in the
middle of the construct.
@end itemize

  There are three ways to do rehighlighting of multiline constructs:

@itemize
@item
Place a @code{font-lock-multiline} property on the construct.  This
will rehighlight the whole construct if any part of it is changed.  In
some cases you can do this automatically by setting the
@code{font-lock-multiline} variable, which see.
@item
Make sure @code{jit-lock-contextually} is set and rely on it doing its
job.  This will only rehighlight the part of the construct that
follows the actual change, and will do it after a short delay.
This only works if the highlighting of the various parts of your
multiline construct never depends on text in subsequent lines.
Since @code{jit-lock-contextually} is activated by default, this can
be an attractive solution.
@item
Place a @code{jit-lock-defer-multiline} property on the construct.
This works only if @code{jit-lock-contextually} is used, and with the
same delay before rehighlighting, but like @code{font-lock-multiline},
it also handles the case where highlighting depends on
subsequent lines.
@end itemize

@menu
* Font Lock Multiline::         Marking multiline chunks with a text property.
* Region to Refontify::         Controlling which region gets refontified
                                  after a buffer change.
@end menu

@node Font Lock Multiline
@subsubsection Font Lock Multiline

  One way to ensure reliable rehighlighting of multiline Font Lock
constructs is to put on them the text property @code{font-lock-multiline}.
It should be present and non-@code{nil} for text that is part of a
multiline construct.

  When Font Lock is about to highlight a range of text, it first
extends the boundaries of the range as necessary so that they do not
fall within text marked with the @code{font-lock-multiline} property.
Then it removes any @code{font-lock-multiline} properties from the
range, and highlights it.  The highlighting specification (mostly
@code{font-lock-keywords}) must reinstall this property each time,
whenever it is appropriate.

  @strong{Warning:} don't use the @code{font-lock-multiline} property
on large ranges of text, because that will make rehighlighting slow.

@defvar font-lock-multiline
If the @code{font-lock-multiline} variable is set to @code{t}, Font
Lock will try to add the @code{font-lock-multiline} property
automatically on multiline constructs.  This is not a universal
solution, however, since it slows down Font Lock somewhat.  It can
miss some multiline constructs, or make the property larger or smaller
than necessary.

For elements whose @var{matcher} is a function, the function should
ensure that submatch 0 covers the whole relevant multiline construct,
even if only a small subpart will be highlighted.  It is often just as
easy to add the @code{font-lock-multiline} property by hand.
@end defvar

  The @code{font-lock-multiline} property is meant to ensure proper
refontification; it does not automatically identify new multiline
constructs.  Identifying the requires that Font Lock mode operate on
large enough chunks at a time.  This will happen by accident on many
cases, which may give the impression that multiline constructs magically
work.  If you set the @code{font-lock-multiline} variable
non-@code{nil}, this impression will be even stronger, since the
highlighting of those constructs which are found will be properly
updated from then on.  But that does not work reliably.

  To find multiline constructs reliably, you must either manually place
the @code{font-lock-multiline} property on the text before Font Lock
mode looks at it, or use @code{font-lock-fontify-region-function}.

@node Region to Refontify
@subsubsection Region to Fontify after a Buffer Change

  When a buffer is changed, the region that Font Lock refontifies is
by default the smallest sequence of whole lines that spans the change.
While this works well most of the time, sometimes it doesn't---for
example, when a change alters the syntactic meaning of text on an
earlier line.

  You can enlarge (or even reduce) the region to refontify by setting
the following variable:

@defvar font-lock-extend-after-change-region-function
This buffer-local variable is either @code{nil} or a function for Font
Lock mode to call to determine the region to scan and fontify.

The function is given three parameters, the standard @var{beg},
@var{end}, and @var{old-len} from @code{after-change-functions}
(@pxref{Change Hooks}).  It should return either a cons of the
beginning and end buffer positions (in that order) of the region to
fontify, or @code{nil} (which means choose the region in the standard
way).  This function needs to preserve point, the match-data, and the
current restriction.  The region it returns may start or end in the
middle of a line.

Since this function is called after every buffer change, it should be
reasonably fast.
@end defvar

@node Auto-Indentation
@section Automatic Indentation of code

For programming languages, an important feature of a major mode is to
provide automatic indentation.  There are two parts: one is to decide what
is the right indentation of a line, and the other is to decide when to
reindent a line.  By default, Emacs reindents a line whenever you
type a character in @code{electric-indent-chars}, which by default only
includes Newline.  Major modes can add chars to @code{electric-indent-chars}
according to the syntax of the language.

Deciding what is the right indentation is controlled in Emacs by
@code{indent-line-function} (@pxref{Mode-Specific Indent}).  For some modes,
the @emph{right} indentation cannot be known reliably, typically because
indentation is significant so several indentations are valid but with different
meanings.  In that case, the mode should set @code{electric-indent-inhibit} to
make sure the line is not constantly re-indented against the user's wishes.

Writing a good indentation function can be difficult and to a large extent it
is still a black art.  Many major mode authors will start by writing a simple
indentation function that works for simple cases, for example by comparing with
the indentation of the previous text line.  For most programming languages that
are not really line-based, this tends to scale very poorly: improving
such a function to let it handle more diverse situations tends to become more
and more difficult, resulting in the end with a large, complex, unmaintainable
indentation function which nobody dares to touch.

A good indentation function will usually need to actually parse the
text, according to the syntax of the language.  Luckily, it is not
necessary to parse the text in as much detail as would be needed
for a compiler, but on the other hand, the parser embedded in the
indentation code will want to be somewhat friendly to syntactically
incorrect code.

Good maintainable indentation functions usually fall into two categories:
either parsing forward from some safe starting point until the
position of interest, or parsing backward from the position of interest.
Neither of the two is a clearly better choice than the other: parsing
backward is often more difficult than parsing forward because
programming languages are designed to be parsed forward, but for the
purpose of indentation it has the advantage of not needing to
guess a safe starting point, and it generally enjoys the property
that only a minimum of text will be analyzed to decide the indentation
of a line, so indentation will tend to be less affected by syntax errors in
some earlier unrelated piece of code.  Parsing forward on the other hand
is usually easier and has the advantage of making it possible to
reindent efficiently a whole region at a time, with a single parse.

Rather than write your own indentation function from scratch, it is
often preferable to try and reuse some existing ones or to rely
on a generic indentation engine.  There are sadly few such
engines.  The CC-mode indentation code (used with C, C++, Java, Awk
and a few other such modes) has been made more generic over the years,
so if your language seems somewhat similar to one of those languages,
you might try to use that engine.  @c FIXME: documentation?
Another one is SMIE which takes an approach in the spirit
of Lisp sexps and adapts it to non-Lisp languages.

@menu
* SMIE::                        A simple minded indentation engine.
@end menu

@node SMIE
@subsection Simple Minded Indentation Engine
@cindex SMIE

SMIE is a package that provides a generic navigation and indentation
engine.  Based on a very simple parser using an operator precedence
grammar, it lets major modes extend the sexp-based navigation of Lisp
to non-Lisp languages as well as provide a simple to use but reliable
auto-indentation.

Operator precedence grammar is a very primitive technology for parsing
compared to some of the more common techniques used in compilers.
It has the following characteristics: its parsing power is very limited,
and it is largely unable to detect syntax errors, but it has the
advantage of being algorithmically efficient and able to parse forward
just as well as backward.  In practice that means that SMIE can use it
for indentation based on backward parsing, that it can provide both
@code{forward-sexp} and @code{backward-sexp} functionality, and that it
will naturally work on syntactically incorrect code without any extra
effort.  The downside is that it also means that most programming
languages cannot be parsed correctly using SMIE, at least not without
resorting to some special tricks (@pxref{SMIE Tricks}).

@menu
* SMIE setup::                  SMIE setup and features.
* Operator Precedence Grammars::  A very simple parsing technique.
* SMIE Grammar::                Defining the grammar of a language.
* SMIE Lexer::                  Defining tokens.
* SMIE Tricks::                 Working around the parser's limitations.
* SMIE Indentation::            Specifying indentation rules.
* SMIE Indentation Helpers::    Helper functions for indentation rules.
* SMIE Indentation Example::    Sample indentation rules.
* SMIE Customization::          Customizing indentation.
@end menu

@node SMIE setup
@subsubsection SMIE Setup and Features

SMIE is meant to be a one-stop shop for structural navigation and
various other features which rely on the syntactic structure of code, in
particular automatic indentation.  The main entry point is
@code{smie-setup} which is a function typically called while setting
up a major mode.

@defun smie-setup grammar rules-function &rest keywords
Setup SMIE navigation and indentation.
@var{grammar} is a grammar table generated by @code{smie-prec2->grammar}.
@var{rules-function} is a set of indentation rules for use on
@code{smie-rules-function}.
@var{keywords} are additional arguments, which can include the following
keywords:
@itemize
@item
@code{:forward-token} @var{fun}: Specify the forward lexer to use.
@item
@code{:backward-token} @var{fun}: Specify the backward lexer to use.
@end itemize
@end defun

Calling this function is sufficient to make commands such as
@code{forward-sexp}, @code{backward-sexp}, and @code{transpose-sexps} be
able to properly handle structural elements other than just the paired
parentheses already handled by syntax tables.  For example, if the
provided grammar is precise enough, @code{transpose-sexps} can correctly
transpose the two arguments of a @code{+} operator, taking into account
the precedence rules of the language.

Calling @code{smie-setup} is also sufficient to make TAB indentation work in
the expected way, extends @code{blink-matching-paren} to apply to
elements like @code{begin...end}, and provides some commands that you
can bind in the major mode keymap.

@deffn Command smie-close-block
This command closes the most recently opened (and not yet closed) block.
@end deffn

@deffn Command smie-down-list &optional arg
This command is like @code{down-list} but it also pays attention to
nesting of tokens other than parentheses, such as @code{begin...end}.
@end deffn

@node Operator Precedence Grammars
@subsubsection Operator Precedence Grammars

SMIE's precedence grammars simply give to each token a pair of
precedences: the left-precedence and the right-precedence.  We say
@code{T1 < T2} if the right-precedence of token @code{T1} is less than
the left-precedence of token @code{T2}.  A good way to read this
@code{<} is as a kind of parenthesis: if we find @code{... T1 something
T2 ...}  then that should be parsed as @code{... T1 (something T2 ...}
rather than as @code{... T1 something) T2 ...}.  The latter
interpretation would be the case if we had @code{T1 > T2}.  If we have
@code{T1 = T2}, it means that token T2 follows token T1 in the same
syntactic construction, so typically we have @code{"begin" = "end"}.
Such pairs of precedences are sufficient to express left-associativity
or right-associativity of infix operators, nesting of tokens like
parentheses and many other cases.

@c Let's leave this undocumented to leave it more open for change!
@c @defvar smie-grammar
@c The value of this variable is an alist specifying the left and right
@c precedence of each token.  It is meant to be initialized by using one of
@c the functions below.
@c @end defvar

@defun smie-prec2->grammar table
This function takes a @emph{prec2} grammar @var{table} and returns an
alist suitable for use in @code{smie-setup}.  The @emph{prec2}
@var{table} is itself meant to be built by one of the functions below.
@end defun

@defun smie-merge-prec2s &rest tables
This function takes several @emph{prec2} @var{tables} and merges them
into a new @emph{prec2} table.
@end defun

@defun smie-precs->prec2 precs
This function builds a @emph{prec2} table from a table of precedences
@var{precs}.  @var{precs} should be a list, sorted by precedence (for
example @code{"+"} will come before @code{"*"}), of elements of the form
@code{(@var{assoc} @var{op} ...)}, where each @var{op} is a token that
acts as an operator; @var{assoc} is their associativity, which can be
either @code{left}, @code{right}, @code{assoc}, or @code{nonassoc}.
All operators in a given element share the same precedence level
and associativity.
@end defun

@defun smie-bnf->prec2 bnf &rest resolvers
This function lets you specify the grammar using a BNF notation.
It accepts a @var{bnf} description of the grammar along with a set of
conflict resolution rules @var{resolvers}, and
returns a @emph{prec2} table.

@var{bnf} is a list of nonterminal definitions of the form
@code{(@var{nonterm} @var{rhs1} @var{rhs2} ...)} where each @var{rhs}
is a (non-empty) list of terminals (aka tokens) or non-terminals.

Not all grammars are accepted:
@itemize
@item
An @var{rhs} cannot be an empty list (an empty list is never needed,
since SMIE allows all non-terminals to match the empty string anyway).
@item
An @var{rhs} cannot have 2 consecutive non-terminals: each pair of
non-terminals needs to be separated by a terminal (aka token).
This is a fundamental limitation of operator precedence grammars.
@end itemize

Additionally, conflicts can occur:
@itemize
@item
The returned @emph{prec2} table holds constraints between pairs of tokens, and
for any given pair only one constraint can be present: T1 < T2,
T1 = T2, or T1 > T2.
@item
A token can be an @code{opener} (something similar to an open-paren),
a @code{closer} (like a close-paren), or @code{neither} of the two
(e.g., an infix operator, or an inner token like @code{"else"}).
@end itemize

Precedence conflicts can be resolved via @var{resolvers}, which
is a list of @emph{precs} tables (see @code{smie-precs->prec2}): for
each precedence conflict, if those @code{precs} tables
specify a particular constraint, then the conflict is resolved by using
this constraint instead, else a conflict is reported and one of the
conflicting constraints is picked arbitrarily and the others are
simply ignored.
@end defun

@node SMIE Grammar
@subsubsection Defining the Grammar of a Language
@cindex SMIE grammar
@cindex grammar, SMIE

The usual way to define the SMIE grammar of a language is by
defining a new global variable that holds the precedence table by
giving a set of BNF rules.
For example, the grammar definition for a small Pascal-like language
could look like:
@example
@group
(require 'smie)
(defvar sample-smie-grammar
  (smie-prec2->grammar
   (smie-bnf->prec2
@end group
@group
    '((id)
      (inst ("begin" insts "end")
            ("if" exp "then" inst "else" inst)
            (id ":=" exp)
            (exp))
      (insts (insts ";" insts) (inst))
      (exp (exp "+" exp)
           (exp "*" exp)
           ("(" exps ")"))
      (exps (exps "," exps) (exp)))
@end group
@group
    '((assoc ";"))
    '((assoc ","))
    '((assoc "+") (assoc "*")))))
@end group
@end example

@noindent
A few things to note:

@itemize
@item
The above grammar does not explicitly mention the syntax of function
calls: SMIE will automatically allow any sequence of sexps, such as
identifiers, balanced parentheses, or @code{begin ... end} blocks
to appear anywhere anyway.
@item
The grammar category @code{id} has no right hand side: this does not
mean that it can match only the empty string, since as mentioned any
sequence of sexps can appear anywhere anyway.
@item
Because non terminals cannot appear consecutively in the BNF grammar, it
is difficult to correctly handle tokens that act as terminators, so the
above grammar treats @code{";"} as a statement @emph{separator} instead,
which SMIE can handle very well.
@item
Separators used in sequences (such as @code{","} and @code{";"} above)
are best defined with BNF rules such as @code{(foo (foo "separator" foo) ...)}
which generate precedence conflicts which are then resolved by giving
them an explicit @code{(assoc "separator")}.
@item
The @code{("(" exps ")")} rule was not needed to pair up parens, since
SMIE will pair up any characters that are marked as having paren syntax
in the syntax table.  What this rule does instead (together with the
definition of @code{exps}) is to make it clear that @code{","} should
not appear outside of parentheses.
@item
Rather than have a single @emph{precs} table to resolve conflicts, it is
preferable to have several tables, so as to let the BNF part of the
grammar specify relative precedences where possible.
@item
Unless there is a very good reason to prefer @code{left} or
@code{right}, it is usually preferable to mark operators as associative,
using @code{assoc}.  For that reason @code{"+"} and @code{"*"} are
defined above as @code{assoc}, although the language defines them
formally as left associative.
@end itemize

@node SMIE Lexer
@subsubsection Defining Tokens
@cindex SMIE lexer
@cindex defining tokens, SMIE

SMIE comes with a predefined lexical analyzer which uses syntax tables
in the following way: any sequence of characters that have word or
symbol syntax is considered a token, and so is any sequence of
characters that have punctuation syntax.  This default lexer is
often a good starting point but is rarely actually correct for any given
language.  For example, it will consider @code{"2,+3"} to be composed
of 3 tokens: @code{"2"}, @code{",+"}, and @code{"3"}.

To describe the lexing rules of your language to SMIE, you need
2 functions, one to fetch the next token, and another to fetch the
previous token.  Those functions will usually first skip whitespace and
comments and then look at the next chunk of text to see if it
is a special token.  If so it should skip the token and
return a description of this token.  Usually this is simply the string
extracted from the buffer, but it can be anything you want.
For example:
@example
@group
(defvar sample-keywords-regexp
  (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
@end group
@group
(defun sample-smie-forward-token ()
  (forward-comment (point-max))
  (cond
   ((looking-at sample-keywords-regexp)
    (goto-char (match-end 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-forward "w_")
              (point))))))
@end group
@group
(defun sample-smie-backward-token ()
  (forward-comment (- (point)))
  (cond
   ((looking-back sample-keywords-regexp (- (point) 2) t)
    (goto-char (match-beginning 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-backward "w_")
              (point))))))
@end group
@end example

Notice how those lexers return the empty string when in front of
parentheses.  This is because SMIE automatically takes care of the
parentheses defined in the syntax table.  More specifically if the lexer
returns @code{nil} or an empty string, SMIE tries to handle the corresponding
text as a sexp according to syntax tables.

@node SMIE Tricks
@subsubsection Living With a Weak Parser

The parsing technique used by SMIE does not allow tokens to behave
differently in different contexts.  For most programming languages, this
manifests itself by precedence conflicts when converting the
BNF grammar.

Sometimes, those conflicts can be worked around by expressing the
grammar slightly differently.  For example, for Modula-2 it might seem
natural to have a BNF grammar that looks like this:

@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (cases (cases "|" cases)
         (caselabel ":" insts)
         ("ELSE" insts))
  ...
@end example

But this will create conflicts for @code{"ELSE"}: on the one hand, the
IF rule implies (among many other things) that @code{"ELSE" = "END"};
but on the other hand, since @code{"ELSE"} appears within @code{cases},
which appears left of @code{"END"}, we also have @code{"ELSE" > "END"}.
We can solve the conflict either by using:
@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ("CASE" exp "OF" cases "ELSE" insts "END")
        ...)
  (cases (cases "|" cases) (caselabel ":" insts))
  ...
@end example
or
@example
  ...
  (inst ("IF" exp "THEN" else "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (else (insts "ELSE" insts))
  (cases (cases "|" cases) (caselabel ":" insts) (else))
  ...
@end example

Reworking the grammar to try and solve conflicts has its downsides, tho,
because SMIE assumes that the grammar reflects the logical structure of
the code, so it is preferable to keep the BNF closer to the intended
abstract syntax tree.

Other times, after careful consideration you may conclude that those
conflicts are not serious and simply resolve them via the
@var{resolvers} argument of @code{smie-bnf->prec2}.  Usually this is
because the grammar is simply ambiguous: the conflict does not affect
the set of programs described by the grammar, but only the way those
programs are parsed.  This is typically the case for separators and
associative infix operators, where you want to add a resolver like
@code{'((assoc "|"))}.  Another case where this can happen is for the
classic @emph{dangling else} problem, where you will use @code{'((assoc
"else" "then"))}.  It can also happen for cases where the conflict is
real and cannot really be resolved, but it is unlikely to pose a problem
in practice.

Finally, in many cases some conflicts will remain despite all efforts to
restructure the grammar.  Do not despair: while the parser cannot be
made more clever, you can make the lexer as smart as you want.  So, the
solution is then to look at the tokens involved in the conflict and to
split one of those tokens into 2 (or more) different tokens.  E.g., if
the grammar needs to distinguish between two incompatible uses of the
token @code{"begin"}, make the lexer return different tokens (say
@code{"begin-fun"} and @code{"begin-plain"}) depending on which kind of
@code{"begin"} it finds.  This pushes the work of distinguishing the
different cases to the lexer, which will thus have to look at the
surrounding text to find ad-hoc clues.

@node SMIE Indentation
@subsubsection Specifying Indentation Rules
@cindex indentation rules, SMIE

Based on the provided grammar, SMIE will be able to provide automatic
indentation without any extra effort.  But in practice, this default
indentation style will probably not be good enough.  You will want to
tweak it in many different cases.

SMIE indentation is based on the idea that indentation rules should be
as local as possible.  To this end, it relies on the idea of
@emph{virtual} indentation, which is the indentation that a particular
program point would have if it were at the beginning of a line.
Of course, if that program point is indeed at the beginning of a line,
its virtual indentation is its current indentation.  But if not, then
SMIE uses the indentation algorithm to compute the virtual indentation
of that point.  Now in practice, the virtual indentation of a program
point does not have to be identical to the indentation it would have if
we inserted a newline before it.  To see how this works, the SMIE rule
for indentation after a @code{@{} in C does not care whether the
@code{@{} is standing on a line of its own or is at the end of the
preceding line.  Instead, these different cases are handled in the
indentation rule that decides how to indent before a @code{@{}.

Another important concept is the notion of @emph{parent}: The
@emph{parent} of a token, is the head token of the nearest enclosing
syntactic construct.  For example, the parent of an @code{else} is the
@code{if} to which it belongs, and the parent of an @code{if}, in turn,
is the lead token of the surrounding construct.  The command
@code{backward-sexp} jumps from a token to its parent, but there are
some caveats: for @emph{openers} (tokens which start a construct, like
@code{if}), you need to start with point before the token, while for
others you need to start with point after the token.
@code{backward-sexp} stops with point before the parent token if that is
the @emph{opener} of the token of interest, and otherwise it stops with
point after the parent token.

SMIE indentation rules are specified using a function that takes two
arguments @var{method} and @var{arg} where the meaning of @var{arg} and the
expected return value depend on @var{method}.

@var{method} can be:
@itemize
@item
@code{:after}, in which case @var{arg} is a token and the function
should return the @var{offset} to use for indentation after @var{arg}.
@item
@code{:before}, in which case @var{arg} is a token and the function
should return the @var{offset} to use to indent @var{arg} itself.
@item
@code{:elem}, in which case the function should return either the offset
to use to indent function arguments (if @var{arg} is the symbol
@code{arg}) or the basic indentation step (if @var{arg} is the symbol
@code{basic}).
@item
@code{:list-intro}, in which case @var{arg} is a token and the function
should return non-@code{nil} if the token is followed by a list of
expressions (not separated by any token) rather than an expression.
@end itemize

When @var{arg} is a token, the function is called with point just before
that token.  A return value of @code{nil} always means to fallback on the
default behavior, so the function should return @code{nil} for arguments it
does not expect.

@var{offset} can be:
@itemize
@item
@code{nil}: use the default indentation rule.
@item
@code{(column . @var{column})}: indent to column @var{column}.
@item
@var{number}: offset by @var{number}, relative to a base token which is
the current token for @code{:after} and its parent for @code{:before}.
@end itemize

@node SMIE Indentation Helpers
@subsubsection Helper Functions for Indentation Rules

SMIE provides various functions designed specifically for use in the
indentation rules function (several of those functions break if used in
another context).  These functions all start with the prefix
@code{smie-rule-}.

@defun smie-rule-bolp
Return non-@code{nil} if the current token is the first on the line.
@end defun

@defun smie-rule-hanging-p
Return non-@code{nil} if the current token is @emph{hanging}.
A token is @emph{hanging} if it is the last token on the line
and if it is preceded by other tokens: a lone token on a line is not
hanging.
@end defun

@defun smie-rule-next-p &rest tokens
Return non-@code{nil} if the next token is among @var{tokens}.
@end defun

@defun smie-rule-prev-p &rest tokens
Return non-@code{nil} if the previous token is among @var{tokens}.
@end defun

@defun smie-rule-parent-p &rest parents
Return non-@code{nil} if the current token's parent is among @var{parents}.
@end defun

@defun smie-rule-sibling-p
Return non-@code{nil} if the current token's parent is actually a
sibling.  This is the case for example when the parent of a @code{","}
is just the previous @code{","}.
@end defun

@defun smie-rule-parent &optional offset
Return the proper offset to align the current token with the parent.
If non-@code{nil}, @var{offset} should be an integer giving an
additional offset to apply.
@end defun

@defun smie-rule-separator method
Indent current token as a @emph{separator}.

By @emph{separator}, we mean here a token whose sole purpose is to
separate various elements within some enclosing syntactic construct, and
which does not have any semantic significance in itself (i.e., it would
typically not exist as a node in an abstract syntax tree).

Such a token is expected to have an associative syntax and be closely
tied to its syntactic parent.  Typical examples are @code{","} in lists
of arguments (enclosed inside parentheses), or @code{";"} in sequences
of instructions (enclosed in a @code{@{...@}} or @code{begin...end}
block).

@var{method} should be the method name that was passed to
@code{smie-rules-function}.
@end defun

@node SMIE Indentation Example
@subsubsection Sample Indentation Rules

Here is an example of an indentation function:

@example
(defun sample-smie-rules (kind token)
  (pcase (cons kind token)
    (`(:elem . basic) sample-indent-basic)
    (`(,_ . ",") (smie-rule-separator kind))
    (`(:after . ":=") sample-indent-basic)
    (`(:before . ,(or `"begin" `"(" `"@{")))
     (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "if")
     (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
          (smie-rule-parent)))))
@end example

@noindent
A few things to note:

@itemize
@item
The first case indicates the basic indentation increment to use.
If @code{sample-indent-basic} is @code{nil}, then SMIE uses the global
setting @code{smie-indent-basic}.  The major mode could have set
@code{smie-indent-basic} buffer-locally instead, but that
is discouraged.

@item
The rule for the token @code{","} make SMIE try to be more clever when
the comma separator is placed at the beginning of lines.  It tries to
outdent the separator so as to align the code after the comma; for
example:

@example
x = longfunctionname (
        arg1
      , arg2
    );
@end example

@item
The rule for indentation after @code{":="} exists because otherwise
SMIE would treat @code{":="} as an infix operator and would align the
right argument with the left one.

@item
The rule for indentation before @code{"begin"} is an example of the use
of virtual indentation:  This rule is used only when @code{"begin"} is
hanging, which can happen only when @code{"begin"} is not at the
beginning of a line.  So this is not used when indenting
@code{"begin"} itself but only when indenting something relative to this
@code{"begin"}.  Concretely, this rule changes the indentation from:

@example
    if x > 0 then begin
            dosomething(x);
        end
@end example
to
@example
    if x > 0 then begin
        dosomething(x);
    end
@end example

@item
The rule for indentation before @code{"if"} is similar to the one for
@code{"begin"}, but where the purpose is to treat @code{"else if"}
as a single unit, so as to align a sequence of tests rather than indent
each test further to the right.  This function does this only in the
case where the @code{"if"} is not placed on a separate line, hence the
@code{smie-rule-bolp} test.

If we know that the @code{"else"} is always aligned with its @code{"if"}
and is always at the beginning of a line, we can use a more efficient
rule:
@example
((equal token "if")
 (and (not (smie-rule-bolp))
      (smie-rule-prev-p "else")
      (save-excursion
        (sample-smie-backward-token)
        (cons 'column (current-column)))))
@end example

The advantage of this formulation is that it reuses the indentation of
the previous @code{"else"}, rather than going all the way back to the
first @code{"if"} of the sequence.
@end itemize

@c In some sense this belongs more in the Emacs manual.
@node SMIE Customization
@subsubsection Customizing Indentation

If you are using a mode whose indentation is provided by SMIE, you can
customize the indentation to suit your preferences.  You can do this
on a per-mode basis (using the option @code{smie-config}), or a
per-file basis (using the function @code{smie-config-local} in a
file-local variable specification).

@defopt smie-config
This option lets you customize indentation on a per-mode basis.
It is an alist with elements of the form @code{(@var{mode} . @var{rules})}.
For the precise form of rules, see the variable's documentation; but
you may find it easier to use the command @code{smie-config-guess}.
@end defopt

@deffn Command smie-config-guess
This command tries to work out appropriate settings to produce
your preferred style of indentation.  Simply call the command while
visiting a file that is indented with your style.
@end deffn

@deffn Command smie-config-save
Call this command after using @code{smie-config-guess}, to save your
settings for future sessions.
@end deffn

@deffn Command smie-config-show-indent &optional move
This command displays the rules that are used to indent the current
line.
@end deffn

@deffn Command smie-config-set-indent
This command adds a local rule to adjust the indentation of the current line.
@end deffn

@defun smie-config-local rules
This function adds @var{rules} as indentation rules for the current buffer.
These add to any mode-specific rules defined by the @code{smie-config} option.
To specify custom indentation rules for a specific file, add an entry
to the file's local variables of the form:
@code{eval: (smie-config-local '(@var{rules}))}.
@end defun


@node Desktop Save Mode
@section Desktop Save Mode
@cindex desktop save mode

@dfn{Desktop Save Mode} is a feature to save the state of Emacs from
one session to another.  The user-level commands for using Desktop
Save Mode are described in the GNU Emacs Manual (@pxref{Saving Emacs
Sessions,,, emacs, the GNU Emacs Manual}).  Modes whose buffers visit
a file, don't have to do anything to use this feature.

For buffers not visiting a file to have their state saved, the major
mode must bind the buffer local variable @code{desktop-save-buffer} to
a non-@code{nil} value.

@defvar desktop-save-buffer
If this buffer-local variable is non-@code{nil}, the buffer will have
its state saved in the desktop file at desktop save.  If the value is
a function, it is called at desktop save with argument
@var{desktop-dirname}, and its value is saved in the desktop file along
with the state of the buffer for which it was called.  When file names
are returned as part of the auxiliary information, they should be
formatted using the call

@example
(desktop-file-name @var{file-name} @var{desktop-dirname})
@end example

@end defvar

For buffers not visiting a file to be restored, the major mode must
define a function to do the job, and that function must be listed in
the alist @code{desktop-buffer-mode-handlers}.

@defvar desktop-buffer-mode-handlers
Alist with elements

@example
(@var{major-mode} . @var{restore-buffer-function})
@end example

The function @var{restore-buffer-function} will be called with
argument list

@example
(@var{buffer-file-name} @var{buffer-name} @var{desktop-buffer-misc})
@end example

and it should return the restored buffer.
Here @var{desktop-buffer-misc} is the value returned by the function
optionally bound to @code{desktop-save-buffer}.
@end defvar
