@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2017 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.

@documentencoding UTF-8
@documentlanguage ru
@c@documentencoding UTF-8

@c\usepackage{babel}
@c\usepackage[utf8]{inputenc}
@c\usepackage[russian]{babel}

@node Modes
@chapter Основные и Второстепенные режимы
@cindex mode

  Режим (@dfn{mode}) это набор определений который добавляет в Emacs полезные функции.
Различают 2 вида режимов: второстепенные режимы @dfn{minor modes},
которые предоставляют функции которые можно включить и выключить во время редактирования;
и Основные режимы @dfn{major modes}, которые используются для редактирования или взаимодействия
с определенным видом текста. Буфер может иметь равно один Основной @dfn{major
mode} в каждый момент времени (основной режим можно менять).

Данная глава описывает как писать Основные и Второстепенные режимы, как показывать их
в строке режимов, и как режимы выполняют функции перехватчики (hook) предоставленные пользователем.
Связанные темы раскладки и синтаксические таблицы описаны в разделах:
@ref{Keymaps}, и @ref{Syntax Tables}.

@menu
* Hooks::             Как использовать функции перехватчики; как написать код который предоставляет перехватчики.
* Major Modes::       Определение Основных режимов.
* Minor Modes::       Определение Второстепенных режимов.
* Mode Line Format::  Настройка отображения текста для строки режимов.
* Imenu::             Предоставление menu для определений из буфера.
* Font Lock Mode::    Подсветка синтаксиса в режиме.
* Auto-Indentation::  Как научить Emacs выполнять отступы в Основном режиме.
* Desktop Save Mode:: Как режимы могут сохранять состояние буфера между сессиями Emacs.
@end menu

@node Hooks
@section Hooks Перехватчики (Ловушки)
@cindex hooks

  Перехватчик @dfn{hook} это переменная которая может хранить функцию
или функции, которые могут быть вызваны в определенном случае
выполняемой программой. В Emacs перехватчики используются для
настройки. Как правило, перехватчики задаются в init файле
(@pxref{Init File}), но Lisp программы тоже могут задавать
перехватчики.  В @xref{Standard Hooks}, описывается часть стандартных
переменных перехватчиков.

@cindex normal hook
@cindex Обыкновенный перехватчик
  Большинство перехватчиков являются обыкновенными @dfn{normal
hooks}. Это переменные, которые содержат списки функций вызываемых без
аргументов. По соглашению, если имя перехватчика оканчивается на
@samp{-hook}, это означает что перехватчик является обыкновенным. Мы
пытаемся сделать все перехватчики обыкновенными, насколько это
возможно, чтобы их можно было использовать единообразно.

  Команда каждого основного режима (например list-mode), поддерживает
выполнение обыкновенного перехватчика, называемого перехватчик
@dfn{mode hook}, как часть завершающего шага инициализации. Это
позволяет просто настроить режим переназначив уже заданные для буфера
значения локальных переменных.  (первоначально они устанавливаются
при включении режима, после чего в перехватчике они могут быть
переопределены). Большинство вспомогательных режимов так же выполняют
перехватчик режима при включении. Перехватчики могут использоваться и в другом
контексте. Например перехватчик @code{suspend-hook} выполняется перед
тем как Emacs остановит (suspend) свою работу (@pxref{Suspending Emacs}).

  Рекомендуется добавлять функции перехватчики к перехватчику путем
вызова @code{add-hook} (@pxref{Setting Hooks}). Функция перехватчик
может быть любым из допустимых функций для которых поддерживается
вызов @code{funcall} (@pxref{What Is a Function}). Большинство
переменных обычных перехватчиков имеют начальное значение void; и
@code{add-hook} умеет обрабатывать данную ситуацию. Используя
@code{add-hook} можно добавлять перехватчики как глобально, так и
локально для буфера.

@cindex abnormal hook
@cindex Необычный перехватчик
  Если имя переменной перехватчика не оканчивается на @samp{-hook},
это является признаком того, что данная переменная @dfn{abnormal hook}
(необычный перехватчик).  Это означает, что функции перехватчика
вызываются с аргументами, или их возвращаемые значение каким-то
образом используются. Документация перехватчика описывает как функции
вызываются.  Можно использовать @code{add-hook} для добавления функций
к необычному перехватчику, но функция должна быть написана в
соответствии с соглашением по вызову.  Условлено, что имена для
необычных перехватчиков оканчиваются на @samp{-functions}.

@cindex single-function hook
@cindex перехватчик с одной функцией
Если имя переменной заканчивается на @samp{-function} это значит что
значение переменной просто одна функция, а не список
функций. @code{add-hook} не может быть использована для изменения
таких перехватчиков @emph{single function hook}.  Для изменения таких
перехватчиков нужно использовать @code{add-function} (@pxref{Advising Functions}).

@menu
* Running Hooks::    Как выполнить перехватчик.
* Setting Hooks::    Как поместить и удалить функцию в перехватчик.
@end menu

@node Running Hooks
@node Запуск перехватчиков
@subsection Running Hooks

  В данном разделе рассматривается функция @code{run-hooks}, которая используется
для запуска обыкновенных перехватчиков. А так же функции для запуска
различных видов необычных перехватчиков.

@defun run-hooks &rest hookvars
Функция принимает одно или более имя переменной обычного перехватчика,
и запускает все перехватчики по очереди. Каждый аргумент должен быть
символом который является переменной обычного перехватчика. Аргументы обрабатываются
согласно их порядку.

Если переменная перехватчик non-@code{nil} (не @code{nil}) значение переменной
должно быть списком функций. @code{run-hooks} вызывает все функции по очереди без
аргументов.

Значение переменной перехватчика может быть отдельная функция, как
лямбда выражение так и символ с определенной функцией, которые @code{run-hooks}
вызовет. Но такое использование устарело.

Если переменная перехватчик локальная для буфера, будет использовано локальное
для буфера значение. Но, если локальная переменная содержит элемент @code{t}, то будут
вызваны функции и из глобальной переменной.
@end defun

@defun run-hook-with-args hook &rest args
Данная функция запускает необычные перехватчика путем вызова всех функций перехватчика
@var{hook}, с передачей каждому параметров @var{args}.
@end defun

@defun run-hook-with-args-until-failure hook &rest args
Функция запускает необычный перехватчик путем вызова всех функций
перехватчика по очереди, если какая-то из функций вернет @code{nil}
то, выполнение перехватчика прекратится и оставшиеся функции вызваны
не будут. Каждая функция вызывается с аргументами @var{args}.  Если
функция останавливается из-за того, что какая-то из функций
перехватчика не выполнилась, то функция возвращает @code{nil} иначе
не-@code{nil} значение.
@end defun

@defun run-hook-with-args-until-success hook &rest args
Функция запускает необычный перехватчик путем вызова всех функций
перехватчика по очереди, с остановкой если она из них вернет
не-@code{nil} значение.  Каждая функция вызывается с аргументами
@var{args}.  Если функция остановилась потому что одна из функций
вернула не-@code{nil} значение, то это значение и возвращается, иначе
возвращается @code{nil}.
@end defun

@node Setting Hooks
@node Установка перехватчиков
@subsection Setting Hooks

  Ниже приведет пример использования перехватчика для режима для
включения Auto Fill режима при включении Lisp Interaction режима:

@example
(add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)
@end example

@defun add-hook hook function &optional append local
Функция предоставляет удобный способ добавить функцию @var{function} к
перехватчику @var{hook}.  @var{function} может быть любой Lisp
функцией которая может принимать правильное для @var{hook} количество
аргументов.  Например,

@example
(add-hook 'text-mode-hook 'my-text-hook-function)
@end example

@noindent
добавляет @code{my-text-hook-function} к перехватчику с именем
@code{text-mode-hook}.

Если @var{function} уже есть в перехватчике @var{hook} (сравнение
выполняется с использованием функции @code{equal}), тогда
@code{add-hook} не выполняет второе добавление.

Если @var{function} содержит не-@code{nil} свойство
@code{permanent-local-hook}, тогда @code{kill-all-local-variables}
(или смена основного режима) не будет удалять ее из локальных значений
переменной перехватчика.

Для обычного перехватчика, функции перехватчики должно быть написаны
так, чтобы порядок их вызова не имел значения. Зависимость от порядка
может привести к проблемам.  Однако порядок выполнения предсказуем:
обычно @var{function} помещается в начала списка перехватчика, поэтому
она выполняется первой (barring another @code{add-hook} call). Если
необязательный параметр @var{append} не-@code{nil}, новая функция
перехватчик добавляется в конец списка и выполняется после других.

@code{add-hook} обрабатывает случаи когда @var{hook} void или
значение одна функция, она устанавливает или изменяет значение на
список функций.

Если @var{local} не-@code{nil}, тогда @var{function} добавляется к
локальному для буфера списку перехватчика, а не к глобальному. При
этом создается перехватчик локальный для буфера и добавляется @code{t}
к локальному перехватчику, чтобы вызывались и функции из глобального
(см. run-hook).
@end defun

@defun remove-hook hook function &optional local
Функция удаляет @var{function} из переменной перехватчика
@var{hook}.  Функция сравнивает @var{function} с элементами @var{hook}
используя @code{equal}, поэтому это работает для символов и лямбда выражения.

Если @var{local} не-@code{nil}, то @var{function} удаляется из локального для буфера перехватчика,
а не из глобального списка перехватчика.
@end defun

@node Major Modes
@section Major Modes (Основные режимы)
@cindex major mode
@cindex основной режим

@cindex major mode command
@cindex команда основного режима
  Основной режим настраивает Emacs для редактирования и взаимодействия
с определенным видом текста. Каждый буфер имеет ровно один основной
режим в каждый момент времени. Каждый основной режим связан с
@dfn{major mode command} (командой основного режима), чье имя должно
оканчиваться на @samp{-mode}. Такая команда выполняет переключение на
соответствующий режим текущего буфера, путем установки различных
локальных для буфера переменных таких как локальная раскладка(keymap).
@xref{Major Mode Conventions}. Стоит отметить, что в отличие от
вспомогательных режимов основные режимы не возможно ``выключить'',
можно только переключиться на другой основной режим.

  Наименее специализированный основной режим называется
@dfn{Fundamental mode}, который не содержит каких-то определений или
настроек переменных.

@deffn Command fundamental-mode
Это команда переключения в основной режим Fundamental. В отличие от
других команд режимов, она @emph{не} запускает никаких перехватчиков
(@pxref{Major Mode Conventions}), поскольку не предполагается
настройка данного режима.
@end deffn

Проще всего создать основной режим, если воспользоваться макросом
@code{define-derived-mode}, который создаст новый режим как вариант
уже существующего основного режима. @xref{Derived
Modes}. Рекомендуется использовать @code{define-derived-mode} даже в
том случае если новый режим не является очевидной производной другого
режима, так как макрос автоматически обеспечивает выполнения множества
соглашений по кодированию. @xref{Basic Major Modes}, for common modes
to derive from.

Стандартное дерево каталогов GNU Emacs Lisp содержит код для нескольких
основных режимов, в таких файлах как @file{text-mode.el},
@file{texinfo.el}, @file{lisp-mode.el}, и @file{rmail.el}. Вы можете
изучить эти библиотеки, чтобы разобраться как пишутся режимы.

@defopt major-mode
Локальное для буфера значение данной переменной хранит символ текущего
основного режима. Значением по умолчанию является режим по умолчанию
для новых буферов. Обычное значение по умолчанию
@code{fundamental-mode}.

Если значение по умолчанию @code{nil}, тогда при создании нового буфера,
например с таким образом @kbd{C-x b} (@code{switch-to-buffer}), для нового
буфера устанавливается основной режим такой же как у предыдущего выбранного буфера.
За исключением случаев, если символ основного режима предыдущего буфера содержит
свойство @code{mode-class} со значением @code{special}, тогда для нового буфера
основным режимом выставляется Fundamental (@pxref{Major Mode Conventions}).
@end defopt

@menu
* Major Mode Conventions::  Соглашения по кодированию .
* Auto Major Mode::         Как Emacs автоматически выбирает основной режим.
* Mode Help::               Получение справки по использованию режима.
* Derived Modes::           Определение основного режима на основе другого основного режима.
* Basic Major Modes::       Режимы на основе которых наиболее часто строятся другие режимы.
* Mode Hooks::              Перехватчики запускаемые в конце функций режимов.
* Tabulated List Mode::     Родительский режим для буферов с табличными данными..
* Generic Modes::           Определение простого основного режима с поддержкой комментариев
                            и Font Lock режимом (режим выполняющий подсветку некоторых конструкций).
* Example Major Modes::     Текстовые и Lisp режимы.
@end menu

@node Major Mode Conventions
@node Соглашения по основным режимам
@subsection Major Mode Conventions
@cindex major mode conventions
@cindex соглашения по основным режимам
@cindex conventions for writing major modes
@cindex соглашения по написанию основных режимов

  Код каждого основного режима должен следовать ряду соглашений,
включающих соглашения по инициализации локальной раскладки (local
keymap) и синтаксической таблицы (syntax table), именах функций,
переменных, и перехватчиков.

  Если используется @code{define-derived-mode}, он берет на себя заботу о
выполнении многих из соглашений автоматически. @xref{Derived Modes}. Отметим
также, что режим Fundamental является исключением для многих из соглашений,
потому что представляет состояние Emacs по умолчанию.

Далее приводится частичный список соглашений. Каждый основной режим
должен стремиться к согласованности с остальными основными режимами, так
как это делает Emacs в целом более последовательным и понятным. Не возможно
перечислить все возможные моменты где могут возникнуть вопросы согласованности;
в случае если разработчики Emacs укажут где ваш режим отклоняется от соглашений,
пожалуйста сделайте свой режим совместимым.

@itemize @bullet
@item
Определяйте команду основного режима оканчивающейся на @samp{-mode}.
Вызываемая без аргументов команда должна переключать текущий буфер в в
новый режим устанавливая раскладку (keymap), синтаксическую таблицу, и
локальные для буфера переменные. Команда не должна изменять содержимое
буфера.

@item
Напишите комментарий(документацию) для команды, которая описывает команды доступные в
данном режиме. @xref{Mode Help}.

Строка документации может включать особые подстроки, @samp{\[@var{command}]},
@samp{\@{@var{keymap}@}}, и
@samp{\<@var{keymap}>}, которые позволяют справке автоматически определять и показывать
пользовательские настройки привязки клавиш.  @xref{Keys in
Documentation}.

@item
Команда основного режима должна начинаться вызовом
@code{kill-all-local-variables}.  Который запускает обычный перехватчик
@code{change-major-mode-hook}, который уничтожает переменные буфера предыдущего
основного режима.  @xref{Creating Buffer-Local}.

@item
Команда основного режима должна присвоить переменной @code{major-mode}
символ команды основного режима. На основе этого значения @code{describe-mode}
определяет какая документация должна быть показана.

@item
Команда основного режима должна присвоить переменной @code{mode-name}
``удобное''(``pretty'') название режима, обычно являющееся строкой
(см. @ref{Mode Line Data}, с описание других возможных вариантов).
Это имя режима будет отображаться в строке режима.

@item
@cindex functions in modes
@cindex функции в режимах
Поскольку все глобальные имена находятся в одном пространстве имен, все
глобальные переменные, константы, и функции которые относятся к режиму должны
иметь имена, которые начинаются с имени режима (или с его сокращения если имя
длинное). @xref{Coding Conventions}.

@item
В основном режиме предназначенном для редактирования структурированного текста,
например программ, отступы соответствующие структуре вероятно будет полезными.
Поэтому стоит установит для @code{indent-line-function} переменной подходящее
значение, и вероятно настроить другие переменные отвечающие
за расстановку отступов. @xref{Auto-Indentation}.

@item
@cindex keymaps in modes
@cindex привязки клавиш в режимах
Основной режим как правило должен иметь свою собственную раскладку, которая
используется как локальная для всех буферов с данным режимом. Команда
основного режима должная вызывать @code{use-local-map} для установки
локальной раскладки. @xref{Active Keymaps} для получения
более полной информации.

Данная раскладка должна быть перманентно загруженной в глобальной
переменной с именем @code{@var{modename}-mode-map}. Как правило библиотека
определяющая режим устанавливает эту переменную.

@xref{Tips for Defining}, для получения советов по установки
значения переменной отвечающей за раскладку в режиме.

@item
Комбинации клавиш в основном режиме обычно должно начинаться с
@kbd{C-c}, за которым следует контрольный символ или цифра, или @kbd{@{},
@kbd{@}}, @kbd{<}, @kbd{>}, @kbd{:} или и@kbd{;}. Другие символы пунктуации
зарезервированы для второстепенных режимов, и обычные буквы зарезервированы
для пользователей.

Основной режим можно так же переназначить @kbd{M-n}, @kbd{M-p} и
@kbd{M-s}. Привязки @kbd{M-n} и @kbd{M-p} должны быть разновидностями
движения вперед и назад, что однако, не обязательно означает перемещение
курсора.

В основном режиме допускается переопределение стандартных комбинаций
если предоставляемые команды делают схожие действия но более подходят
для текста с которым должен работать режим. Например, основной режим
для редактирования программ может переопределить @kbd{C-M-a} для перехода
в начало функции способом который подходит для редактируемого языка.

Кроме того допускается переопределять редко используемые в данном
режиме клавиши. Например, режим минибуфера переопределяет @kbd{M-r},
чье обычное назначение (прим. @code{move-to-window-line-top-bottom})
редко может быть использовано в минибуфере. Основные режимы такие как
Dired или Rmail которые не выполняют непосредственную работу с текстом
могут вполне обосновано переопределять буквы и другие печатные символы
для выполнения команд.

@item
Основные режимы для редактирования текста не должны определять для @key{RET}
действия отличные от вставки новой строки. Однако, вполне нормально для
специальных режимов в которых не выполняется редактирование текста, таких
как Dired, переопределить @key{RET} для выполнения совершенно
других действий.

@item
Основной режим не должен изменять параметр, которые должен определить
пользователь в соответствии со своими предпочтениями, такие как
использование Auto-Fill режима. Оставьте это на усмотрение пользователя.
Однако, основной режим должен настроить другие переменные таким образом,
чтобы режим Auto-Fill был полезен в случае @emph{если} (@emph{if}) пользователь
решит его использовать.

@item
@cindex syntax tables in modes
@cindex синтаксические таблицы в режимах
Режим может использовать свою собственную синтаксическую таблицу или
использовать общую вместе с другими связанными режимами. Если режим
имеет собственную таблицу, то она должна хранится в переменной
@code{@var{modename}-mode-syntax-table}.  @xref{Syntax Tables}.

@item
В режимах для языков которые содержат комментарии, нужно установить
переменные которые определяют синтаксис комментариев. @xref{Options for
Comments,, Options Controlling Comments, emacs, The GNU Emacs Manual}.

@item
@cindex abbrev tables in modes
@cindex Таблицы сокращений в режимах
Режим может содержать свою таблицу сокращений или использовать общую с
другими связанными режимами. Если режим имеет собственную таблицу, то
она должна хранится в переменной  @code{@var{modename}-mode-abbrev-table}.
Если команда основного режима определяет какие-то сокращения должен быть
установлен в @code{t} аргумент флаг @var{system-flag} функции
@code{define-abbrev} используемой для определения сокращений.
@xref{Defining Abbrevs}.

@item
Режим должен определять как подсвечивать режим Font Lock, путем
установки локальной для буфера переменной @code{font-lock-defaults}
(@pxref{Font Lock Mode}).

@item
Каждый начертание шрифта(face, дальше просто начертание) который
определят режим, должен наследоваться, если это возможно, от
существующего в Emacs начертания.
@xref{Basic Faces}, и @ref{Faces for Font Lock}.

@item
Режим должен определить как Imenu будет находить определение разделов
буфера, путем установки локальной (для буфера) переменных
@code{imenu-generic-expression}, и
@code{imenu-prev-index-position-function} и
@code{imenu-extract-index-name-function} или переменной
@code{imenu-create-index-function} (@pxref{Imenu}).

@item
Режим может задать локальное значение для @code{eldoc-documentation-function},
чтобы определить как режим ElDoc будет обрабатывать данный режим.

@item
Режим может определить как завершать разные ключевые слова добавив один или
более локальных перехватчиков в специальный перехватчик
@code{completion-at-point-functions}.  @xref{Completion in Buffers}.

@item
@cindex buffer-local variables in modes
@cindex локальные (для буфера) переменные в режимах
Что бы сделать переменную локальной для буфера, следует использовать
@code{make-local-variable} в основной функции режима, а не
@code{make-variable-buffer-local}. @code{make-variable-buffer-local}
делает переменную локальной для всех буферов в которых она устанавливается,
что будет влиять и на буферы в других режимах. Такой глобальный эффект
является не желательным для режима. @xref{Buffer-Local Variables}.

За редким исключением, единственный оправданный способ использования
@code{make-variable-buffer-local} в Lisp пакете для переменных, которые
используются только в этом пакете. Использование этой функции на переменных
используемых другими пакетами может приводить к конфликтам.

@item
@cindex mode hook
@cindex major mode hook
@cindex перехватчик режима
@cindex основной перехватчик режима
Каждый основной режим должен иметь нормальный  @dfn{mode hook} с именем
@code{@var{modename}-mode-hook}. В конце команда режима должна вызывать
команда @code{run-mode-hooks}. Которая вызывает обыкновенный перехватчик
@code{change-major-mode-after-body-hook}, перехватчик режима, после которого
нормальный перехватчик @code{after-change-major-mode-hook}.
@xref{Mode Hooks}.

@item
Команда основного режима может может начинаться с вызова нескольких
команд других основных режимов (называемых @dfn{parent mode} родительские)
после чего изменить некоторые из их настроек. Выполняющий это ражим
называется @dfn{derived mode} (дочерний). Рекомендуется, но не требуется
делать дочерние режимы путем использования макроса
@code{define-derived-mode}. Такой режим должен вызывать команду родительского
режима внутри формы @code{delay-mode-hooks}. (При использовании
@code{define-derived-mode} это делается автоматически.) @xref{Derived
Modes}, and @ref{Mode Hooks}

@item
В случае необходимости выполнения каких-то специфичных действий при
переключении на другой режим, данный режим должен установить локальную
(для буфера) переменную @code{change-major-mode-hook}
(@pxref{Creating Buffer-Local}).

@item
Если режим предназначен для работы только со специальным текстом созданным
самим режимом (не как обычно набранного пользователем или внешнего файла),
тогда для символа команды основного режима должно быть задано свойство
@code{mode-class} со значением @code{special}.
Код для задания:

@kindex mode-class @r{(property)}
@cindex @code{special} modes
@example
(put 'funny-mode 'mode-class 'special)
@end example

@noindent
Таким образом указав Emacs, что новые буферы созданные из буфера в режиме
Funny mode не нужно запускать в режиме Funny mode, даже если значение
по умолчанию свойства @code{major-mode}  @code{nil}. Значение
@code{nil} для свойства @code{major-mode} предполагает использование
основного режима текущего буфера при создании новых буферов
(@pxref{Auto Major Mode}), но для специальных
@code{special} режимов вместо этого используется Fundamental mode.
Режимы такие как Dired, Rmail, и Buffer List используют данную особенность.

Функция @code{view-buffer} не включает дополнительный режим View для
буферов у которых mode-class задан как special, потому что такие режимы
обычно предоставляют свои привязки для просмотра (см. View mode).

Макрос @code{define-derived-mode} автоматически помечает дочерний режим
как специальный если родительский режим специальный.
@xref{Basic Major Modes}.

@item
С помощью добавления элемента в @code{auto-mode-alist}
можно задать определения имен файлов для которых режим будет
использоваться по умолчанию (@pxref{Auto Major Mode}). Если
режим загружается через autoload, нужно поместить добавление
элемента в @code{auto-mode-alist}, в тот же файл где вызывается @code{autoload}.
Если используются autoload cookie для команды режима, так же нужно использовать
autoload cookie для формы добавления элемента (@pxref{autoload cookie}).
Если autoload не используется, добавление в @code{auto-mode-alist} можно
выполнить в файле с определением режима.

@item
@cindex mode loading
@cindex Загрузка режима
Форма первого уровня (top-level) файла в котором определяется режим,
должна позволять многократное выполнение без негативных последствий.
Например, стоит использовать @code{defvar} или @code{defcustom} для установки
переменных режима, таким образом значения переменных не будут переопределены
если они уже имеют значения (@pxref{Defining Variables}).

@end itemize

@node Auto Major Mode
@node Автоматический выбор основного режима
@subsection How Emacs Chooses a Major Mode
@subsection Как Emacs выбирает основной режим
@cindex major mode, automatic selection
@cindex основной режим, автоматический выбор

Когда Emacs открывает файл, оно автоматически выбирает основной режим
основываясь на информации об имени файла или информации в самом файле.
Также обрабатываются локальные переменные определенные в тексте файла.

@deffn Command normal-mode &optional find-file
Функция устанавливает подходящий основной режим и значение локальных переменных
для текущего буфера. В этой функции сначала вызывается @code{set-auto-mode}
(см. ниже), затем запускается функция @code{hack-local-variables}, которая
разбирает и затем связывает или вычисляет локальные переменные файла
(@pxref{File Local Variables}).

Если значение параметра @var{find-file} функии @code{normal-mode} не @code{nil},
тогда @code{normal-mode} считает, что она была вызвана из @code{find-file} и в этом
случае выполняется обработка локальных переменных в @samp{-*-} и в конце файла.
Переменная @code{enable-local-variables} включает или выключает данный
функционал. @xref{File
Variables, , Local Variables in Files, emacs, The GNU Emacs Manual}, для получения
информации по синтаксису секции описания локальных переменных.

В случае интерактивного запуска @code{normal-mode}, аргумент @var{find-file}
по умолчанию @code{nil}. В этом случае @code{normal-mode} безусловно
обрабатывает все локальные переменные файла.

Функция вызывает @code{set-auto-mode} для выбора основного режима.
Если режим не был определен, основной режим остается равным значению
основного режима по умолчанию @code{major-mode} см. ниже.

@cindex file mode specification error
@cindex Ошибка определения основного режима
@code{normal-mode} вызывает команду режима внутри @code{condition-case}, поэтому
ошибки ловятся и о них сообщается как @samp{File
mode specification error} следующей за полученным сообщением об ошибке.
@end deffn

@defun set-auto-mode &optional keep-mode-if-same
@cindex visited file mode
@cindex режим для посещенного файла
 Функция выбирает основной режим который подходит для текущего буфера.
Выбор основывается на (в порядке предшествования) строке @w{@samp{-*-}},
на любой @samp{mode:} (используется @code{interpreter-mode-alist}) в
районе завершения файла, @w{@samp{#!}}
(используется @code{magic-mode-alist}) в тексте в начале файла, и
в заключение имени файла (используется auto-mode-alist). @xref{Choosing Modes, ,
How Major Modes are Chosen, emacs, The GNU Emacs Manual}. Если @code{enable-local-variables}
равно @code{nil}, @code{set-auto-mode} не проверяет @w{@samp{-*-}} или окончание файла, для
любого тега режима. (TODO: тут перевод не очень получился)

@vindex inhibit-local-variables-regexps
Для некоторых типов файлов не выполняется сканирование содержимого
для определения режима. Например, tar архив может содержать файл,
который имеет секцию с локальными переменными в конце, определяющими
режим для этого файла. Но они не будут применены ко всему tar файлу.
Аналогично, tiff файл изображения может иметь первую строку соответствующую
шаблону @w{@samp{-*-}}. По этой причини, файлы с таким расширением находятся
в списке @code{inhibit-local-variables-regexps}. Добавление шаблона в этот
список предотвращает поиск Emacs-ом поиск локальных переменных (не только
определяющих режима) в файлах соответствующих шаблону.

Если переменная @var{keep-mode-if-same} не @code{nil}, функция не
вызывает команду режима если буфер уже имеет подходящий основной режим.
Например @code{set-visited-file-name}, выставляет данную переменную в
@code{t}, чтобы предотвратить уничтожение локальных переменных, которые
пользователь мог установить
@end defun

@defun set-buffer-major-mode buffer
Функция устанавливает основной режим @var{buffer} в значение по умолчанию
определяемое @code{major-mode}; если оно @code{nil}, используется
основной режим текущего режима (если он подходит). Если имя буфера
@file{*scratch*}, то для него устанавливается режим определяемый значением
@code{initial-major-mode}.

Низкоуровневые простые функции для создания буфера не используют
это функцию, но команды среднего уровня такие как @code{switch-to-buffer} и
@code{find-file-noselect} используют ее как только они создадут
буфер.
@end defun

@defopt initial-major-mode
@cindex @file{*scratch*}
Значение этой переменной определяет основной режим буфера @file{*scratch*}.
Значение должно быть символом который является командой основного
режима. Значение по умолчанию @code{lisp-interaction-mode}.
@end defopt

@defvar interpreter-mode-alist
Переменная определяет основной режим, который будет использоваться для
скриптов для которых задан командный интерпретатор в @samp{#!} строке.
Переменная представляет собой ассоциативный список (alist) с элементами
в форме @code{(@var{regexp} . @var{mode})}, что указывает использовать
режим @var{mode} если в файле указано использование интерпретатора,
удовлетворяющее регулярному выражению @code{\\`@var{regexp}\\'}. Например
по умолчанию есть такое соответствие: @code{("python[0-9.]*" . python-mode)}.
@end defvar

@defvar magic-mode-alist
Значением переменной является ассоциативный список (alist) в форме:
@code{(@var{regexp} .  @var{function})}.
@var{regexp} - регулярное выражение,
@var{function} - функция или @code{nil}.
При посещении файла (открытии) @code{set-auto-mode} вызывает @var{function}
если текст в начале буфера удовлетворяет @var{regexp} и функция
@var{function} не-@code{nil}, если @var{function} @code{nil}, то
режим определяется на основе значения переменной @code{auto-mode-alist}.
@end defvar

@defvar magic-fallback-mode-alist
Данная переменная работает так же как @code{magic-mode-alist}, за исключением
того что она используется только если @code{auto-mode-alist} не определило
режим для данного файла.
@end defvar

@defvar auto-mode-alist
Переменная содержит ассоциативный список @code{(@var{regexp} .  @var{mode-function})},
@code{(@var{regexp} - регулярное выражение,
    которому должно удовлетворять имя файла.
@var{mode-function})} - функция режима которая будет выполнена если
имя соответствует регулярному выражению.
Как правило @code{(@var{regexp}} проверяет расширение имени файла,
например @samp{.el} или @samp{.c}, но не обязательно.

Например,

@smallexample
@group
(("\\`/tmp/fol/" . text-mode)
 ("\\.texinfo\\'" . texinfo-mode)
 ("\\.texi\\'" . texinfo-mode)
@end group
@group
 ("\\.el\\'" . emacs-lisp-mode)
 ("\\.c\\'" . c-mode)
 ("\\.h\\'" . c-mode)
 @dots{})
@end group
@end smallexample

Когда открывается файла чье полное имя (@pxref{File Name
Expansion}) с удаленными номерами версии и расширениями резервных копий
@code{file-name-sans-versions} (@pxref{File Name Components}), соответствует
регулярному выражению @var{regexp}, @code{set-auto-mode} вызывает
соответствующую @var{mode-function}. Данная способность позволяет Emacs
выбирать подходящий режим для большинства файлов.

Если элемент списка @code{auto-mode-alist} имеет форму @code{(@var{regexp}
@var{function} t)}, тогда после вызова функции @var{function}, Emacs
выполняет поиск в @code{auto-mode-alist} снова, для получения соответствия
для части имени файла которая не могла совпасть ранее.
Данная возможность полезна например для пакетов архивов, запись @code{("\\.gz\\'"
@var{function} t)} позволяет распаковать файл и открыть распакованный файл
в режиме соответствующем части перед @samp{.gz}.

Пример создания правил задания режимов @code{auto-mode-alist}:
(Такие выражения можно использовать в init файле)

@smallexample
@group
(setq auto-mode-alist
  (append
   ;; @r{File name (within directory) starts with a dot.}
   '(("/\\.[^/]*\\'" . fundamental-mode)
     ;; @r{File name has no dot.}
     ("/[^\\./]*\\'" . fundamental-mode)
     ;; @r{File name ends in @samp{.C}.}
     ("\\.C\\'" . c++-mode))
   auto-mode-alist))
@end group
@end smallexample
@end defvar

@node Mode Help
@node Справка по режиму
@subsection Getting Help about a Major Mode
@cindex mode help
@cindex help for major mode
@cindex documentation for major mode
@cindex справка по режиму
@cindex помощь по основному режиму
@cindex документация по основному режиму

Функция @code{describe-mode} предоставляет информацию по
основному режиму. Как правило она вызывается комбинацией @kbd{C-h m}.
Функция использует значение переменной @code{major-mode} (@pxref{Major Modes}).
Поэтому каждая команда основного режима должна устанавливать эту переменную.

@deffn Command describe-mode &optional buffer
Команда отображает документацию по основному и вспомогательным режимам
текущего буфера. Команда использует функцию @code{documentation} для
нахождения строк документации команд основного и вспомогательных режимов
@pxref{Accessing Documentation}).

Если вызывается из Lisp cо значением аргумента @var{buffer} не-@code{nil},
функция отображает документацию для основного и вспомогательного режимов
указанного буфера, а не текущего буфера.
@end deffn

@node Derived Modes
@node Дочерние режимы
@subsection Defining Derived Modes
@cindex derived mode
@cindex дочерние режимы

  Рекомендуемым способом определения основного режима является создание
дочернего режима для одного из уже существующих с использованием
@code{define-derived-mode}. В случае если нет подходящего режима, стоит
наследоваться от @code{text-mode}, @code{special-mode}, или @code{prog-mode}.
@xref{Basic Major Modes}. Если и не один из этих режимов не подходит
стоит наследоваться от @code{fundamental-mode} (@pxref{Major Modes}).

@defmac define-derived-mode variant parent name docstring keyword-args@dots{} body@dots{}
Макрос определяет @var{variant} как команду основного режима,
используя @var{name} в качестве имени режима. @var{variant} и @var{parent} должны
быть символами без кавычки (без цитирования).

Новая команда @var{variant} определяется как вызов функции родителя
@var{parent} с последующем переопределением некоторых частей
родительского режима:

@itemize @bullet
@item
Новый режим имеет пустую раскладку, которая называется
@code{@var{variant}-map}. @code{define-derived-mode} задает
раскладку родительского режима, родителем новой раскладки, если
только @code{@var{variant}-map} еще не задан и уже имеет родителя.

@item
Новый режим содержит свою собственную синтаксическую таблицу,
хранящуюся в переменной @code{@var{variant}-syntax-table}, если
только она не переопределяется явно с использованием ключевого
слова @code{:syntax-table} (см. ниже). Команда @code{define-derived-mode}
устанавливает родителя синтаксической таблицы равным синтаксической
таблице родительского режима, если только @code{@var{variant}-syntax-table}
еще не установлена и не содержит родителя отличающегося от стандартного.

@item
Новый режим содержит свою таблицу аббревиатур(abbrev table), хранящуюся
в @code{@var{variant}-abbrev-table}, если ее не переопределили с использованием
ключевого слова @code{:abbrev-table} (см. ниже).

@item
Новый режим содержит свой перехватчик (mode hook), @code{@var{variant}-hook}.
Режим запускает этот перехватчик после перехватчиков предков, используя
@code{run-mode-hooks}, в конце выполнения команды режима. @xref{Mode Hooks}.
@end itemize

Кроме того можно переопределить другие части родителей @var{parent}
используя @var{body}. Команда @var{variant} выполняет формы (выражения)
@var{body} после установки всех обычных переопределений, непосредственно
перед вызовом перехватчиков (hooks).

Если @var{parent} содержит non-@code{nil} @code{mode-class} свойство
символа, тогда @code{define-derived-mode} устанавливает @code{mode-class}
свойство @var{variant} в это же значение. Это позволяет обеспечить, например то,
что если @var{parent} специальный режим, то и @var{variant} будет специальным
режимом (@pxref{Major Mode Conventions}).

Можно также задать значение @var{parent} равным @code{nil}. Что приведет
к создания нового режима без родителя. Тогда @code{define-derived-mode}
все равно будет действовать как описано выше, при этом пропуская действия
связанные с родителем (@var{parent}).

Аргумент @var{docstring} определяет строку документации для нового режима.
@code{define-derived-mode} добавляет общую информацию о перехватчиках и раскладках
режима, в конец данной строки документации. Если пропустить @var{docstring},
@code{define-derived-mode} сгенерирует строку документации.

@var{keyword-args} это пары ключ значение. Значения вычисляются.
Поддерживаются следующие ключевые слова:

@table @code
@item :syntax-table
Аргумент позволяет явно задать синтаксическую таблицу для нового режима.
Если значение @code{nil}, новый режим будет использовать ту же таблицу
синтаксиса что и @var{parent} или стандартную таблицу синтаксиса если
@var{parent} тоже @code{nil}. (Заметьте что это @emph{не} соответствует
соглашению для не ключевых слов, для которых значение @code{nil} равносильно
отсутствию аргумента).

@item :abbrev-table
Аргумент позволяет явно задать таблицу аббревиатур для нового режима.
Если задать значение @code{nil}, новый режим будет использовать
туже таблицу что и режим родитель(@var{parent}) или
@code{fundamental-mode-abbrev-table}
если @var{parent} тоже @code{nil}. (Снова значение @code{nil} @emph{не}
соответствует отсутствию аргумента).

@item :group
Если значение задано, то оно должно быть группой настройки(customization group).
Не у всех режимов такая группа есть. Команда @code{customize-mode} использует
данную переменную. @code{define-derived-mode} @emph{не} задает
по умолчанию данную переменную.
@end table

Предположительный пример:

@example
(defvar hypertext-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [down-mouse-3] 'do-hyper-link)
    map))

(define-derived-mode hypertext-mode
  text-mode "Hypertext"
  "Major mode for hypertext."
  (setq-local case-fold-search nil))
@end example

Не стоит писать @code{interactive} в определении, @code{define-derived-mode}
добавит его автоматически.
@end defmac

@defun derived-mode-p &rest modes
Функция возвращает не-@code{nil} если текущий основной режим
является дочерним к режиму заданному символами @var{modes}.
@end defun

@node Basic Major Modes
@node Базовые основные режимы
@subsection Basic Major Modes

Кроме Fundamental, есть три основных режима которые другие основные
режимы используют как родительские: Text, Prog и Special режимы.
В отличие от Text режима, который сам является режимом для файлов
с расширением @file{.txt}, Prog и Special предназначены главным
образом для того, чтобы другие режимы могли наследоваться от них.

@vindex prog-mode-hook
  Там где это возможно, новые основные режимы должны быть дочерними напрямую
или нет для этих трех режимов. Одной из причин для этого является возможность
настройки пользователем одного и того же перехватчика режима,
  As far as possible, new major modes should be derived, either directly
or indirectly, from one of these three modes.  One reason is that this
allows users to customize a single mode hook (например, @code{prog-mode-hook})
для всего семейства соответствующего режиму (например, для всех режимов работы с языками программирования).

@deffn Command text-mode
Режим Text, является основным режимом для редактирования текстов естественных языков
(human languages). Он определяет символы @samp{"} и @samp{\} как символы
пунктуации (@pxref{Syntax Class Table}) и задана привязка @kbd{M-@key{TAB}} для
@code{ispell-complete-word} автодополнения (@pxref{Spelling,,, emacs, The GNU Emacs
Manual})

HTML режим является примером режима дочернего к Text.
@xref{HTML Mode,,SGML and HTML Modes, emacs, The GNU Emacs Manual}.
@end deffn

@deffn Command prog-mode
Режим Prog является базовым для режимов редактирования исходных кодов
на различных языках программирования. Большинство режимов Emacs являются
наследниками данного режима.

Режим Prog делает устанавливает @code{parse-sexp-ignore-comments} в @code{t}
(@pxref{Motion via Parsing})
и @code{bidi-paragraph-direction} в @code{left-to-right}
(@pxref{Bidirectional Display}).
@end deffn

@deffn Command special-mode
Режим Special является основным режимом для буферов текст в которым
специальным образом генерируется самим Emacs-ом, а не берется из файла
(например dired)
Основные являющиеся дочерними к Special имеют свойство @code{mode-class}
равное @code{special} (@pxref{Major Mode Conventions}).

Режим Special устанавливает буфер в режим только чтение (read-only).
Таблица привязки клавиш (keymap) определяет несколько общих привязок,
таких как @kbd{q} - @code{quit-window} и @kbd{g} - @code{revert-buffer}.
(@pxref{Reverting}).


Например Buffer Menu является основном режимом дочерним к Special.
Данный режим используется буфером @file{*Buffer List*}. @xref{List
Buffers,,Listing Existing Buffers, emacs, The GNU Emacs Manual}.
@end deffn

  Режимы с табличными данными могут наследоваться от режима Tabulated List,
который в свою очередь является дочерним для Special режима.
@xref{Tabulated List Mode}.

@node Mode Hooks
@node Перехватчики режима
@subsection Mode Hooks

Каждая команда основного режима должна заканчиваться запуском не зависимым от
режима обычным перехватчиком @code{change-major-mode-after-body-hook}, вызовом
перехватчиком режима и вызовом обычного перехватчика @code{after-change-major-mode-hook}.
Что выполняется через вызов @code{run-mode-hooks}. Если основной режим
является дочерним, тогда команда вызывает родительский основной режим в
теле команды режима, вызов делается через @code{delay-mode-hooks}, чтобы родитель
не вызвал свои перехватчики самостоятельно. При это в дочернем режиме при
вызове @code{run-mode-hooks} выполняются перехватчики родительских режимов тоже.
Таким образом выполняются сначала все body режимом, потом перехватчики режимов.
@xref{Major Mode Conventions}.

  Emacs версий до 22, не имел @code{delay-mode-hooks}.
Версии до 24 не имеют @code{change-major-mode-after-body-hook}.
Когда пользовательские основные режимы не используют @code{run-mode-hooks} и
не были обновлены для использования этих новых возможностей, они не полностью
соответствуют текущим соглашениям, они могут запустить родительский перехватчик
слишком рано или не запустить @code{after-change-major-mode-hook}. В случае
использования или встречи с таким режимом рекомендуется исправить его.

При определении основного режима с использованием @code{define-derived-mode},
указанные соглашения соблюдаются автоматически. Если же режим определяется
в ручном режима (``by hand``), без использования @code{define-derived-mode},
стоит использовать следующие функции для автоматического выполнения соглашений.

@defun run-mode-hooks &rest hookvars
Основной режим должен выполнять свои перехватчики используя эту функцию.
Функция схожа с @code{run-hooks} (@pxref{Hooks}), но она так же запускает
@code{change-major-mode-after-body-hook} и
@code{after-change-major-mode-hook}.

Когда функция вызывается в рамкам выполнения формы @code{delay-mode-hooks},
она не выполняет перехватчики сразу. Напротив, она делает так чтобы они были вызваны
при следующем вызове @code{run-mode-hooks}.
@end defun

@defmac delay-mode-hooks body@dots{}
Когда один основной режим вызывает другой, такой вызов должен выполняться
внутри @code{delay-mode-hooks}.

Такой макрос выполняет тело @var{body}, но не выполняет вызовы перехватчиков
внутри @code{run-mode-hooks}. Такие перехватчики будут выполнены
при следующем выполнении @code{run-mode-hooks}, после завершения действия
конструкции @code{delay-mode-hooks}.
@end defmac

@defvar change-major-mode-after-body-hook
Это обычный перехватчик запускаемый @code{run-mode-hooks}. Он выполняется до
перехватчика режима.
@end defvar

@defvar after-change-major-mode-hook
Обыкновенный перехватчик запускаемый @code{run-mode-hooks}. Перехватчик
запускается в конце функции режима, если она правильно написана.
@end defvar

@node Tabulated List Mode
@node Режим табличных списков
@subsection Tabulated List mode
@cindex Tabulated List mode
@cindex режим табулированного списка

  Режим табличных списков (Tabulated List) основной режим для
отображения табличных данных, т.е. данных состоящих из @dfn{entries}
(@dfn{записей}), каждая запись это одна строка текста разделенная на
колонки. Табличный режим предоставляет возможности для красивой печати
строк и колонок, сортировки строк в соответствии со значениями в
колонках. Данный режим является дочерним для Special режима
(@pxref{Basic Major Modes}.

Табличный режим предназначен для использования как родительский для
множества специальных основных режимов. Например режимы Меню Процессов
(Process Menu), (@pxref{Process Information}) и Меню Пакетов (Package
Menu) (@pxref{Package Menu,,, emacs, The GNU Emacs Manual}).

@findex tabulated-list-mode
  Дочерний режим должен использовать @code{define-derived-mode} как
обычно, задав @code{tabulated-list-mode} вторым аргументом
(@pxref{Derived Modes}).  Тело @code{define-derived-mode} должно
определять формат табличных данных, путем задания значения переменных
описанных ниже, функция @code{tabulated-list-init-header} может быть
вызвана для заполнения заголовка именами колонок.

Дочерний режим должен определить @dfn{listing command}. Это не команда
режима, а команда вызываемая аналогично (e.g., @kbd{M-x
list-processes}).
Команда должна создавать или переключать буфер, включать дочерний режим,
определять табличные данные и в заключение вызывать @code{tabulated-list-print}
для заполнения буфера.

@defvar tabulated-list-format
Данная локальная для буфера (buffer-local) переменная определяет формат
данных табличного списка. Значение должно быть вектором. Каждый элемент
вектора представляет колонку данных, и должен быть списком
@code{(@var{name} @var{width} @var{sort})}, где

@itemize
@item
@var{name} имя колонки (строка).

@item
@var{width} ширина колонки (число). Данный параметр не используется для
крайней колонки которая занимает все оставшееся место.

@item
@var{sort} задает правило сортировки записей по колонкам. Если
@code{nil}, колонка не будет использоваться для сортировки. Если
@code{t}, колонка сортируется как строковая. В другом случае,
нужно задать функцию предикат @code{sort} (@pxref{Rearrangement}),
которая принимает 2 аргумента того же вида что и элементы
@code{tabulated-list-entries} (см. ниже).
@end itemize
@end defvar

@defvar tabulated-list-entries
Данная локальная для буфера (buffer-local) переменная записи отображаемые
в Табличном режиме. Значение должно быть списком или функцией.

Если значение список, каждый элемент соответствует одной записи,
и должен иметь форму @w{@code{(@var{id} @var{contents})}}, где

@itemize
@item
@var{id} либо @code{nil}, либо Lisp объект идентифицирующий запись.
В случае объекта, курсор будет оставаться на той же записи при
пересортировке. Сравнение выполняется с использованием @code{equal}.

@item
@var{contents} это вектор с тем же количеством элементов, что и
@code{tabulated-list-format}. Каждый элемент вектора либо строка,
которая вставляется в буфер как есть, либо список @code{(@var{label}.
@var{properties})}, который предполагает вставку текстовой кнопки
вызовом @code{insert-text-button} с @var{label} и @var{properties}
в качестве аргументов (@pxref{Making Buttons}).

Переводов строк не в одной из строк быть не должно.
@end itemize

Если значение функция, то она должна возвращать список описанной выше
формы при вызове без аргументов.
@end defvar

@defvar tabulated-list-revert-hook
Обыкновенный перехватчик выполняемые как правило для перезагрузки
буфера с табличным списком. Дочерний режим может добавить функцию
в этот перехватчик для пересчета
@code{tabulated-list-entries}.
@end defvar

@defvar tabulated-list-printer
Значение данное переменной должно быть функцией вызываемой для вставки
записи в точке, включая символ перевода строки. Функция должна
принимать два аргумента @var{id} и @var{contents} (id и содержимое),
такие же как для @code{tabulated-list-entries}. Значение по умолчанию
функция вставляющая запись как есть, режимы использующие табличный
список более сложным образом могут задавать другую функцию.
@end defvar

@defvar tabulated-list-sort-key
Значение этой переменной определяет значение текущего ключа для сортировки
в буфере. Если значение @code{nil}, сортировка не выполняется.
Значение должно быть в форме @code{(@var{name} . @var{flip})}, где
@var{name} строка соответствующая имени одной из колонок в
@code{tabulated-list-format}, и @var{flip} если не-@code{nil},
задает сортировку в обратном порядке.
@end defvar

@defun tabulated-list-init-header
Функция вычисляет и устанавливает @code{header-line-format} для
буфера с табличным списком (@pxref{Header Lines}), и присваивает
обработчики кнопок для строки заголовков, чтобы было возможном
сортировать записи по клику на заголовке колонки.

Режимы дочерние к режиму Табличных списков, должны вызывать
данную функцию после установки вышеописанных переменных,
(в особенности после установки @code{tabulated-list-format}).
@end defun

@defun tabulated-list-print &optional remember-pos update
Функция заполняет текущий буфер записями. Она должна вызываться
командой листинга (listing-command). Функция очищает буфер, сортирует
записи заданные @code{tabulated-list-entries} в соответствии с
@code{tabulated-list-sort-key}, а затем вызывает функцию определенную
@code{tabulated-list-printer} для вставки каждой записи.

Если необязательный аргумент @var{remember-pos} не-@code{nil}, функция
смотрит на @var{id} текущей записи, и пытается спозиционироваться
на ту же запись после того как все записи будут (пере)вставлены ((re)inserted).

Если необязательный аргумент @var{update} не-@code{nil}, функция
будет удалять и вставлять только записи, которые изменились со
времени предыдущей печати. Такое поведение может быть в несколько
раз быстрее если большинство записей не изменились с предыдущего вызова
функции. Единственная разница в результатах, заключается в том, что
теги выставленные через @code{tabulated-list-put-tag}, не будут удалены
для записей которые не изменились (обычно все теги удаляются).
@end defun

@node Generic Modes
@node Общие режимы
@subsection Generic Modes
@cindex generic mode
@cindex Общие режимы

  @dfn{Generic modes} Общие режимы это простые основные режимы с базовой
поддержкой синтаксиса комментариев и подсветкой синтаксиса (Font Lock mode).
См. @file{generic-x.el} чтобы изучить примеры использования @code{define-generic-mode}.

@defmac define-generic-mode mode comment-list keyword-list font-lock-list auto-mode-list function-list &optional docstring
Макрос определяет команду общего режима с именем @var{mode}
(символ без кавычки (not quoted)).
Не обязательный аргумент @var{docstring} документация для команды режима.
Если опущено, то @code{define-generic-mode} сгенерирует значение по умолчанию.

Аргумент @var{comment-list} список в котором каждый элемент это
символ, строка из одного или двух символов, или cons ячейка.
Символ или строка установлены в таблице синтаксиса режима как
начало комментария. Если запись является cons ячейкой, то @sc{car}
является началом комментария, а @sc{cdr} завершением комментария.
(Стоит использовать @code{nil} в качестве @sc{cdr} если нужно чтобы комментарии
заканчивались в конце строки.)
Стоит учитывать, что синтаксическая таблица
имеет накладывает ограничения на то что может быть началом
и концом комментария.

@xref{Syntax Tables}.

Аргумент @var{keyword-list} это список ключевых слов которые должны
выделяться шрифтом @code{font-lock-keyword-face}. Каждое ключевое
слово должно быть строкой.  Кроме того, @var{font-lock-list}
это список дополнительных выражений для выделения. Каждый элемент
этого списка должен иметь ту же форму что и элементы @code{font-lock-keywords}.
@xref{Search-based Fontification}.

Аргумент @var{auto-mode-list} это список регулярных выражений для добавления
в переменную @code{auto-mode-alist}. Они добавляются при выполнении
формы @code{define-generic-mode}, а не при раскрытии макроса.

Переменная @var{function-list} является списком функций которые
выполняются при выполнении команды режима для задания дополнительных
настроек. Данные функции выполняет непосредственно перед вызовом
перехватчиков из переменной @code{@var{mode}-hook}.
@end defmac

@node Example Major Modes
@node Пример основных режимов
@subsection Major Mode Examples

  Текстовый (Text) режим вероятно самый простой режим после Fundamental
режима. Приведем отрывок из @file{text-mode.el} иллюстрирующий многие
из вышеописанных соглашений.

@smallexample
@group
;; @r{Create the syntax table for this mode.}
(defvar text-mode-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?\" ".   " st)
    (modify-syntax-entry ?\\ ".   " st)
    ;; Add 'p' so M-c on 'hello' leads to 'Hello', not 'hello'.
    (modify-syntax-entry ?' "w p" st)
    st)
  "Syntax table used while in `text-mode'.")
@end group

;; @r{Create the keymap for this mode.}
@group
(defvar text-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\t" 'ispell-complete-word)
    map)
  "Keymap for `text-mode'.
Many other modes, such as `mail-mode', `outline-mode' and
`indented-text-mode', inherit all the commands defined in this map.")
@end group
@end smallexample

  Далее выполняется определение команды режима:

@smallexample
@group
(define-derived-mode text-mode nil "Text"
  "Major mode for editing text written for humans to read.
In this mode, paragraphs are delimited only by blank or white lines.
You can thus get the full benefit of adaptive filling
 (see the variable `adaptive-fill-mode').
\\@{text-mode-map@}
Turning on Text mode runs the normal hook `text-mode-hook'."
@end group
@group
  (set (make-local-variable 'text-mode-variant) t)
  (set (make-local-variable 'require-final-newline)
       mode-require-final-newline)
  (set (make-local-variable 'indent-line-function) 'indent-relative))
@end group
@end smallexample

@noindent
(Крайняя строка в настоящее время избыточна, так как @code{indent-relative}
это значение по умолчанию, и стоит удалить ее в будущих версиях.)

@cindex @file{lisp-mode.el}
  Следующие 3 Lisp режима (Lisp режим, Emacs Lisp режим и Lisp Interaction режим)
имеют больше особенностей чем Text режим и код данных режимов
более сложный. Далее приводится выдержка из @file{lisp-mode.el}, которая
иллюстрирует как данные режимы написаны.

  Так определяются таблица синтаксиса и аббревиатур:

@cindex syntax table example
@cindex пример синтаксической таблицы
@smallexample
@group
;; @r{Create mode-specific table variables.}
(defvar lisp-mode-abbrev-table nil)
(define-abbrev-table 'lisp-mode-abbrev-table ())

(defvar lisp-mode-syntax-table
  (let ((table (copy-syntax-table emacs-lisp-mode-syntax-table)))
    (modify-syntax-entry ?\[ "_   " table)
    (modify-syntax-entry ?\] "_   " table)
    (modify-syntax-entry ?# "' 14" table)
    (modify-syntax-entry ?| "\" 23bn" table)
    table)
  "Syntax table used in `lisp-mode'.")
@end group
@end smallexample

  Три режима для Lisp разделяются большую часть кода. Например,
все вызывают следующую функцию для установки переменных:

@smallexample
@group
(defun lisp-mode-variables (&optional syntax keywords-case-insensitive)
  (when syntax
    (set-syntax-table lisp-mode-syntax-table))
  (setq local-abbrev-table lisp-mode-abbrev-table)
  @dots{}
@end group
@end smallexample

@noindent
Среди прочего, функция устанавливает переменную @code{comment-start}
для обработки Lisp комментариев:

@smallexample
@group
  (make-local-variable 'comment-start)
  (setq comment-start ";")
  @dots{}
@end group
@end smallexample

  Каждый из различных Lisp режимов имеет немного отличающуюся
привязку клавиш (keymap, раскладку). Например в Lisp режиме по
@kbd{C-c C-z} выполняется @code{run-lisp}, а в других Lisp
режимах нет. Однако, все Lisp режимы имеют часть общих команд.
Общие команды устанавливаются следующим кодом:

@smallexample
@group
(defvar lisp-mode-shared-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\e\C-q" 'indent-sexp)
    (define-key map "\177" 'backward-delete-char-untabify)
    map)
  "Keymap for commands shared by all sorts of Lisp modes.")
@end group
@end smallexample

@noindent
Далее приводится код для установки раскладки Lisp режима:

@smallexample
@group
(defvar lisp-mode-map
  (let ((map (make-sparse-keymap))
	(menu-map (make-sparse-keymap "Lisp")))
    (set-keymap-parent map lisp-mode-shared-map)
    (define-key map "\e\C-x" 'lisp-eval-defun)
    (define-key map "\C-c\C-z" 'run-lisp)
    @dots{}
    map)
  "Keymap for ordinary Lisp mode.
All commands in `lisp-mode-shared-map' are inherited by this map.")
@end group
@end smallexample

@noindent
Далее приводится команда основного режима, для  Lisp режима:

@smallexample
@group
(define-derived-mode lisp-mode prog-mode "Lisp"
  "Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
Commands:
Delete converts tabs to spaces as it moves back.
Blank lines separate paragraphs.  Semicolons start comments.

\\@{lisp-mode-map@}
Note that `run-lisp' may be used either to start an inferior Lisp job
or to switch back to an existing one.
@end group

@group
Entry to this mode calls the value of `lisp-mode-hook'
if that value is non-nil."
  (lisp-mode-variables nil t)
  (set (make-local-variable 'find-tag-default-function)
       'lisp-find-tag-default)
  (set (make-local-variable 'comment-start-skip)
       "\\(\\(^\\|[^\\\\\n]\\)\\(\\\\\\\\\\)*\\)\\(;+\\|#|\\) *")
  (setq imenu-case-fold-search t))
@end group
@end smallexample

@node Minor Modes
@node Дополнительные режимы
@section Minor Modes
@cindex minor mode
@cindex дополнительные режимы

  Дополнительный @dfn{minor mode} режим предоставляется необязательные
функции, которые пользователи могут включать или выключать не зависимо от
основного режима. Дополнительные режимы могут включаться по отдельности
или в некоторой комбинации.

  Большинство дополнительных режимов реализуют функционал, который не зависит
от основного режима, и таким образом могут быть использованы с большинством
основных режимов. Например, Auto Fill (режим автозаполнения) может работать
с любым текстовым режимом который поддерживает вставку текста. Некоторые
дополнительные режимы, однако, специализированы для определенных основных
режимов. Например, Diff Auto Refine дополнительный режим предназначен
только для использования с Diff режимом.

  В идеале, дополнительный режим не должен оказывать влияния на другие
дополнительные режимы. Должно быть возможно включать и выключать дополнительные
режимы в любом порядке.

@defvar minor-mode-list
Значение этой переменной это список всех команд вспомогательных режимов
@end defvar

@menu
* Minor Mode Conventions::      Tips for writing a minor mode. (Советы по написанию дополнительных режимов)
* Keymaps and Minor Modes::     How a minor mode can have its own keymap. (Раскладки для вспомогательных режимов)
* Defining Minor Modes::        A convenient facility for defining minor modes. (Средства ддля упрощения определения дополнительных режимов)
@end menu

@node Minor Mode Conventions
@node Соглашения по дополнительным режимам
@subsection Conventions for Writing Minor Modes
@cindex minor mode conventions
@cindex соглашения по дополнительным режимам
@cindex conventions for writing minor modes
@cindex соглашения по написанию дополнительных режимов

  Как и для основных режимов, для дополнительных существуют соглашения
по их написанию. Указанные соглашения будут описаны ниже. Использование
макроса @code{define-minor-mode} простейший способ следовать этим
соглашениям.
@xref{Defining Minor Modes}.

@itemize @bullet
@item
@cindex mode variable
Переменная режима определяется переменной, чье имя оканчивается на
@samp{-mode}. Данную переменную будем называть @dfn{mode variable}.
Команда дополнительного режима должна устанавливать данную переменную.
Значение должно быть @code{nil} если режим не активен(disabled)
и не-@code{nil} если режим активен (enabled). Переменная должна быть
локальной для буфера (buffer-local) если дополнительный режим локальный
для буфера (buffer-local).

Данная переменная используется для в списке @code{minor-mode-alist}, для
отображения имени дополнительного режима в строке режима. Так же данная
переменная определяет является ли раскладка режима активной, через
@code{minor-mode-map-alist} (@pxref{Controlling Active Maps}). Другие
команды и перехватчики тоже могут проверять значение данной переменной.

@item
Нужно определить команду, называемую @dfn{mode command}, имя которой такое
же как имя переменной режима. Задача данной команды установить значение
переменной режима и выполнить другие действия включения и выключения
функций режима.

Команда режима должна принимать один необязательный параметр.
Если команда вызывается интерактивно, она должна переключать
состояние режима (включать если выключен и наоборот). Если она
вызывается интерактивно с prefix аргументом
(задается при помощи C-u <значение>), то режим нужно включить если
значение аргумента положительное и выключить в другом случае.

Если команда режима вызывается из Lisp (т.е не-интерактивно), тогда
команда должна включить режим если аргумент не задан или @code{nil};
должна переключить режима если аргумент символ @code{toggle};
иначе аргумент должен обработаться аналогично интерактивному поведению.

Дальше приводится пример как реализовать такое поведение (код схож
с кодом генерируемым макросом @code{define-minor-mode}):

@example
(interactive (list (or current-prefix-arg 'toggle)))
(let ((enable (if (eq arg 'toggle)
                  (not foo-mode) ; @r{this mode's mode variable}
                (> (prefix-numeric-value arg) 0))))
  (if enable
      @var{do-enable}
    @var{do-disable}))
@end example

Причина такого отчасти сложного поведения в том, что пользователю
нужно предоставить удобный способ включения дополнительного режима
интерактивно и из перехватчиков, например так:

@example
(add-hook 'text-mode-hook 'foo-mode)
@end example

@noindent
Данный код работает корректно в не зависимости от того включен ли
уже режим @code{foo-mode} или нет, так как @code{foo-mode} безусловно
включит дополнительный режим при вызове из Lisp без аргументов.
Выключение режима в перехватчике выглядит немного хуже:

@example
(add-hook 'text-mode-hook (lambda () (foo-mode -1)))
@end example

@noindent
Но, данный вызов используется не часто.

@item
В @code{minor-mode-alist} должен быть добавлен элемент
для каждого дополнительного режима (@pxref{Definition of minor-mode-alist}),
если дополнительный режим должен отображаться в строке режимов.
Элемент должен быть списком следующей формы:

@smallexample
(@var{mode-variable} @var{string})
@end smallexample

Где @var{mode-variable} переменная определяющая активность дополнительного
режима, а @var{string} короткая строка начинающаяся с пробела, которая
будет описывать режим в строке режимов. Данная строка должна быть короткой
так как пространство для описания всех режимов ограничено и одно на всех.

При добавлении элемента в @code{minor-mode-alist}, стоит использовать
@code{assq} чтобы избежать дублирования.
Например:

@smallexample
@group
(unless (assq 'leif-mode minor-mode-alist)
  (push '(leif-mode " Leif") minor-mode-alist))
@end group
@end smallexample

@noindent
или например, использовать @code{add-to-list} (@pxref{List Variables}):

@smallexample
@group
(add-to-list 'minor-mode-alist '(leif-mode " Leif"))
@end group
@end smallexample
@end itemize

  Часть соглашений для основных режимов хорошо подходят и для
дополнительных: например касающиеся имен глобальных символов,
использования функций в завершении функции инициализации режима, и
использования таблицы раскладок и других таблиц.

Дополнительный режима должен, если это возможно, поддерживать
включение и выключение через Custom (режим графической настройки)
(@pxref{Customization}). Чтобы это реализовать, переменная режима
должна быть определена через @code{defcustom}, обычно с
@code{:type 'boolean}. Если простое установление значения не
достаточно для включения режима, нужно определить метод @code{:set}
который включит режим вызовом команды режима. Стоит отметить, что
строка документации заданная не через Custom будет игнорироваться.
(примю
@code{autoload cookie} это магический комментарий @code{;;;###autoload},
который понимается командой @code{update-file-autoloads} и записывает
соответствующий autoload код в специальный файл @code{loaddefs.el}
)
Также можно пометить определение с использованием
autoload cookie (@pxref{autoload cookie}),
и добавить @code{:require}, чтобы изменение переменной
загружала соответствующую библиотеку с определением режима.
Например:

@smallexample
@group
;;;###autoload
(defcustom msb-mode nil
  "Toggle msb-mode.
Setting this variable directly does not take effect;
use either \\[customize] or the function `msb-mode'."
  :set 'custom-set-minor-mode
  :initialize 'custom-initialize-default
  :version "20.4"
  :type    'boolean
  :group   'msb
  :require 'msb)
@end group
@end smallexample

@node Keymaps and Minor Modes
@node Раскладки и дополнительные режимы
@subsection Keymaps and Minor Modes

  Дополнительный режим может иметь свою собственную раскладку, которая
активна когда режим включен. Для установки раскладки дополнительного режима
нужно добавить элемент в alist @code{minor-mode-map-alist}.
@xref{Definition of minor-mode-map-alist}.

@cindex @code{self-insert-command}, minor modes
@cindex @code{self-insert-command}, дополнительные режимы
  Одно из применений раскладок второстепенных режимов изменение поведения
символов (self-inserting characters символы вставляющие себя), чтобы
они делали еще что-то кроме вставки себя. (Другой способ настроить
@code{self-insert-command} использовать @code{post-self-insert-hook}. Кроме того,
настройка @code{self-insert-command} ограничена особыми случаями для
аббревиатур и режимом автозаполнения (Auto Fill mode)). Не нужно пытаться
заменить своим определением стандартное. Так как цикл редактора
обработает их специальным образом.)

Дополнительные режимы могут выполнять привязку к последовательности
@kbd{C-c} + знак пунктуации. Но @kbd{C-c} и следующим @kbd{@{@}<>:;} или
управляющим символом или цифрой зарезервированы для основных режимов.
Так же @kbd{C-c @var{letter}} зарезервировано для пользователей.
@xref{Key Binding Conventions}.
(Прим. То ест почти не с чем использовать нельзя.)

@node Defining Minor Modes
@node Определение дополнительного режима
@subsection Defining Minor Modes
@subsection Определение дополнительного режима

  Макрос @code{define-minor-mode} является удобным способом
определения режима.

@defmac define-minor-mode mode doc [init-value [lighter [keymap]]] keyword-args@dots{} body@dots{}
Макрос определяет новый дополнительный режим чье имя @var{mode}
(символ (a symbol)). Макрос определяет команду @var{mode} для
включения/выключения дополнительного режима, с @var{doc} в
качестве документации.

Команда переключения получает 1 необязательный (prefix) аргумент.
Если команда вызывается интерактивно без аргументов то она переключает
состояние режима с включенного на выключенное и наоборот.
Положительный prfix включает режим, любой другой prefix выключает.
При вызове из Lisp, аргумент @code{toggle} переключает режим, а
отсутствие аргумента или @code{nil} аргумент включает режим.
Такое поведение позволяет легко включить дополнительный режим в перехватчике
основного режима, например.
Если @var{doc} @code{nil}, макрос предоставляют строку документации
по умолчанию описанную выше.

По умолчанию, так же определяется переменная с именем @var{mode}, которая
устанавливается в @code{t} и @code{nil} при включении или выключении режима.
Переменная инициализируется значением @var{init-value}. За исключением
особых случаем (см. ниже), такое значение должно быть @code{nil}.

Параметр @var{lighter} определяет то, что будет отображаться в
строке режима, когда режим включен; если значение @code{nil},
режим не отображается в строке режима.

Не обязательный аргумент @var{keymap} определяет раскладку для
дополнительного режима. Если не-@code{nil}, то значение должно
быть именем переменной, чье значение это раскладка, или alist (ассоциативный массив)
в форме

@example
(@var{key-sequence} . @var{definition})
@end example

@noindent
где @var{key-sequence} и @var{definition} аргументы пригодные для
команды @code{define-key} (@pxref{Changing Key
Bindings}). Если @var{keymap} это раскладка или alist, то в макросе
будет этим будет определена переменная @code{@var{mode}-map}.

Три вышеописанных аргумента @var{init-value}, @var{lighter}, и
@var{keymap} могут быть (частично) опущены когда используется
@var{keyword-args}. Некоторые ключевые слова имеют
специальное значение:

@table @code
@item :group @var{group}
Специальное имя группы, которое будет использоваться во всех
формах @code{defcustom}.
По умолчанию @var{mode}, @samp{-mode}.
@strong{Warning:} не стоит использовать это имя по умолчанию,
если вы не определили использовали @code{defgroup} для
правильного определения группы. @xref{Group Definitions}.

@item :global @var{global}
Если значение не-@code{nil}, то режим будет глобальным,
а не локальным для буфера. Значение по умолчанию @code{nil}.

Одним из эффектов глобального дополнительного режима, является
то что переменная режима @var{mode} становится переменной
настройки (customization variable). Переключение ее значения
через интерфейс настройки (Customize interface) включает
и выключает режим, и данное значение может быть сохранено
для следующих сессий Emacs. (@pxref{Saving
Customizations,,, emacs, The GNU Emacs Manual}. Чтобы
сохранение переменной работало, нужно проверить, что
форма @code{define-minor-mode} выполняется каждый раз когда
Emacs запускается; для пакетов не являющихся частью
Emacs использование ключевого слова @code{:require}
является простейшим способом сделать это.

@item :init-value @var{init-value}
Эквивалентно позиционному @var{init-value}.

@item :lighter @var{lighter}
Эквивалентно позиционному @var{lighter}.

@item :keymap @var{keymap}
Эквивалентно позиционному @var{keymap}.

@item :variable @var{place}
Данная переменная заменяет переменную по умолчанию @var{mode},
используемую для хранения состояния режима. Если задать
это значение @var{mode} не определяется, и любой
@var{init-value} аргумент не будет использоваться. @var{place}
может быть другой именованной переменной (которую должна быть определена),
или чем угодно что может быть использовано с функцией @code{setf}
(@pxref{Generalized Variables}).
@var{place} может быть cons ячейкой @code{(@var{get} . @var{set})},
где @var{get} выражение возвращающее текущее значение, а
@var{set} функция одного аргумента устанавливающая значение.

@item :after-hook @var{after-hook}
Параметр определяет одну Lisp форму, которая выполняется после
того как выполнится перехватчик режима. Форма не должна быть
цитированием (quoted).
@end table

Все другие аргументы заданные с ключевыми словами передаются
непосредственно в @code{defcustom} сгенерированной для
переменной @var{mode}.

Команда с именем @var{mode} сначала выполняет стандартные действия
такие как установку переменной @var{mode} и затем выполняет формы @var{body},
если они заданы. Затем вызывается перехватчик режима @code{@var{mode}-hook},
и в завершении выполняется форма @code{:after-hook}.
@end defmac

  Начальное значение должно быть @code{nil} за исключением случаев
где (1) режим предварительно загружен в Emacs, или (2) загрузка режима
""безболезненна"" даже если пользователь ее не запрашивал. Например если
режим не оказывает эффекта, пока еще что-то не включено, тогда он будет
загружен для этого чего-то. Это особые случаи. Обычно начальное
значение @code{nil}.

@findex easy-mmode-define-minor-mode
  Имя @code{easy-mmode-define-minor-mode} является псевдонимом для
макроса.

  Пример использования @code{define-minor-mode}:

@smallexample
(define-minor-mode hungry-mode
  "Toggle Hungry mode.
Interactively with no argument, this command toggles the mode.
A positive prefix argument enables the mode, any other prefix
argument disables it.  From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

When Hungry mode is enabled, the control delete key
gobbles all preceding whitespace except the last.
See the command \\[hungry-electric-delete].

   Переключение Hunrgy режима.
Интерактивно без аргументов, команда переключает режим.
Положительный префикс аргумент включает режим, а любой другой
выключает. Из Lisp, отсутствие аргумента или nil включает режим, `toggle'
переключает состояние.

Когда Hungry режим включен, control + delete удаляет все
предшествующие пробелы кроме 1.
См. команду \\[hungry-electric-delete].
"
 ;; The initial value. Начальное значение
 nil
 ;; The indicator for the mode line. Текст для строки режима.
 " Hungry"
 ;; The minor mode bindings. Привязка клавиш дополнительно режима.
 '(([C-backspace] . hungry-electric-delete))
 :group 'hunger)
@end smallexample

@noindent
В примере определяется дополнительный режим ``Hungry mode'', команда
для переключения @code{hungry-mode}, переменная @code{hungry-mode},
которая указывает на состояние режима, и переменная @code{hungry-mode-map},
которая содержит раскладку, которая хранит привязки клавиш, которые
активны, когда активен режим. Создается раскладка с привязкой для
@kbd{C-@key{DEL}}. Переменная @code{hungry-mode} помещается в группу
настройки @code{hunger}. Форма @var{body} отсутствует --- многие
дополнительные режимы в ней не нуждаются.

  Эквивалентный вариант записи:

@smallexample
(define-minor-mode hungry-mode
  "Toggle Hungry mode.
...rest of documentation as before..."
 ;; The initial value. Начальное значение
 :init-value nil
 ;; The indicator for the mode line. Текст для строки режима
 :lighter " Hungry"
 ;; The minor mode bindings. Раскладка дополнительного режима.
 :keymap
 '(([C-backspace] . hungry-electric-delete)
   ([C-M-backspace]
    . (lambda ()
        (interactive)
        (hungry-electric-delete t))))
 :group 'hunger)
@end smallexample

@defmac define-globalized-minor-mode global-mode mode turn-on keyword-args@dots{}
Определяет глобальный переключатель @var{global-mode}, назначение
которого выключать или включать локальный для буфера дополнительный режим
@var{mode} во всех буферах. Для включения дополнительного режима
в буфере используется функция @var{turn-on}, для выключения вызов
@var{mode} с аргументом @minus{}1.

Глобальное включение режима так же сказывается на буферах созданных
при открытии файлов в дальнейшем, и буферах которые используют
основной режим отличный от Fundamental режима; но не обнаруживается
создание новых буферов в Fundamental режиме.

Макросом определяется опция настройки @var{global-mode} (@pxref{Customization}),
которая может быть изменена через интерфейс настройки (Customize interface).
Как и с @code{define-minor-mode}, нужно проверять, что
@code{define-globalized-minor-mode} вычисляется при каждом
запуске Emacs, например используя ключевое слово @code{:require}.

Чтобы задать группу настройки можно использовать @code{:group @var{group}}
@var{keyword-args}.

В общем, когда определяется глобальный доп. режим, так же нужно
определить не глобальную версию, чтобы люди могли использовать (или отключать)
режим в отдельных буферах. Кроме того это позволит
им отключить глобально включенный доп. режим в заданных основных
режимах, используя перехватчики этих режимов.
@end defmac


@node Mode Line Format
@node Формат строки режима
@section Mode Line Format
@section Формат строки режима
@cindex mode line
@cindex строка режима

  Каждое Emacs окно (за исключением окна минибуфера) как правило
имеет строку режима внизу, на которой отображается информация о буфере
отображаемом в окне. Строка режима содержит информацию о буфере, такую
как имя файла, глубину рекурсивного редактирования, основной и
дополнительные режимы. Окно может также иметь @dfn{header line},
которая такая же как строка режима только сверху окна.

Данный раздел описывает как управлять содержимым строки состояния и
строкой заголовка (header line). Данный раздел включен в эту главу,
потому что основная часть информации строки состояния связана с
основным или вспомогательным режимом.

@menu
* Base: Mode Line Basics.       Основные идеи управления строкой режима.
* Data: Mode Line Data.         Структура данных управляющая строкой режима.
* Top: Mode Line Top.           Переменная верхнего уровня, mode-line-format.
* Mode Line Variables::         Переменные используемые в структуре данных строки режима.
* %-Constructs::                Размещение информации в строке режима.
* Properties in Mode::          Использования свойств текста в строке режим.
* Header Lines::                Как строка режима только сверху.
* Emulating Mode Line::         Форматирование текста в стиле строке режима (эмулирование).
@end menu

@node Mode Line Basics
@subsection Mode Line Basics

  Содержимое строки режима определяется локальной переменной буфера
@code{mode-line-format} (@pxref{Mode Line Top}).  Эта переменная
хранит @dfn{mode line construct}: шаблон, который определяет
что отображается на строке режима. Значение переменной
@code{header-line-format} определяет строку заголовка точно
аналогично. Все окна одного буфера используют одни и теже
@code{mode-line-format} и @code{header-line-format}.
  a template that controls what is
displayed on the buffer's mode line.  The value of
@code{header-line-format} specifies the buffer's header line in the same

Для повышения производительности, Emacs не всегда пересчитывает
строку режима и строку заголовка окна. Пересчет выполняется если
при ряде условие, таких как переключение буферов, сжатие или расширение
буфера, прокрутка, или изменение буфера. Если изменить переменные
@code{mode-line-format} или
@code{header-line-format} (@pxref{Mode Line Variables}), или любые
другие структуры данных которые влияют на отображение текста
(@pxref{Display}), нужно воспользоваться функцией
@code{force-mode-line-update} для обновления.

@defun force-mode-line-update &optional all
Функция заставляет Emacs обновить строку режима и строку заголовка
текущего буфера, на основе значений всех связанных переменных.
Если необязательный аргумент @var{all} не-@code{nil}, обновляются
все строки режима и заголовки.

Функция так же заставляет обновить строку меню и заголовок фрейма.
@end defun

  Строка выбранного окна, как правило отображается другим цветом,
используя шрифт @code{mode-line}. Строки других окон отображаются
шрифтом @code{mode-line-inactive}. @xref{Faces}.

@node Mode Line Data
@subsection The Data Structure of the Mode Line
@cindex mode line construct

  Строка режима задается при помощи структуры
@dfn{mode line construct}  состоящей из списков, строк, символов, и
чисел хранящихся в локальных переменных буфера. Каждый тип данных
имеет особое значение в строке режима, как описано ниже. Такие же
структуры данных используются для задания заголовка фрейма
(@pxref{Frame Titles}) и строки заголовка буфера (@pxref{Header Lines}).

 Строка режима может просто фиксированной строкой текста, но
как правило задается как в виде комбинации строки и значений
переменных для задания текста. Многие такие переменные сами
так определены специально для использования в строке режима.
(Many of these variables are themselves
defined to have mode line constructs as their values.)


 Далее описание значение типов данных в качестве частей строки режима:

@table @code
@cindex percent symbol in mode line
@item @var{string}
Строки в строке режима отображаются без изменений, за исключением
@dfn{@code{%}-constructs}. В такие конструкции выполняется
подстановка других данных.
@ref{%-Constructs}.

Если часть строки содержит @code{face} свойства, они управляют
текстом так же как в буфере. Любые символы  которые не содержат
@code{face} отображаются шрифтом по умолчанию @code{mode-line} или
@code{mode-line-inactive}. @code{help-echo} и @code{keymap}
свойства @var{string} имеют особое значение. @xref{Properties in Mode}.

@item @var{symbol}
Символ в строке режима добавляет свое значение. Значение @var{symbol}
используется как часть конструкции строки режима. Но @code{t} и @code{nil}
игнорируются, как и символы со значением void.

Есть 1 исключение: если значение @var{symbol} строка, то текст
вставляется как есть и подстановка @code{%}-constructs не выполняется.

Если символ не помечен как @var{symbol} рискованный (т.е
свойство @code{risky-local-variable} не-@code{nil}),
все текстовые свойства строк в переменной символа @var{symbol},
игнорируются, как и все @code{:eval} и @code{:propertize}
формы. (Это делается ради безопасности: не опасные переменные
могут быть установлены автоматически из переменных файла
без запроса у пользователя).
(Не очень понятно, что тут имеется ввиду. Оригинальный вариант:).
Unless @var{symbol} is marked as risky (i.e., it has a
non-@code{nil} @code{risky-local-variable} property), all text
properties specified in @var{symbol}'s value are ignored.  This includes
the text properties of strings in @var{symbol}'s value, as well as all
@code{:eval} and @code{:propertize} forms in it.  (The reason for this
is security: non-risky variables could be set automatically from file
variables without prompting the user.)

@item (@var{string} @var{rest}@dots{})
@itemx (@var{list} @var{rest}@dots{})
Список с первым элементом строкой, указывает что нужно обработать
все элементы рекурсивно и соединить результаты. Это наиболее
частая форма конструкции строки режима.

@item (:eval @var{form})
Список первым элементом которого является символ @code{:eval},
говорит вычислить @var{form}, и использовать результат как строку
для отображения. Вычисление не должно загружать файлы, так как
это может привести к бесконечной рекурсии.

@item (:propertize @var{elt} @var{props}@dots{})
Список первый элемент которого символ @code{:propertize} говорит
обработать @var{elt} рекурсивно, после чего добавить свойства текста
заданные @var{props} к результату. Аргумент @var{props} должен
состоять из 0 или более пар @var{text-property} @var{value}.

@item (@var{symbol} @var{then} @var{else})
Список с первым аргументом являющемся не ключевым символом обрабатывается
в зависимости от значения @var{symbol}. Если значение @var{symbol}
не-@code{nil}, второй элемент @var{then} обрабатывается рекурсивно
как элемент строки режима, иначе, третий аргумент @var{else},
обрабатывается рекурсивно. @var{else} можно опустить, тогда
в строке режима ничего не будет отображено если значение
@var{symbol} @code{nil} или void.

@item (@var{width} @var{rest}@dots{})
Список с первым элементом числом определяет максимальную
ширину для результата @var{rest}. @var{rest} обрабатывается
рекурсивно, как части строки режима и соединяются вместе.
Когда @var{width} положительное, если ширина вычисления
меньше @var{rest}, справа добавляются пробелы. Когда
@var{width} отрицательное, результат обрезается до
@minus{}@var{width} если ширина больше @minus{}@var{width}.

Например, обычный способ показать сколько процентов буфера находится
выше использовать: @code{(-3 "%p")}.
@end table

@node Mode Line Top
@subsection The Top Level of Mode Line Control

Переменная верхнего уровня.
 Переменная для задания всей строки режима
называется @code{mode-line-format}.


@defopt mode-line-format
Значение переменной элемент (конструкт) строки режима, задающий
содержимое строки режима. Как правило это локальная для буфера
переменная.

Если значение переменной установить в @code{nil}, строки режима
у буфера не будет. (Окна высотой в 1 строку так же не имеют
строки режима).
@end defopt

Значение по умолчанию @code{mode-line-format} проектируется с
использованием значением таких переменных как @code{mode-line-position} и
@code{mode-line-modes} (которые объединяют значение переменных
@code{mode-name} и @code{minor-mode-alist}). Совсем немногим
режимам требуется изменение @code{mode-line-format} самостоятельно.
В большинстве случаев, достаточно задать какие-то переменные
которые влияют на @code{mode-line-format}.

Если вы изменяете @code{mode-line-format}, новое
значение должно использовать те же переменные что и в
оригинальном значении (@pxref{Mode Line Variables}),
вместо дублирования их значений или использования другого
способа отображения информации. Такой способ, позволяет
оставить возможность настройки через переменные пользователем или
Lisp программой (как @code{display-time} и основными режимами).

Ниже гипотетический пример @code{mode-line-format}, который
может использоваться для Shell режима (в реальности, Shell режим, не
задает @code{mode-line-format}).

@example
@group
(setq mode-line-format
  (list "-"
   'mode-line-mule-info
   'mode-line-modified
   'mode-line-frame-identification
   "%b--"
@end group
@group
   ;; @r{Отметим, что это вычисляется при построении списка.}
   ;; @r{Получается  конструкт строки режима который является строкой.}
   (getenv "HOST")
@end group
   ":"
   'default-directory
   "   "
   'global-mode-string
   "   %[("
   '(:eval (mode-line-mode-name))
   'mode-line-process
   'minor-mode-alist
   "%n"
   ")%]--"
@group
   '(which-func-mode ("" which-func-format "--"))
   '(line-number-mode "L%l--")
   '(column-number-mode "C%c--")
   '(-3 "%p")))
@end group
@end example

@noindent
(Переменные @code{line-number-mode}, @code{column-number-mode}
и @code{which-func-mode} включают соответствующие дополнительные режимы; как правило,
имена этих переменных являются именами команд дополнительных режимов.)

@node Mode Line Variables
@subsection Variables Used in the Mode Line

Переменные строки режима.
  Данная секция содержит описание переменных объединяющихся в
значение строки режима для стандартного значения @code{mode-line-format}.
Ничем существенно особенным эти переменные не являются; но некоторые
переменные могут иметь определенное влияние не строку режима,
если значение @code{mode-line-format} изменено, так чтобы они
использовались. Но, различные части Emacs устанавливают значения
данных переменных, считая, что влияют на строку режима; таким образом;
важно чтобы строка режима их использовала. См. @ref{Optional Mode Line,,,
emacs, The GNU Emacs Manual}.
(Суть в том, что если изменяется @code{mode-line-format}, стоит
оставить в ней использование описанных ниже переменных, так как
другой Lisp код считает что они используются).

@defvar mode-line-mule-info
Переменная в строке режима определяет отображение информации
о языке, кодировке буфера, и текущем методе ввода.
@xref{Non-ASCII Characters}.
@end defvar

@defvar mode-line-modified
Переменная отвечает за информации о том, был ли буфер изменен.
Типичные значения: @samp{**} -- буфер изменен, @samp{--} -- не
изменен, @samp{%%} -- буфер только для чтения, @samp{%*} -- буфер
только для чтения, но при этом изменен.

Изменение этой переменной, не приводит к немедленному обновлению
строки режима.
@end defvar

@defvar mode-line-frame-identification
Переменная определяет отображение информации о текущем фрейме.
Значение по умолчанию:
@code{" "} -- если используется система окон, которая
может отображать множество фреймов, или @code{"-%F "} на
терминалах, которые могут отображать только один фрейм за раз.
@end defvar

@defvar mode-line-buffer-identification
Переменная отвечает за отображение информации о буфере. Значение по умолчанию
предполагает отображение имени буфера расширенное пробелами до минимальных
12 символов.
@end defvar

@defvar mode-line-position
Переменная определяет отображение позиции в буфере. Значение по умолчанию
отображает часть буфера сверху в процентах, и опционально размер
буфера, номер строки и столбца курсора.
@end defvar

@defvar vc-mode
Переменная @code{vc-mode} локальная для буфера, определяет,
поддерживается для контроль версий для файла буфера, и если да
то какая система контроля версий. Значение переменной строка,
которая отображается в строке режима или @code{nil} если
система контроля версий не используется.
@end defvar

@defvar mode-line-modes
Переменная определяет отображение основного и дополнительных режимов.
Значение по умолчанию также отображает уровень рекурсивного редактироавния
(recursive editing level), информацию о статусе процесса и используется
ли сужение (narrow).
(narrow -- такая штука когда, выделяется часть буфера, нажимается
C-x n n (narrow-to-region) и редактируется только часть буфера,
потом нажимается C-x n w (widen) и опять видим весь буфер).
@end defvar

@defvar mode-line-remote
Переменная определяет отображение удаленности @code{default-directory}.
То есть является ли текущий каталог удаленным (прим. например ssh.).
@end defvar

@defvar mode-line-client
Переменная отображает @code{emacsclient} фреймов.
@end defvar

  Три следующих переменных используются в @code{mode-line-modes}:

@defvar mode-name
 Локальная для буфера переменная хранит ``pretty'' (удобное) имя
основного режима. Каждый основной режим устанавливает данную переменную.
Значение не обязано быть строкой, но может использовать все типы данных
конструктов (частей) строки режима (@pxref{Mode Line Data}).
Для вычисления строки, которая появится в строки режима можно
использовать @code{format-mode-line} (@pxref{Emulating Mode Line}).
@end defvar

@defvar mode-line-process
Локальная для буфера переменная содержит информацию о статусе
процесса в режимах используемых для связи с подпроцессами.
Значение отображается сразу за именем основного режима.
Например в буфере @file{*shell*} используется значение @code{(":%s")},
которое позволяет оболочке (shell) отображать статус вместе
с основным режимом как: @samp{(Shell:run)}.
Обычно значение переменной @code{nil}.
@end defvar

@defvar mode-line-front-space
Значение данной переменной отображается в начале строки режима, за
исключением наличия memory-full сообщения.
@end defvar

@defvar mode-line-end-spaces
Значение данной переменной отображается в конце строки режима.
@end defvar

@defvar mode-line-misc-info
Переменная используется для отображения дополнительно информации.
По умолчанию, переменная отображает информации заданную
@code{global-mode-string}.
@end defvar

@defvar minor-mode-alist
@anchor{Definition of minor-mode-alist}
Переменная содержит ассоциативный список элементы которого определяют
как должно отображаться в строке режима активность соответствующего
дополнительного режима. Каждый элемент @code{minor-mode-alist}
должен быть 2-х элементным списком:

@example
(@var{minor-mode-variable} @var{mode-line-string})
@end example


В общем, @var{mode-line-string} может быть любым конструктом
строки режима. Значение появляется в строке режима, когда
@var{minor-mode-variable}  не-@code{nil}. Строки должна
начинаться с пробела, чтобы названия режимов не сливались.
Традиционно, переменная @var{minor-mode-variable} режима не-@code{nil}
когда дополнительный режим активен.

@code{minor-mode-alist} не локальная для буфера. Но переменные
используемые в списке, должны быть локальными для буфера, если
дополнительный режим может включаться-выключаться в отдельных буферах.
@end defvar

@defvar global-mode-string
Переменная хранит контрукт строки режима, который ко умолчанию, появляется
в строке режима сразу за @code{which-func-mode} второстепенного режима,
если он задан, иначе за @code{mode-line-modes}. Команда @code{display-time}
устанавливает ссылку @code{global-mode-string} на переменную
@code{display-time-string}, которая хранит строку времени и
информацию о загрузке. (прим. средняя информации по загрузке системы,
за какой-то промежуток времени, по умолчанию видимо 1 минута).

Конструкт @samp{%M} выполняет подстановку значения @code{global-mode-string},
(но это считается устаревшим), так как переменная включена в
строку режима в @code{mode-line-format}.
@end defvar

Ниже упрощенный пример значения по умолчанию
@code{mode-line-format}. Реальное определение
определяет дополнительные текстовые свойства.

@example
@group
("-"
 mode-line-mule-info
 mode-line-modified
 mode-line-frame-identification
 mode-line-buffer-identification
@end group
 "   "
 mode-line-position
 (vc-mode vc-mode)
 "   "
@group
 mode-line-modes
 (which-func-mode ("" which-func-format "--"))
 (global-mode-string ("--" global-mode-string))
 "-%-")
@end group
@end example

@node %-Constructs
@subsection @code{%}-Constructs in the Mode Line

  Строки используемые в строке режима могут использовать
@code{%}-конструкты для подстановки разных данных.
Ниже содержится описание списка @code{%}-конструктов, и
их значений.

  В любом конструкте за исключением @samp{%%}, можно добавить натуральное
числе после @samp{%}, для задания минимальной ширины поля. Чисто числовые
конструкты (@samp{c}, @samp{i}, @samp{I}, and @samp{l}) расширяются
пробелами слева, другие расширяются пробелами справа.

@table @code
@item %b
Имя текущего буфера, полученное функцией @code{buffer-name}.
@xref{Buffer Names}.

@item %c
Текущий номер колонки.

@item %e
Когда у Emacs приближается переполнение памяти Lisp объектов,
показывается краткое сообщение. В других случая, контрукт пустой.

@item %f
Имя файла, полученное функцией @code{buffer-file-name}.
@xref{Buffer File Name}.

@item %F
Заголовок (только для системы окон) или имя выбранного фрейма.
@xref{Basic Parameters}.

@item %i
Размер доступной части текущего буфера; вычисляемой
@code{(- (point-max) (point-min))}.

@item %I
Так же как @samp{%i}, но размер печатается в более читаемой форме,
используя  @samp{k} для 10^3,
@samp{M} для 10^6, @samp{G} для 10^9, и т.д., для сокращения.

@item %l
Текущий номер строки, вычисляемой для доступной части буфера.

@item %n
@samp{Narrow} Когда включено сужение; иначе пусто (см.
@code{narrow-to-region} в @ref{Narrowing}).

@item %p
Процент буфера находящийся сверху @strong{top} окна, или
@samp{Top}, @samp{Bottom} или @samp{All}. Конструкция для
строки режима по умолчанию, обрезает значение до 3-х символов.

@item %P
Процент текста буфера который выше @strong{bottom} окна
(включает текст видимый в окне, как и текст выше top), плюс @samp{Top}
если верх буфера виден на экране; или @samp{Bottom}  @samp{All}.

@item %s
Статус подпроцесса принадлежащего текущему буферу,
полученный функцией @code{process-status}.
@xref{Process Information}.

@item %z
Мнемоническое обозначение кодировки раскладки, терминала или
буфера.

@item %Z
Как @samp{%z}, но включает форматирования конца строки end-of-line.

@item %*
@samp{%} Если буфер только для чтения (см @code{buffer-read-only}); @*
@samp{*} Если буфер изменен (см. @code{buffer-modified-p}); @*
@samp{-} В других случаях.  @xref{Buffer Modification}.

@item %+
@samp{*} Если буфер изменен (см. @code{buffer-modified-p}); @*
@samp{%} Если буфер только для чтения (см. @code{buffer-read-only}); @*
@samp{-} В других случаях.  Тут отличие от @samp{%*} только
для измененных буферов и только на чтение.  @xref{Buffer Modification}.

@item %&
@samp{*} Если буфер изменен, и @samp{-} если не изменен.

@item %[
Индикатор глубины рекурсивного редактирования (не считаются уровни
минибуфера): одна @samp{[} для каждого уровня.
@xref{Recursive Editing}.

@item %]
Одна @samp{]} для каждого уровня рекурсивного редактирования
(не считаются уровни минибуфера).

@item %-
Черточка для заполнения оставшейся части строки режима.
(Dashes sufficient to fill the remainder of the mode line.)
(Прим. Видимо просто заполнение.)

@item %%
Позволяет включить символ @samp{%} в строку в которой
поддерживаются @code{%}-конструкты.
(То есть экранирование @samp{%}).
@end table

Следующие 2 @code{%}-конструкта еще поддерживаются, но они уже
устарели, так как тот же результат можно получить:
через @code{mode-name} and @code{global-mode-string}.

@table @code
@item %m
Значение @code{mode-name}.

@item %M
Значение @code{global-mode-string}.
@end table

@node Свойства в режиме
@node Properties in Mode
@subsection Properties in the Mode Line
@cindex text properties in the mode line
@cindex текстовые свойства в строке режима

Некоторые свойства текста влияют на строку режима.
Свойство @code{face} влияет на внешний вид текста;
@code{help-echo} ассоциирует подсказку с текстом, а
@code{keymap} делает текст кликабельным (мышкой).


Существует 4 способа задать текстовые свойства в строке режима:

@enumerate
@item
Поместить строку с текстовыми свойствами непосредственно в структуры
данных строки режима.

@item
Поместить текстовые свойства на %-конструкт, такой как @samp{%12b};
в результате чего текст полученный для конструкта будет содержать
те же свойства.

@item
Использовать @code{(:propertize @var{elt} @var{props}@dots{})} конструкт
чтобы задать @var{elt} текстовое свойство заданное @var{props}.

@item
Использовать список @code{:eval @var{form}} в структуре данных
строки режима, и выполнить интерпретацию @var{form}
в строку с текстовыми свойствами.
(make @var{form} evaluate)
@end enumerate

  Можно использовать @code{keymap} для задания раскладки. Раскладка
будет действовать только для нажатия мышкой; привязка
других клавиш будет игнорироваться, потому что перемещение
по строке режима не возможно.

  Если строка режима ссылается на переменную, которая не содержит
не-@code{nil} @code{risky-local-variable} свойства,
любой текст определенный с такой переменной игнорируется.
Так делается потому что такие свойства могут определять вызов
функций, и такие функции могут быть получены из
локальных переменных файлов.
(судя по всему имеется ввиду, что свойства игнорируются, потому что
зависят от переменных локальных для файла)

@node Header Lines
@node Строки заголовка
@subsection Window Header Lines
@cindex header line (of a window)
@cindex window header line

  Окно может иметь @dfn{header line} (строку заголовка) сверху,
так же как строку режима снизу. Строка заголовка
определяется и функционирует так же как строка режима, за
исключением того, что определяется переменной @code{header-line-format}:

@defvar header-line-format
Переменная, локальная для любого буфера, определяет то как будет
отображаться строка заголовка. Формат переменной такой же как 
for @code{mode-line-format} (@pxref{Mode Line Data}).
Как правило это значение @code{nil}, то есть буферы не
содержат строки заголовка.
@end defvar

@defun window-header-line-height &optional window
Функция возвращает высоту в пикселах строки заголовка @var{window}
(окна). @var{window} (окно) должно быть существующим окном,
значением по умолчанию является выбранной окно.
@end defun

  Окно высотой в одну строку не отображает строку заголовка.
Окно высотой в 2 строки не может отобразить строку заголовка и строку
режима одновременно, если у окна есть строка режима, то строка
заголовка отображаться не будет.

@node Эмулирование строки режима
@node Emulating Mode Line
@subsection Emulating Mode Line Formatting

  Можно использовать функцию @code{format-mode-line} для вычисления
текста который появится в строке режима или строке заголовка для
заданной конструкции строки режима.

@defun format-mode-line format &optional face window buffer
Функция выполняет форматирование текстовой строки @var{format}
как если бы это была строка режима окна @var{window},
и возвращает текст как результат. Значение по умолчанию
для @var{window} текущее окно. Если @var{buffer} не @code{nil},
информация берется из @var{buffer}; @var{buffer} по умолчанию
буфер из @var{window}. 

Строковое значение содержит свойства текста такие соответствующие
шрифтам, раскладкам и т.д. такие какие бы были у текста строки режима.
Любой символ для которого @code{face} не задается через @var{format}
получит шрифт по умолчанию из аргумента @var{face}. Если @code{t},
используется шрифт как для строки режима активного окна (@code{mode-line})
если @var{window}
окно активное, иначе как для не активного (@code{mode-line-inactive}).
Если @var{face} @code{nil}, то используется шрифт по умолчанию.
Если @var{face} число, значение возвращаемое функцией не содержит
свойств текста.

Если задать шрифт в аргументе @var{face}, он будет использоваться
по умолчанию для символов чей шрифт не определяется в @var{format}.

Стоит отметить, что использование @code{mode-line},
@code{mode-line-inactive}, или @code{header-line} в качестве @var{face}
шрифта, приведет к перерисовки строки режима или строки заголовка
соответственно, а не только возвращению форматированной строки.
(Другие шрифты такого влияния не оказывают).

Например, @code{(format-mode-line header-line-format)} вернет
текст соответствующий строке заголовка (@code{""} если заголовка нет)
@code{(format-mode-line header-line-format
'header-line)} вернет тот же текст, и кроме того перерисует строку
заголовка.
@end defun

@node Imenu
@section Imenu

@cindex Imenu
  @dfn{Imenu} позволяет пользователю выполнять выделение определений
или секций буфера, из меню содержащего список всех элементов, с
непосредственным переходом к элементу. Imenu работает путем
создания индекса который представляет собой список имен
и соответствующих им позиций в буфере; после чего
пользователь может выбрав имя переместится на соответствующую
позицию. Основные режима могут добавить элемент в меню (основное)
для использования Imenu командой @code{imenu-add-to-menubar}.

@deffn Command imenu-add-to-menubar name
Функция определяет элемент меню с именем @var{name}, для
запуска Imenu.
@end deffn

  Пользовательские команды для использования Imenu описаны в руководстве
Emacs (@pxref{Imenu,, Imenu, emacs, the Emacs Manual}). Данная секция
описывает как настроить методы Imenu для поиска определений или
позиций для определенного основного режима.

  Простейший и наиболее часто используемым является
задание переменной @code{imenu-generic-expression}:

@defvar imenu-generic-expression
Если переменная не-@code{nil}, должна быть списком регулярных
выражений для поиска определений для Imenu. Простой элемент
@code{imenu-generic-expression} может выглядеть так:

@example
(@var{menu-title} @var{regexp} @var{index})
@end example

Тут, если @var{menu-title} не-@code{nil}, означает, что найденный
элемент попадет в подменю индекса буфера (или просто подменю);
@var{menu-title} определяет имя подменю. Если
@var{menu-title} @code{nil}, найденные элементы попадают непосредственно
в меню верхнего уровня.

@var{regexp} регулярное выражение (@pxref{Regular Expressions});
все что в буфере удовлетворяет является определением, попадающем
в индекс.

Третий элемент, @var{index}, это положительно целое, определяющее
какое подвыражение @var{regexp} является именем определения.
(Видимо имеется в виду что, в regexp есть группы, и это номер
группы).

Элемент может выглядеть и так:

@example
(@var{menu-title} @var{regexp} @var{index} @var{function} @var{arguments}@dots{})
@end example

Каждое совпадение для такого элемента создает элемент индекса,
но при выборе такого элемента пользователем вызывается функция
@var{function} с аргументами именем элемента, позицией в буфере, и
@var{arguments}.

Для режима Emacs Lisp, @code{imenu-generic-expression}, должна
выглядеть следующим образом:

@c should probably use imenu-syntax-alist and \\sw rather than [-A-Za-z0-9+]
@example
@group
((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2)
@end group
@group
 ("*Types*"
  "^\\s-*\
(def\\(type\\|struct\\|class\\|ine-condition\\)\
\\s-+\\([-A-Za-z0-9+]+\\)" 2))
@end group
@end example

Установка данной переменной делает ее локальной для текущего буфера.
@end defvar

@defvar imenu-case-fold-search
Переменная @code{imenu-generic-expression} если @code{t}
то поиск выполняет с учетом регистра, по умолчанию
без учета.

Установка переменной делает ее локальной для текущего буфера.
@end defvar

@defvar imenu-syntax-alist
Переменная содержит ассоциативный список (alist) модификаторов
синтаксической таблицы при обработке @code{imenu-generic-expression},
для перезаписи синтаксической таблицы буфера.
Каждый элемент должен иметь форму:

@example
(@var{characters} . @var{syntax-description})
@end example

@sc{car}, @var{characters} может быть символом (character) или строкой.
Элемент предписывает взять символ или строки заданные
@var{syntax-description},
которые передаются @code{modify-syntax-entry}
(@pxref{Syntax Table Functions}).

Данная возможность используется для того, чтобы
сделать обычными некоторые слова которые обычно являются
символами, и упростить @code{imenu-generic-expression},
чтобы увеличить скорость.

Например, Fortran использует это так:

@example
(setq imenu-syntax-alist '(("_$" . "w")))
@end example

В регулярном выражении @code{imenu-generic-expression} можно после
этого использовать @samp{\\sw+} вместо @samp{\\(\\sw\\|\\s_\\)+}.
Данная техника не удобна когда в режиме нужно ограничить
начальную букву имени, до небольшого множества символов
которые разрешены в отличие от остальной части имени.

Установка данной переменной делает ее локально для буфера.
@end defvar

  Другой способ настройки Imenu для основного режима установить
переменные @code{imenu-prev-index-position-function} и
@code{imenu-extract-index-name-function}:

@defvar imenu-prev-index-position-function
Если переменная не-@code{nil}, то значением должна быть функция,
которая ищет следующее определение для помещения в индекс буфера,
выполняя сканирование буфера в обратном порядке начиная с текущей
точки. Функция должна возвращать @code{nil} если не одного
определения найдено не было. Иначе она должна оставить точку в месте
где найдено определение и вернуть любое не-@code{nil} значение.

Установка переменной делает ее локально для текущего буфера.
@end defvar

@defvar imenu-extract-index-name-function
Если значение переменной не-@code{nil}, значение должна быть
функция возвращающая имя определения, предполагая что точка (point, курсор)
находится на определении и была оставлена
функцией @code{imenu-prev-index-position-function}.

Установка данной переменной делает ее локально для буфера.
@end defvar

  Еще один способ настройки Imenu задать
@code{imenu-create-index-function}:

@defvar imenu-create-index-function
Переменная определяет функцию используемую для создания
индекса буфера. Функция не должна иметь аргументов, и возвращать
ассоциативный список, который будет индексом для текущего
буфера. Функция вызывается внутри, @code{save-excursion}, поэтому
изменение точки не важно.

Ассоциативный список индекса может иметь три типа аргументов:
Простые элементы выглядят как:

@example
(@var{index-name} . @var{index-position})
@end example

Выбор простого элемента приводит в позиционированию
на @var{index-position} в буфере. 
Специальные элементы выглядят как:

@example
(@var{index-name} @var{index-position} @var{function} @var{arguments}@dots{})
@end example

Выбор специального элемента выполняется как:

@example
(funcall @var{function}
         @var{index-name} @var{index-position} @var{arguments}@dots{})
@end example

Вложенные под-индексы выглядят:

@example
(@var{menu-title} . @var{sub-alist})
@end example

В результате создается подменю  @var{menu-title} с  @var{sub-alist}.

Значением по умолчанию для @code{imenu-create-index-function} является
@code{imenu-default-create-index-function}.  Функция вызывает
 @code{imenu-prev-index-position-function} и 
@code{imenu-extract-index-name-function} для создания индекса.
Но, если хотя бы одна из этих переменных @code{nil}, используется
@code{imenu-generic-expression}.

Установка данной переменной делает ее локально для буфера.
@end defvar

@node Режим блокировки шрифта
@node Font Lock Mode
@section Font Lock Mode
@cindex Font Lock mode

Прим. Font Lock режим используется для подсветки текста.
В режимах для языков программирования он подсвечивает переменные,
комментарии, строки константы и т.д.
В оригинале используется термин fontification, в переводи
это будет переводится как подсветка.

  @dfn{Font Lock mode} локальный для буфера дополнительный режим
который автоматически устанавливает свойство @code{face} для
некоторых частей буфера в зависимости от их синтаксической роли.
При сами части зависят от основного режима. Большинство
основных режимов задает синтаксис, для этого. Данная
секция описывает как настроить Font Lock для
основного режима.

  Font Lock находит текст для выделения двумя способами:
через разбор синтаксиса на основе таблицы синтаксиса, и
через поиск (обычно по регулярным выражениям).

Сначала выполняется подсветка по синтаксису (так
можно подсветить комментарии, строковые константы);
затем выполняется подсветка с использование поиска.

@menu
* Font Lock Basics::            Обзор настройки Font Lock.
* Search-based Fontification::  Подсветка по регулярным выражениям.
* Customizing Keywords::        Настройки подсветки по поиску.
* Other Font Lock Variables::   Дополнительные возможности настройки.
* Levels of Font Lock::         Каждый режим может задать дополнительные
                                уровни, а пользователь может выбрать
                                больше или меньше.
* Precalculated Fontification::  Как Lisp программы генерирующие содержимое буфера
                                 могут определить подсветку для них.
* Faces for Font Lock::         Шрифты специально для Font Lock.
* Syntactic Font Lock::         Подсветка основанная на таблицах синтаксиса.
* Multiline Font Lock::         Как включить подсветку Font Lock для многострочных
                                конструкций.
@end menu

@node Font Lock Basics
@subsection Font Lock Basics

Основы подсветки.

  Функционал Font Lock основан на нескольких базовых функциях.
Каждая из них вызывает функцию определенную соответствующей
переменной. Такая непрямолинейность позволяет основным и дополнительным
режимам изменять работу способа подсветки в буфере с соответствующим
режимом, или даже использовать механизмы Font Lock там где
подсветка не нужна. (Поэтому ниже в описании функций
говорится что они ``должны'' делать, так как режим может их
изменить на что-то другое).
Перечисленные ниже переменные описаны в @ref{Other
Font Lock Variables}.

@ftable @code
@item font-lock-fontify-buffer
Данная функция должна сделать подсветку доступной части буфера
путем вызова функции определенной
@code{font-lock-fontify-buffer-function}.

@item font-lock-unfontify-buffer
Если Font Lock включен то функция выключает подсветку (Font Lock).
Вызывается функция  @code{font-lock-unfontify-buffer-function}.

@item font-lock-fontify-region beg end &optional loudly
Функция должна сделать подсветку для региона между
@var{beg} и @var{end}. Если @var{loudly} не-@code{nil},
должно отображаться сообщения статуса пока выполняется
подсветка. Вызывается функция определенная
@code{font-lock-fontify-region-function}.

@item font-lock-unfontify-region beg end
Функция должна удалить подсветку региона между @var{beg} и
@var{end} Вызывается функция заданная переменной
@code{font-lock-unfontify-region-function}.

@item font-lock-flush &optional beg end
Функция должна пометить подсветку региона между
@var{beg} и @var{end} как устаревшую. Если
@var{beg} и @var{end} не заданы или @code{nil},
то помечается вся доступная область буфера. Вызывается
функция заданная переменной @code{font-lock-flush-function}.

@item font-lock-ensure &optional beg end
Функция должна удостоверится что регион @var{beg}, @var{end}
подсвечен. Если @var{beg}, @var{end} не заданы
или @code{nil}, то рассматривается вся доступная область буфера.
Вызывается функция определенная переменой
@code{font-lock-ensure-function}.
@end ftable

  Несколько переменных влияют на то как Font Lock выполняет подсветку.
Но основные режимы не должны устанавливать никакие из этих
переменных напрямую, вместо этого они должны установить
@code{font-lock-defaults} как локальную для буфера переменную.
Значение этой переменой используется для установки всех
других переменных Font Lock режима.

@defvar font-lock-defaults
Переменная устанавливается режимами для настройки подсветки
текста в этих режимах. Переменная автоматически становится локальной
для буфера при задании значения. Если значение @code{nil}, то
Font Lock ничего не подсвечивает, и можно использовать
меню @samp{Faces} (Шрифты) (@samp{Edit}->@samp{Text
Properties}) (Редактировать->Свойства текста) для явного задания
шрифта текста в буфере.

Если не-@code{nil}, значение должно выглядеть как:

@example
(@var{keywords} [@var{keywords-only} [@var{case-fold}
 [@var{syntax-alist} @var{other-vars}@dots{}]]])
@end example

Первый элемент, @var{keywords}, неявно задает значение
@code{font-lock-keywords} которые направляют подсветку по поиску.
Это может быть символ (symbol), переменная или функция, значение
которое список используемый в @code{font-lock-keywords}.
Так же она может списком из нескольких таких символов, под 1 на каждый
уровень подсветки. Первый символ определяет уровень @samp{mode default}
подсветки, следующий 1 уровень, следующий 2 и т.д. 
@samp{mode default} как правило такой же как и уровень 1.
Он используется когда @code{font-lock-maximum-decoration}
имеет значение @code{nil}. @xref{Levels of Font Lock}.

Второй элемент @var{keywords-only}, определяет значение переменной
@code{font-lock-keywords-only}. Если он опущен или @code{nil}
подсветка на основе синтаксиса (строки и комментарии) выполняется.
Если не-@code{nil}, то не выполняется. @xref{Syntactic Font Lock}.

Третий элемент @var{case-fold}, определяет значение
@code{font-lock-keywords-case-fold-search}, если он
не-@code{nil}, Font Lock режим игнорирует регистр при
подсветки основанной на поиске.

Если четвертый элемент, @var{syntax-alist}, не-@code{nil},
он должен быть списком cons ячеек в форме
@code{(@var{char-or-string} . @var{string})}. Они используются
для установки синтаксической таблицы, для подсветки основанной
на синтаксисе; результирующая таблица синтаксиса загружается
в @code{font-lock-syntax-table}. Если @var{syntax-alist} пропущен
или @code{nil}, подсветка основанная на синтаксисе использует
синтаксическую таблицу возвращаемую функцией @code{syntax-table}.
@xref{Syntax Table Functions}.

Все остальные элементы (если есть) имеют общее название
@var{other-vars}. Каждый из этих элементов должен иметь
форму @code{(@var{variable} . @var{value})} -- которая означает,
что нужно сделать переменную @var{variable} локальной для буфера
и установить в значение @var{value}. Можно использовать
@var{other-vars} для установки других переменных влияющих
на подсветку, кроме рассмотренных выше 5 переменных.
Each of these elements should have the form
@xref{Other Font Lock Variables}.
@end defvar

  Если подсветка в режиме делается путем добавления
@code{font-lock-face} свойств, нужно установить @code{font-lock-defaults}
в @code{(nil t)} для выключения автоматической подсветки.
Но, это не обязательно; возможна совмещать подсветку некоторых вещей
с использованием свойств @code{font-lock-face} с автоматической
подсветки других частей текста.

@node Search-based Fontification
@subsection Search-based Fontification

Подсветка основанная на поиске.

  Переменная @code{font-lock-keywords} напрямую управляет подсветкой
основанной на поиске, которая как правило определяется через
@var{keywords} элемент в @code{font-lock-defaults}.

@defvar font-lock-keywords
Значение этой переменной это список ключевых слов для подсветки. Lisp
программы не должны устанавливать эту переменную напрямую. Как правило,
значение автоматически устанавливается режимом Font Lock, используя
@var{keywords} элемент в @code{font-lock-defaults}. Значение может
быть изменено с использованием функций @code{font-lock-add-keywords} и
@code{font-lock-remove-keywords} (@pxref{Customizing Keywords}).
@end defvar

  Каждый элемент @code{font-lock-keywords} определяет как найти
определенный текстовые конструкции, и как подсветить эти конструкции.
Font Lock обрабатывает элементы @code{font-lock-keywords} по одному, и для
каждого находятся и обрабатываются все совпадения. Как правило, если
какая-то часть была подсвечена, ее подсветка не перезаписывается,
последующими совпадениями (то есть каждый элемент текста относится к 1
элементу поиска); но можно определить и другое поведение
с использованием @var{override} элемента a @var{subexp-highlighter}.

Каждый элемент @code{font-lock-keywords} должен представляться одной
из следующих форм:

@table @code
@item @var{regexp}
Подсвечиваются все совпадение @var{regexp} шрифтом
@code{font-lock-keyword-face}.  Например,

@example
;; @r{Highlight occurrences of the word @samp{foo}}
;; @r{using @code{font-lock-keyword-face}.}
"\\<foo\\>"
@end example

Стоит аккуратно строить такие регулярные выражения; плохо
написанные шаблоны могут можно сильно замедлить работу
редактора. Функция @code{regexp-opt} (@pxref{Regexp Functions})
полезна для полезна для построения регулярного выражения
совпадающего с несколькими ключевыми словами.

@item @var{function}
Находит текст путем вызова @var{function}, и подсвечивает
найденные совпадения шрифтом @code{font-lock-keyword-face}.

Когда @var{function}, она получает 1 аргумент, ограничение
на поиск; она должна начать поиск в текущей точке, не и
искать дальше ограничения. Функция должна вернуть
не-@code{nil}, если поиск успешен, и установить результат
совпадения (не ясно каким именно образом ???, вероятно в результате)
для описания найденных совпадений. Возвращение @code{nil}
является сигналом того, что поиск ничего не дал. 

При выполнении подсветки @var{function} будет вызываться повторно
с одни и тем же ограничением в точках где закончился предыдущий вызов,
пока поиск дает результаты. В случае
неудачи @var{function} не нужно вновь переставлять точку (point, курсор).

@item (@var{matcher} . @var{subexp})
В этом типе элемента, @var{matcher} регулярное выражение или
функция, как вышеописанные.  The @sc{cdr},
@var{subexp}, определяет какое подвыражение @var{matcher} должно
быть подсвечено (вместо всего текста совпадения с @var{matcher}).

@example
;; @r{Highlight the @samp{bar} in each occurrence of @samp{fubar},}
;; @r{using @code{font-lock-keyword-face}.}
("fu\\(bar\\)" . 1)
@end example

Если использовать @code{regexp-opt} для создания регулярного выражения
@var{matcher}, можно использовать @code{regexp-opt-depth} (@pxref{Regexp
Functions}) для вычисления значения @var{subexp}.

@item (@var{matcher} . @var{facespec})
В элементе данного вида, @var{facespec} выражение чье значение
определяет шрифт используемый для подсветки.  В простейшем случае,
@var{facespec} Lisp переменная (a symbol) чье значение имя шрифта.

@example
;; @r{Highlight occurrences of @samp{fubar},}
;; @r{using the face which is the value of @code{fubar-face}.}
("fubar" . fubar-face)
@end example

Но, @var{facespec} может вычисляться в список следующей формы:

@example
(face @var{face} @var{prop1} @var{val1} @var{prop2} @var{val2}@dots{})
@end example

@noindent
Для определения шрифта @var{face} и различных дополнительных
свойств текста которые должны быть добавлена к тексту совпадения.
В этом случае нужно добавить имена дополнительных свойств в
@code{font-lock-extra-managed-props}, чтобы эти свойства очищались
когда они перестают быть актуальными. Либо можно
установить @code{font-lock-unfontify-region-function} в
функцию которая очистит такие свойства. @xref{Other Font Lock
Variables}.

@item (@var{matcher} . @var{subexp-highlighter})
В данном виде элемента, @var{subexp-highlighter} список который
определяет как подсвечивать найденные @var{matcher} совпадения.
@var{subexp-highlighter} должен иметь форму:

@example
(@var{subexp} @var{facespec} [@var{override} [@var{laxmatch}]])
@end example

@sc{car}, @var{subexp}, число определяющее какое подвыражение совпадения
подсвечивать (0 означает все совпадение). @var{facespec},
выражение которое определяет шрифт, как описывалось выше.


@var{override} и @var{laxmatch}, необязательные флаги.  Если
@var{override} @code{t}, элемент должен перезаписывать подсветку
сделанную предыдущими элементами @code{font-lock-keywords}.
Если значение @code{keep}, тогда каждый символ подсвечивается, если
он еще не был подсвечен другим элементом. Если значение @code{prepend},
шрифт определенный @var{facespec} добавляется в начало
свойства @code{font-lock-face}. Если значение @code{append},
шрифт добавляется в конец свойства @code{font-lock-face}.

Если @var{laxmatch} не-@code{nil}, означает, что не является ошибкой
отсутствие подвыражения с номером @var{subexp} в @var{matcher}.
Очевидно, подсветки при для такого выражения не будет. Но
подсветка других подвыражений (и других регулярных выражений)
продолжится. Если @var{laxmatch} и @code{nil} и подвыражение
отсутствует, тогда сообщается об ошибке и выполнение
подсветки основанной на поиске заканчивается.

Ниже несколько примеров элементов данного вида:

@smallexample
;; @r{Highlight occurrences of either @samp{foo} or @samp{bar}, using}
;; @r{@code{foo-bar-face}, even if they have already been highlighted.}
;; @r{@code{foo-bar-face} should be a variable whose value is a face.}
("foo\\|bar" 0 foo-bar-face t)

;; @r{Highlight the first subexpression within each occurrence}
;; @r{that the function @code{fubar-match} finds,}
;; @r{using the face which is the value of @code{fubar-face}.}
(fubar-match 1 fubar-face)
@end smallexample

@item (@var{matcher} . @var{anchored-highlighter})
В данном виде элемента, @var{anchored-highlighter} определяет
как подсвечивать текст который следует за совпадением найденным
@var{matcher}. То есть совпадение найденное по @var{matcher}, выступает
в виде отправной точки (якоря) для дальнейшего поиска заданного
@var{anchored-highlighter}. @var{anchored-highlighter} это
список следующей формы:

@example
(@var{anchored-matcher} @var{pre-form} @var{post-form}
                        @var{subexp-highlighters}@dots{})
@end example

Где, @var{anchored-matcher}, как @var{matcher}, регулярное
выражение или функция.  После нахождение совпадения @var{matcher},
курсор(точка) в конце совпадения.  Теперь, Font Lock вычисляет
@var{pre-form}.  Затем ищет совпадения  для
@var{anchored-matcher} и использует @var{subexp-highlighters} для подсветки.
@var{subexp-highlighter} описано выше.  В завершении,
Font Lock вычисляет @var{post-form}.

Форма @var{pre-form} и @var{post-form} могут быть использованы для
инициализации до и очистки после @var{anchored-matcher}. Как правило,
@var{pre-form} используется для перемещения курсора на позицию
относительно совпадения @var{matcher}, до того как начать поиск
@var{anchored-matcher}. @var{post-form} может быть
использована для возврата курсора перед продолжением поиска
@var{matcher}.

После того как Font Lock вычислит @var{pre-form},
@var{anchored-matcher} не ищет дальше окончания строки. Но если
@var{pre-form} вернет позицию в буфере больше чем позиция
курсора после вычисления @var{pre-form}, тогда возвращенная
@var{pre-form} позиция используется в качестве ограничения поиска.
Как правило не стоит возвращать позицию дальше окончания строк,
то есть не стоит делать чтобы @var{anchored-matcher} переходила
на другую строку.

Например,

@smallexample
;; @r{Highlight occurrences of the word @samp{item} following}
;; @r{an occurrence of the word @samp{anchor} (on the same line)}
;; @r{in the value of @code{item-face}.}
("\\<anchor\\>" "\\<item\\>" nil nil (0 item-face))
@end smallexample

В примере, @var{pre-form} и @var{post-form} are @code{nil}.  Поэтому
поиск @samp{item} начинается в конце поиска
@samp{anchor}, и поиск последующих совпадений @samp{anchor}
продолжается там где завершился поиск @samp{item}.

@item (@var{matcher} @var{highlighters}@dots{})
Данный вид элемента определят несколько список @var{highlighter}
подсветки для одного @var{matcher}. @var{highlighter} может
быть типа @var{subexp-highlighter} или @var{anchored-highlighter}
которые описаны выше.

Например,

@smallexample
;; @r{Highlight occurrences of the word @samp{anchor} in the value}
;; @r{of @code{anchor-face}, and subsequent occurrences of the word}
;; @r{@samp{item} (on the same line) in the value of @code{item-face}.}
("\\<anchor\\>" (0 anchor-face)
                ("\\<item\\>" nil nil (0 item-face)))
@end smallexample

@item (eval . @var{form})
Здесь @var{form}  выражение которое должно быть вычислено
при первом использовании @code{font-lock-keywords} в буфере.
Значением должно быть одна из форм описанных в таблице.
@end table

@strong{Warning:} Не стоит проектировать элемент
@code{font-lock-keywords} для совпадения с текстом который переходит
через строку, так как такие элементы работают не надежно см.
@xref{Multiline Font Lock}.

Можно использовать @var{case-fold} в @code{font-lock-defaults}
для задания @code{font-lock-keywords-case-fold-search},
который указывает должна ли подсветка выполнятся с игнорированием
регистра.

@defvar font-lock-keywords-case-fold-search
Не-@code{nil} означает, что поиск регулярных выражений
@code{font-lock-keywords} должен выполняться без
учета регистра.
@end defvar

@node Customizing Keywords
@subsection Customizing Search-Based Fontification

  Настройка ключевых слов.

  Можно использовать @code{font-lock-add-keywords} для добавления
правил подсветки основанной на поиске в основной режим,
и @code{font-lock-remove-keywords}, для удаления
правил.

@defun font-lock-add-keywords mode keywords &optional how
Функция добавляет @var{keywords} для подсветки, для текущего
буфера или для основного режима @var{mode}. Аргумент @var{keywords}
должен быть списком с тем же форматом, что и
@code{font-lock-keywords}.

Если @var{mode} символ команды основного режима, как
@code{c-mode}, при включении Font Lock в @var{mode},
@var{keywords} будут добавлены в @code{font-lock-keywords}.
Вызов с не-@code{nil} значением @var{mode} верно, только
в @file{~/.emacs}.

Если @var{mode} @code{nil}, функция добавляет @var{keywords} в
@code{font-lock-keywords} текущего буфера.  Такой способ вызова
@code{font-lock-add-keywords} как правило используется в перехватчиках
режимов.

По умолчанию, @var{keywords} добавляются в начало
@code{font-lock-keywords}.  Если необязательный аргумент @var{how}
равен @code{set}, то значения @code{font-lock-keywords} заменяются.
Если @var{how} любое другое не-@code{nil} значение, то @var{keywords}
добавляются в конец @code{font-lock-keywords}.

Некоторые режимы предоставляют дополнительные возможности которые
можно использовать для подсветки.  Например переменные
@code{c-font-lock-extra-types}, @code{c++-font-lock-extra-types},
@code{java-font-lock-extra-types}.

@strong{Warning:} Команда основного режима не должна вызывать даже не
явно @code{font-lock-add-keywords}, кроме как через перехватчик
режима. (Так как это приведет к некорректному поведению некоторых
дополнительных режимов.) Основной режим должен задавать правила
подсветки основанной на поиске через @code{font-lock-keywords}.
@end defun

@defun font-lock-remove-keywords mode keywords
Функция удаляет @var{keywords} из @code{font-lock-keywords} для
текущего буфера или основного режима @var{mode}.  Как и в
@code{font-lock-add-keywords}, @var{mode} должно быть командой
основного режима или @code{nil}.  Все предупреждения и требования для
@code{font-lock-add-keywords} применимы и для этой функций.  Аргумент
@var{keywords} должны точно совпадать с теми который использовались в
@code{font-lock-add-keywords}.
@end defun

  Например, следующий код добавляет два шаблона подсветки для C
режима: один подсвечивает @samp{FIXME}, даже в комментария, и другой
подсвечивает @samp{and}, @samp{or} и @samp{not} как ключевые слова.

@smallexample
(font-lock-add-keywords 'c-mode
 '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
   ("\\<\\(and\\|or\\|not\\)\\>" . font-lock-keyword-face)))
@end smallexample

@noindent
Данный пример влияет только на C режим. Для добавления этого
шаблона в C режим @emph{and} (и) все его дочерние режимы, нужно:

@smallexample
(add-hook 'c-mode-hook
 (lambda ()
  (font-lock-add-keywords nil
   '(("\\<\\(FIXME\\):" 1 font-lock-warning-face prepend)
     ("\\<\\(and\\|or\\|not\\)\\>" .
      font-lock-keyword-face)))))
@end smallexample

@node Other Font Lock Variables
@subsection Other Font Lock Variables

Другие переменные режима Font Lock.

  Данный раздел описывает другие переменные, которые основной режим
может установить с помощью @var{other-vars} в
@code{font-lock-defaults} (@pxref{Font Lock Basics}).

@defvar font-lock-mark-block-function
Если значение не-@code{nil}, то оно должно быть функцией, вызываемой
без аргументов, и которая выбирает объемлющий регион текста, дял
пересчета подсветки по команде @kbd{M-o M-o}
(@code{font-lock-fontify-block}).

Функция сообщает о выборе путем размещения региона.  Регион нужно
выбрать так, чтобы пересчет подсветки дал хороший результат, но при
этом он не должен быть настолько большим, чтобы пересчет был
долгим. Обычно используется @code{mark-defun} для режимов
программирования или @code{mark-paragraph} для текстовых режимов.
@end defvar

@defvar font-lock-extra-managed-props
Переменная определяет дополнительные свойства (не те что
@code{font-lock-face}), которые должны контролироваться режимом Font
Lock. Значение используется @code{font-lock-default-unfontify-region},
которая иначе контролирует только @code{font-lock-face}
свойства. Дополнительные свойства для можно задавать как через
@var{facespec} в @code{font-lock-keywords}, так и добавляя их в список
данной переменной.  @xref{Search-based Fontification}.
@end defvar

@defvar font-lock-fontify-buffer-function
Функция для подсветки буфера. Значение по умолчанию
@code{font-lock-default-fontify-buffer}.
@end defvar

@defvar font-lock-unfontify-buffer-function
Функция для очистки подсветки буфера. Используется при выключении Font
Lock режима. Значение по умолчанию
@code{font-lock-default-unfontify-buffer}.
@end defvar

@defvar font-lock-fontify-region-function
Функция используется для подсветки региона. Функция должна принимать
два аргумента, начала и конца региона, и необязательный третий
аргумент @var{verbose}. Если @var{verbose} не-@code{nil}, функция
должна печатать статусное сообщение. Значение по умолчанию
@code{font-lock-default-fontify-region}.
@end defvar

@defvar font-lock-unfontify-region-function
Функция используется для снятия подсветки с региона. Должна получать 2
параметр начало и конец регион. Значение по умолчанию
@code{font-lock-default-unfontify-region}.
@end defvar

@defvar font-lock-flush-function
Функция используется для того, чтобы пометить, что подсветка регион
устарела. Должна получать 2 параметр начала и конец региона. Значение
по умолчанию @code{font-lock-after-change-function}.
@end defvar

@defvar font-lock-ensure-function
Функция гарантирует что подсветка региона буфера выполнена.
Должна получать 2 параметра начало и конце региона. Значение
по умолчанию вызывает @code{font-lock-default-fontify-buffer}
если подсветки в буфере нет; в результате выполняется
подсветка доступной части буфера.
@end defvar

@defun jit-lock-register function &optional contextual
Функция предписывает Font Lock режиму запускать 
@var{function} всегда когда делается или обновляется подсветка.
@var{function} вызывается до вызова основной функции подсветки,
и получает 2 аргумента @var{start} и @var{end} региона, для
которого выполняется подсветка.

Не обязательный аргумент @var{contextual}, если не-@code{nil},
предписывает Font Lock режиму всегда обновлять подсветку (основываясь
на синтаксисе) соответствующей части буфера, а не только измененных
строк. Аргумент как правило опускается.
@end defun

@defun jit-lock-unregister function
Если @var{function} была добавлена с использованием @code{jit-lock-register},
то эта функция выполняет обратное действие и убирает выполнение @var{function}.
@end defun

@node Levels of Font Lock
@subsection Levels of Font Lock

  Уровни Font Lock режима.

  Некоторые основные режимы поддерживают три уровня подсветки. Уровни
можно определять используя список символов в @var{keywords} в
@code{font-lock-defaults}. Каждый уровень определяет один уровень
подсветки; пользователь может выбрать один из уровней задавая
@code{font-lock-maximum-decoration} (@pxref{Font Lock,,, emacs, the
GNU Emacs Manual}). Выбранный символ используется для инициализации
@code{font-lock-keywords}.

  Ниже описаны соглашения по определению уровней подсветки:

@itemize @bullet
@item
Уровень 1: (level 1) подсветка определений функций, файловых директив
(include, import и другие), строки и комментарии.  Данный уровень
должен быт максимально быстрым, поэтому подсвечиваются только наиболее
важные компоненты.

@item
Уровень 2: (level 2) в дополнение к уровню 1, подсвечиваются все
ключевые слова языка программирования и значения именованных
констант. Цель данного режима подсветить ключевые слова
(синтаксические или семантические).

@item
Уровень 3: (level 3) в дополнение к уровню 2, подсвечивает символы
которые определены в определениях функций и переменных, и имена всех
встроенных функций.
@end itemize

@node Precalculated Fontification
@subsection Precalculated Fontification

  Предварительно посчитанная подсветка.

  Некоторые основные режимы, такие как @code{list-buffers} и
@code{occur} создают текст буфера программно. И в них проще
поддерживать Font Lock режим, если определять шрифты текста в момент
вставки текста в буфер.

  Это можно сделать путем определения шрифтов в тексте используя
свойство текста  @code{font-lock-face} (@pxref{Special
Properties}). Когда режим Font Lock активен, данное свойство
задает подсветку(отображение), как свойство @code{face}, если же
режим Font Lock отключен свойство @code{font-lock-face} никак
не влияет на отображение.

  В режиме можно использовать @code{font-lock-face} для части текста
совмещая с использованием обычных механизмов Font Lock режима. Но если
режим не использует обычные механизмы, он не должен задавать
@code{font-lock-defaults}.

@node Faces for Font Lock
@subsection Faces for Font Lock
@cindex faces for font lock
@cindex font lock faces

  Шрифты для Font Lock режима.

  Font Lock режим может выполнять подсветку используя любые шрифты, но
в Emacs определено несколько шрифтов специально для Font Lock. Эти
шрифты @dfn{Font Lock faces} рассматриваются ниже. Данные шрифты могут
использоваться основными режимами для синтаксической подсветки
(выделения) вне Font Lock режима (@pxref{Major Mode Conventions}).

 Каждый из рассматриваемых символов является именем шрифта и именем
переменной значением по умолчанию которой является сам символ.  Таким
образом, значением по умолчанию @code{font-lock-comment-face} является
@code{font-lock-comment-face}.

  Шрифты перечислены с описанием их назначения, и упорядочены в
порядке их заметности (prominence) от большего к меньшему. Если
синтаксические категории в режиме не соответствуют описанным
назначениям, можно использовать описанный порядок в качестве
руководства при назначении шрифтов.

@table @code
@item font-lock-warning-face
@vindex font-lock-warning-face
используется для необычных конструкций, или таких которые сильно
изменяют значение другого текста, такие как @samp{;;;###autoload} в
Emacs Lisp и @samp{#error} в C.

@item font-lock-function-name-face
@vindex font-lock-function-name-face
для определений и объявлений функций.

@item font-lock-variable-name-face
@vindex font-lock-variable-name-face
для определений и объявлений переменных.

@item font-lock-keyword-face
@vindex font-lock-keyword-face
для ключевых слов имеющих синтаксическое значение, например @samp{for} и
@samp{if} в C.

@item font-lock-comment-face
@vindex font-lock-comment-face
для комментариев.

@item font-lock-comment-delimiter-face
@vindex font-lock-comment-delimiter-face
для разделителей комментариев, например @samp{/*} и @samp{*/} в C@. Как правило
наследуется от @code{font-lock-comment-face}.

@item font-lock-type-face
@vindex font-lock-type-face
для имен пользовательских типов.

@item font-lock-constant-face
@vindex font-lock-constant-face
для имен констант, например @samp{NULL} в C.

@item font-lock-builtin-face
@vindex font-lock-builtin-face
для имен встроенных функций.

@item font-lock-preprocessor-face
@vindex font-lock-preprocessor-face
для команд препроцессора. Как правило, наследуется от
@code{font-lock-builtin-face}.

@item font-lock-string-face
@vindex font-lock-string-face
для строковых констант.

@item font-lock-doc-face
@vindex font-lock-doc-face
для строк документации в коде. Как правило наследуется от
@code{font-lock-string-face}.

@item font-lock-negation-char-face
@vindex font-lock-negation-char-face
для легко пропускаемых (видимо имеется ввиду не заметных)
символов отрицания.
@end table

@node Syntactic Font Lock
@subsection Syntactic Font Lock
@cindex syntactic font lock

 Подсветка основанная на синтаксисе (далее синтаксическая подсветка).

 Подсветка по синтаксису использует таблицу синтаксиса (@pxref{Syntax
Tables}) для нахождения и подсветки синтаксически значимого
текста. Если такая подсветка активна, она выполняется после подсветки
поиском. Переменная @code{font-lock-syntactic-face-function} описанная
ниже, определяет синтаксические конструкции для
подсветки. Предусмотрено несколько переменных для управления
синтаксической подсветкой. Устанавливать их нужно с использованием
@code{font-lock-defaults} (@pxref{Font Lock Basics}).


  Когда, Font Lock выполняет синтаксическую подсветку части текста,
первым делом вызывается функция задаваемая @code{syntax-propertize-function}.
Основные режимы могут использовать ее для применения 
@code{syntax-table}, чтобы переписать таблицу синтаксиса буфера,
если необходимо.  @xref{Syntax Properties}.

@defvar font-lock-keywords-only
Если значение переменной не-@code{nil}, Font Lock не выполняет
синтаксическую подсветку, только подсветку основанную на поиске по
@code{font-lock-keywords}. Обычно значение переменной устанавливается
Font Lock режимом по элементу @var{keywords-only} из
@code{font-lock-defaults}.
@end defvar

@defvar font-lock-syntax-table
Переменная хранит таблицу синтаксиса, используемую для подсветки
комментариев и строк. Обычно значение переменной устанавливается на
основе элемента @var{syntax-alist} из @code{font-lock-defaults}. Если
значение @code{nil}, синтаксическая подсветка использует синтаксическую
таблицу буфера (значение возвращается функцией @code{syntax-table}; @pxref{Syntax
Table Functions}).
@end defvar

@defvar font-lock-syntactic-face-function
Если значение не-@code{nil}, то оно должно быть функцией которая
определяет какой шрифт нужно использовать для данного элемента (может быть строка
или комментарий). Обычно значение устанавливается через  @var{other-vars} из
@code{font-lock-defaults}.

Функция вызывается с 1 аргументов, состоянием разбора в точке,
возвращаемого @code{parse-partial-sexp}, и должна возвращать шрифт.
По умолчанию используются @code{font-lock-comment-face} fдля
комментариев @code{font-lock-string-face} для строк (@pxref{Faces for
Font Lock}).
@end defvar

@node Multiline Font Lock
@subsection Multiline Font Lock Constructs
@cindex multiline font lock

  Подсветка много-строчных конструкций.
  
  Как правило, элементы @code{font-lock-keywords}, не должны выдавать
совпадений с переводом строки; они работают не корректно, потому
что Font Lock обычно обрабатывает только часть буфера, и может пропустить
много-строчную конструкцию которая находится на пересечении границ
сканирования.  (Как правило сканирование начинается с начала строки).

  Создание элементов, которые совпадают с много-строчными конструкция
и работают корректно требует: 1. правильных @emph{identification} (определения)
и 2. правильного @emph{rehighlighting} (обновления подсветки).
Первое требует, чтобы Font Lock находил все много-строчные конструкции.
Второе требует, чтобы Font Lock верно обновлял подсветку всего текста
имеющего отношение к конструкции, при изменении таких конструкций ---
например, если часть текста, которая была частью много-строчной конструкции
перестал быть ее частью. Эти два аспекта сильно связаны, и как правило
реализация одного из них, приводит к работе второго. Но, нужно проверить
оба.

  Есть 3 способа, удостоверится в корректной идентификации много-строчных
конструкций:

@itemize
@item
Добавить функцию в  @code{font-lock-extend-region-functions} которая
выполнит @emph{identification} (идентификацию) и расширит область сканирования
так, чтобы сканируемый текст, никогда не начинался или закачивался внутри
много-строчной конструкции.
@item
Использовать перехватчик @code{font-lock-fontify-region-function}
для расширения области сканирования, аналогично предыдущему пункту.
@item
Каким-то образом выполнять идентификацию много строчной конструкции
при добавлении в буфер (до того как font-lock попробует выполнить его
подсветку), и помечать ее @code{font-lock-multiline}, который будет
указывать font-lock, что не нужно начинать или останавливать сканирование
внутри этой конструкции.
@end itemize

  Есть 3 способа, обновить подсветку много-строчных конструкций:

@itemize
@item
Поместить @code{font-lock-multiline} свойство на конструкцию. Что
приведет к обновлению подсветки всей конструкции если любая ее часть
изменится. В некоторых случаях это можно сделать автоматически,
установкой переменной @code{font-lock-multiline},  (which see ??)
@item
Проверить, что @code{jit-lock-contextually} установлена и доверить
ей такую работу. Она будет выполнять обновление части конструкции
которая связана с произведенными изменениями, и выполняется с
небольшой задержкой. Такой способ работает, только если
подсветка разных частей много-строчной конструкции не зависит
от следующих строк. Так как @code{jit-lock-contextually} активно
по умолчанию, данное решение может быть удобным.
@item
Поместить @code{jit-lock-defer-multiline} свойство на конструкцию.
Данный способ работает только если используется @code{jit-lock-contextually}
и с некоторой задержкой перед обновлением подсветки, но как и
@code{font-lock-multiline} он работает в ситуации когда подсветка зависит от
следующих строк.

(Под следующими строками возможно подразумеваются внутренние строки
конструкции).
@end itemize

@menu
* Font Lock Multiline::         Marking multiline chunks with a text property.
* Region to Refontify::         Controlling which region gets refontified
                                  after a buffer change.
@end menu

@node Font Lock Multiline
@subsubsection Font Lock Multiline

  One way to ensure reliable rehighlighting of multiline Font Lock
constructs is to put on them the text property @code{font-lock-multiline}.
It should be present and non-@code{nil} for text that is part of a
multiline construct.

  When Font Lock is about to highlight a range of text, it first
extends the boundaries of the range as necessary so that they do not
fall within text marked with the @code{font-lock-multiline} property.
Then it removes any @code{font-lock-multiline} properties from the
range, and highlights it.  The highlighting specification (mostly
@code{font-lock-keywords}) must reinstall this property each time,
whenever it is appropriate.

  @strong{Warning:} don't use the @code{font-lock-multiline} property
on large ranges of text, because that will make rehighlighting slow.

@defvar font-lock-multiline
If the @code{font-lock-multiline} variable is set to @code{t}, Font
Lock will try to add the @code{font-lock-multiline} property
automatically on multiline constructs.  This is not a universal
solution, however, since it slows down Font Lock somewhat.  It can
miss some multiline constructs, or make the property larger or smaller
than necessary.

For elements whose @var{matcher} is a function, the function should
ensure that submatch 0 covers the whole relevant multiline construct,
even if only a small subpart will be highlighted.  It is often just as
easy to add the @code{font-lock-multiline} property by hand.
@end defvar

  The @code{font-lock-multiline} property is meant to ensure proper
refontification; it does not automatically identify new multiline
constructs.  Identifying the requires that Font Lock mode operate on
large enough chunks at a time.  This will happen by accident on many
cases, which may give the impression that multiline constructs magically
work.  If you set the @code{font-lock-multiline} variable
non-@code{nil}, this impression will be even stronger, since the
highlighting of those constructs which are found will be properly
updated from then on.  But that does not work reliably.

  To find multiline constructs reliably, you must either manually place
the @code{font-lock-multiline} property on the text before Font Lock
mode looks at it, or use @code{font-lock-fontify-region-function}.

@node Region to Refontify
@subsubsection Region to Fontify after a Buffer Change

  When a buffer is changed, the region that Font Lock refontifies is
by default the smallest sequence of whole lines that spans the change.
While this works well most of the time, sometimes it doesn't---for
example, when a change alters the syntactic meaning of text on an
earlier line.

  You can enlarge (or even reduce) the region to refontify by setting
the following variable:

@defvar font-lock-extend-after-change-region-function
This buffer-local variable is either @code{nil} or a function for Font
Lock mode to call to determine the region to scan and fontify.

The function is given three parameters, the standard @var{beg},
@var{end}, and @var{old-len} from @code{after-change-functions}
(@pxref{Change Hooks}).  It should return either a cons of the
beginning and end buffer positions (in that order) of the region to
fontify, or @code{nil} (which means choose the region in the standard
way).  This function needs to preserve point, the match-data, and the
current restriction.  The region it returns may start or end in the
middle of a line.

Since this function is called after every buffer change, it should be
reasonably fast.
@end defvar

@node Auto-Indentation
@section Automatic Indentation of code

For programming languages, an important feature of a major mode is to
provide automatic indentation.  There are two parts: one is to decide what
is the right indentation of a line, and the other is to decide when to
reindent a line.  By default, Emacs reindents a line whenever you
type a character in @code{electric-indent-chars}, which by default only
includes Newline.  Major modes can add chars to @code{electric-indent-chars}
according to the syntax of the language.

Deciding what is the right indentation is controlled in Emacs by
@code{indent-line-function} (@pxref{Mode-Specific Indent}).  For some modes,
the @emph{right} indentation cannot be known reliably, typically because
indentation is significant so several indentations are valid but with different
meanings.  In that case, the mode should set @code{electric-indent-inhibit} to
make sure the line is not constantly re-indented against the user's wishes.

Writing a good indentation function can be difficult and to a large extent it
is still a black art.  Many major mode authors will start by writing a simple
indentation function that works for simple cases, for example by comparing with
the indentation of the previous text line.  For most programming languages that
are not really line-based, this tends to scale very poorly: improving
such a function to let it handle more diverse situations tends to become more
and more difficult, resulting in the end with a large, complex, unmaintainable
indentation function which nobody dares to touch.

A good indentation function will usually need to actually parse the
text, according to the syntax of the language.  Luckily, it is not
necessary to parse the text in as much detail as would be needed
for a compiler, but on the other hand, the parser embedded in the
indentation code will want to be somewhat friendly to syntactically
incorrect code.

Good maintainable indentation functions usually fall into two categories:
either parsing forward from some safe starting point until the
position of interest, or parsing backward from the position of interest.
Neither of the two is a clearly better choice than the other: parsing
backward is often more difficult than parsing forward because
programming languages are designed to be parsed forward, but for the
purpose of indentation it has the advantage of not needing to
guess a safe starting point, and it generally enjoys the property
that only a minimum of text will be analyzed to decide the indentation
of a line, so indentation will tend to be less affected by syntax errors in
some earlier unrelated piece of code.  Parsing forward on the other hand
is usually easier and has the advantage of making it possible to
reindent efficiently a whole region at a time, with a single parse.

Rather than write your own indentation function from scratch, it is
often preferable to try and reuse some existing ones or to rely
on a generic indentation engine.  There are sadly few such
engines.  The CC-mode indentation code (used with C, C++, Java, Awk
and a few other such modes) has been made more generic over the years,
so if your language seems somewhat similar to one of those languages,
you might try to use that engine.  @c FIXME: documentation?
Another one is SMIE which takes an approach in the spirit
of Lisp sexps and adapts it to non-Lisp languages.

@menu
* SMIE::                        A simple minded indentation engine.
@end menu

@node SMIE
@subsection Simple Minded Indentation Engine
@cindex SMIE

SMIE is a package that provides a generic navigation and indentation
engine.  Based on a very simple parser using an operator precedence
grammar, it lets major modes extend the sexp-based navigation of Lisp
to non-Lisp languages as well as provide a simple to use but reliable
auto-indentation.

Operator precedence grammar is a very primitive technology for parsing
compared to some of the more common techniques used in compilers.
It has the following characteristics: its parsing power is very limited,
and it is largely unable to detect syntax errors, but it has the
advantage of being algorithmically efficient and able to parse forward
just as well as backward.  In practice that means that SMIE can use it
for indentation based on backward parsing, that it can provide both
@code{forward-sexp} and @code{backward-sexp} functionality, and that it
will naturally work on syntactically incorrect code without any extra
effort.  The downside is that it also means that most programming
languages cannot be parsed correctly using SMIE, at least not without
resorting to some special tricks (@pxref{SMIE Tricks}).

@menu
* SMIE setup::                  SMIE setup and features.
* Operator Precedence Grammars::  A very simple parsing technique.
* SMIE Grammar::                Defining the grammar of a language.
* SMIE Lexer::                  Defining tokens.
* SMIE Tricks::                 Working around the parser's limitations.
* SMIE Indentation::            Specifying indentation rules.
* SMIE Indentation Helpers::    Helper functions for indentation rules.
* SMIE Indentation Example::    Sample indentation rules.
* SMIE Customization::          Customizing indentation.
@end menu

@node SMIE setup
@subsubsection SMIE Setup and Features

SMIE is meant to be a one-stop shop for structural navigation and
various other features which rely on the syntactic structure of code, in
particular automatic indentation.  The main entry point is
@code{smie-setup} which is a function typically called while setting
up a major mode.

@defun smie-setup grammar rules-function &rest keywords
Setup SMIE navigation and indentation.
@var{grammar} is a grammar table generated by @code{smie-prec2->grammar}.
@var{rules-function} is a set of indentation rules for use on
@code{smie-rules-function}.
@var{keywords} are additional arguments, which can include the following
keywords:
@itemize
@item
@code{:forward-token} @var{fun}: Specify the forward lexer to use.
@item
@code{:backward-token} @var{fun}: Specify the backward lexer to use.
@end itemize
@end defun

Calling this function is sufficient to make commands such as
@code{forward-sexp}, @code{backward-sexp}, and @code{transpose-sexps} be
able to properly handle structural elements other than just the paired
parentheses already handled by syntax tables.  For example, if the
provided grammar is precise enough, @code{transpose-sexps} can correctly
transpose the two arguments of a @code{+} operator, taking into account
the precedence rules of the language.

Calling @code{smie-setup} is also sufficient to make TAB indentation work in
the expected way, extends @code{blink-matching-paren} to apply to
elements like @code{begin...end}, and provides some commands that you
can bind in the major mode keymap.

@deffn Command smie-close-block
This command closes the most recently opened (and not yet closed) block.
@end deffn

@deffn Command smie-down-list &optional arg
This command is like @code{down-list} but it also pays attention to
nesting of tokens other than parentheses, such as @code{begin...end}.
@end deffn

@node Operator Precedence Grammars
@subsubsection Operator Precedence Grammars

SMIE's precedence grammars simply give to each token a pair of
precedences: the left-precedence and the right-precedence.  We say
@code{T1 < T2} if the right-precedence of token @code{T1} is less than
the left-precedence of token @code{T2}.  A good way to read this
@code{<} is as a kind of parenthesis: if we find @code{... T1 something
T2 ...}  then that should be parsed as @code{... T1 (something T2 ...}
rather than as @code{... T1 something) T2 ...}.  The latter
interpretation would be the case if we had @code{T1 > T2}.  If we have
@code{T1 = T2}, it means that token T2 follows token T1 in the same
syntactic construction, so typically we have @code{"begin" = "end"}.
Such pairs of precedences are sufficient to express left-associativity
or right-associativity of infix operators, nesting of tokens like
parentheses and many other cases.

@c Let's leave this undocumented to leave it more open for change!
@c @defvar smie-grammar
@c The value of this variable is an alist specifying the left and right
@c precedence of each token.  It is meant to be initialized by using one of
@c the functions below.
@c @end defvar

@defun smie-prec2->grammar table
This function takes a @emph{prec2} grammar @var{table} and returns an
alist suitable for use in @code{smie-setup}.  The @emph{prec2}
@var{table} is itself meant to be built by one of the functions below.
@end defun

@defun smie-merge-prec2s &rest tables
This function takes several @emph{prec2} @var{tables} and merges them
into a new @emph{prec2} table.
@end defun

@defun smie-precs->prec2 precs
This function builds a @emph{prec2} table from a table of precedences
@var{precs}.  @var{precs} should be a list, sorted by precedence (for
example @code{"+"} will come before @code{"*"}), of elements of the form
@code{(@var{assoc} @var{op} ...)}, where each @var{op} is a token that
acts as an operator; @var{assoc} is their associativity, which can be
either @code{left}, @code{right}, @code{assoc}, or @code{nonassoc}.
All operators in a given element share the same precedence level
and associativity.
@end defun

@defun smie-bnf->prec2 bnf &rest resolvers
This function lets you specify the grammar using a BNF notation.
It accepts a @var{bnf} description of the grammar along with a set of
conflict resolution rules @var{resolvers}, and
returns a @emph{prec2} table.

@var{bnf} is a list of nonterminal definitions of the form
@code{(@var{nonterm} @var{rhs1} @var{rhs2} ...)} where each @var{rhs}
is a (non-empty) list of terminals (aka tokens) or non-terminals.

Not all grammars are accepted:
@itemize
@item
An @var{rhs} cannot be an empty list (an empty list is never needed,
since SMIE allows all non-terminals to match the empty string anyway).
@item
An @var{rhs} cannot have 2 consecutive non-terminals: each pair of
non-terminals needs to be separated by a terminal (aka token).
This is a fundamental limitation of operator precedence grammars.
@end itemize

Additionally, conflicts can occur:
@itemize
@item
The returned @emph{prec2} table holds constraints between pairs of tokens, and
for any given pair only one constraint can be present: T1 < T2,
T1 = T2, or T1 > T2.
@item
A token can be an @code{opener} (something similar to an open-paren),
a @code{closer} (like a close-paren), or @code{neither} of the two
(e.g., an infix operator, or an inner token like @code{"else"}).
@end itemize

Precedence conflicts can be resolved via @var{resolvers}, which
is a list of @emph{precs} tables (see @code{smie-precs->prec2}): for
each precedence conflict, if those @code{precs} tables
specify a particular constraint, then the conflict is resolved by using
this constraint instead, else a conflict is reported and one of the
conflicting constraints is picked arbitrarily and the others are
simply ignored.
@end defun

@node SMIE Grammar
@subsubsection Defining the Grammar of a Language
@cindex SMIE grammar
@cindex grammar, SMIE

The usual way to define the SMIE grammar of a language is by
defining a new global variable that holds the precedence table by
giving a set of BNF rules.
For example, the grammar definition for a small Pascal-like language
could look like:
@example
@group
(require 'smie)
(defvar sample-smie-grammar
  (smie-prec2->grammar
   (smie-bnf->prec2
@end group
@group
    '((id)
      (inst ("begin" insts "end")
            ("if" exp "then" inst "else" inst)
            (id ":=" exp)
            (exp))
      (insts (insts ";" insts) (inst))
      (exp (exp "+" exp)
           (exp "*" exp)
           ("(" exps ")"))
      (exps (exps "," exps) (exp)))
@end group
@group
    '((assoc ";"))
    '((assoc ","))
    '((assoc "+") (assoc "*")))))
@end group
@end example

@noindent
A few things to note:

@itemize
@item
The above grammar does not explicitly mention the syntax of function
calls: SMIE will automatically allow any sequence of sexps, such as
identifiers, balanced parentheses, or @code{begin ... end} blocks
to appear anywhere anyway.
@item
The grammar category @code{id} has no right hand side: this does not
mean that it can match only the empty string, since as mentioned any
sequence of sexps can appear anywhere anyway.
@item
Because non terminals cannot appear consecutively in the BNF grammar, it
is difficult to correctly handle tokens that act as terminators, so the
above grammar treats @code{";"} as a statement @emph{separator} instead,
which SMIE can handle very well.
@item
Separators used in sequences (such as @code{","} and @code{";"} above)
are best defined with BNF rules such as @code{(foo (foo "separator" foo) ...)}
which generate precedence conflicts which are then resolved by giving
them an explicit @code{(assoc "separator")}.
@item
The @code{("(" exps ")")} rule was not needed to pair up parens, since
SMIE will pair up any characters that are marked as having paren syntax
in the syntax table.  What this rule does instead (together with the
definition of @code{exps}) is to make it clear that @code{","} should
not appear outside of parentheses.
@item
Rather than have a single @emph{precs} table to resolve conflicts, it is
preferable to have several tables, so as to let the BNF part of the
grammar specify relative precedences where possible.
@item
Unless there is a very good reason to prefer @code{left} or
@code{right}, it is usually preferable to mark operators as associative,
using @code{assoc}.  For that reason @code{"+"} and @code{"*"} are
defined above as @code{assoc}, although the language defines them
formally as left associative.
@end itemize

@node SMIE Lexer
@subsubsection Defining Tokens
@cindex SMIE lexer
@cindex defining tokens, SMIE

SMIE comes with a predefined lexical analyzer which uses syntax tables
in the following way: any sequence of characters that have word or
symbol syntax is considered a token, and so is any sequence of
characters that have punctuation syntax.  This default lexer is
often a good starting point but is rarely actually correct for any given
language.  For example, it will consider @code{"2,+3"} to be composed
of 3 tokens: @code{"2"}, @code{",+"}, and @code{"3"}.

To describe the lexing rules of your language to SMIE, you need
2 functions, one to fetch the next token, and another to fetch the
previous token.  Those functions will usually first skip whitespace and
comments and then look at the next chunk of text to see if it
is a special token.  If so it should skip the token and
return a description of this token.  Usually this is simply the string
extracted from the buffer, but it can be anything you want.
For example:
@example
@group
(defvar sample-keywords-regexp
  (regexp-opt '("+" "*" "," ";" ">" ">=" "<" "<=" ":=" "=")))
@end group
@group
(defun sample-smie-forward-token ()
  (forward-comment (point-max))
  (cond
   ((looking-at sample-keywords-regexp)
    (goto-char (match-end 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-forward "w_")
              (point))))))
@end group
@group
(defun sample-smie-backward-token ()
  (forward-comment (- (point)))
  (cond
   ((looking-back sample-keywords-regexp (- (point) 2) t)
    (goto-char (match-beginning 0))
    (match-string-no-properties 0))
   (t (buffer-substring-no-properties
       (point)
       (progn (skip-syntax-backward "w_")
              (point))))))
@end group
@end example

Notice how those lexers return the empty string when in front of
parentheses.  This is because SMIE automatically takes care of the
parentheses defined in the syntax table.  More specifically if the lexer
returns @code{nil} or an empty string, SMIE tries to handle the corresponding
text as a sexp according to syntax tables.

@node SMIE Tricks
@subsubsection Living With a Weak Parser

The parsing technique used by SMIE does not allow tokens to behave
differently in different contexts.  For most programming languages, this
manifests itself by precedence conflicts when converting the
BNF grammar.

Sometimes, those conflicts can be worked around by expressing the
grammar slightly differently.  For example, for Modula-2 it might seem
natural to have a BNF grammar that looks like this:

@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (cases (cases "|" cases)
         (caselabel ":" insts)
         ("ELSE" insts))
  ...
@end example

But this will create conflicts for @code{"ELSE"}: on the one hand, the
IF rule implies (among many other things) that @code{"ELSE" = "END"};
but on the other hand, since @code{"ELSE"} appears within @code{cases},
which appears left of @code{"END"}, we also have @code{"ELSE" > "END"}.
We can solve the conflict either by using:
@example
  ...
  (inst ("IF" exp "THEN" insts "ELSE" insts "END")
        ("CASE" exp "OF" cases "END")
        ("CASE" exp "OF" cases "ELSE" insts "END")
        ...)
  (cases (cases "|" cases) (caselabel ":" insts))
  ...
@end example
or
@example
  ...
  (inst ("IF" exp "THEN" else "END")
        ("CASE" exp "OF" cases "END")
        ...)
  (else (insts "ELSE" insts))
  (cases (cases "|" cases) (caselabel ":" insts) (else))
  ...
@end example

Reworking the grammar to try and solve conflicts has its downsides, tho,
because SMIE assumes that the grammar reflects the logical structure of
the code, so it is preferable to keep the BNF closer to the intended
abstract syntax tree.

Other times, after careful consideration you may conclude that those
conflicts are not serious and simply resolve them via the
@var{resolvers} argument of @code{smie-bnf->prec2}.  Usually this is
because the grammar is simply ambiguous: the conflict does not affect
the set of programs described by the grammar, but only the way those
programs are parsed.  This is typically the case for separators and
associative infix operators, where you want to add a resolver like
@code{'((assoc "|"))}.  Another case where this can happen is for the
classic @emph{dangling else} problem, where you will use @code{'((assoc
"else" "then"))}.  It can also happen for cases where the conflict is
real and cannot really be resolved, but it is unlikely to pose a problem
in practice.

Finally, in many cases some conflicts will remain despite all efforts to
restructure the grammar.  Do not despair: while the parser cannot be
made more clever, you can make the lexer as smart as you want.  So, the
solution is then to look at the tokens involved in the conflict and to
split one of those tokens into 2 (or more) different tokens.  E.g., if
the grammar needs to distinguish between two incompatible uses of the
token @code{"begin"}, make the lexer return different tokens (say
@code{"begin-fun"} and @code{"begin-plain"}) depending on which kind of
@code{"begin"} it finds.  This pushes the work of distinguishing the
different cases to the lexer, which will thus have to look at the
surrounding text to find ad-hoc clues.

@node SMIE Indentation
@subsubsection Specifying Indentation Rules
@cindex indentation rules, SMIE

Based on the provided grammar, SMIE will be able to provide automatic
indentation without any extra effort.  But in practice, this default
indentation style will probably not be good enough.  You will want to
tweak it in many different cases.

SMIE indentation is based on the idea that indentation rules should be
as local as possible.  To this end, it relies on the idea of
@emph{virtual} indentation, which is the indentation that a particular
program point would have if it were at the beginning of a line.
Of course, if that program point is indeed at the beginning of a line,
its virtual indentation is its current indentation.  But if not, then
SMIE uses the indentation algorithm to compute the virtual indentation
of that point.  Now in practice, the virtual indentation of a program
point does not have to be identical to the indentation it would have if
we inserted a newline before it.  To see how this works, the SMIE rule
for indentation after a @code{@{} in C does not care whether the
@code{@{} is standing on a line of its own or is at the end of the
preceding line.  Instead, these different cases are handled in the
indentation rule that decides how to indent before a @code{@{}.

Another important concept is the notion of @emph{parent}: The
@emph{parent} of a token, is the head token of the nearest enclosing
syntactic construct.  For example, the parent of an @code{else} is the
@code{if} to which it belongs, and the parent of an @code{if}, in turn,
is the lead token of the surrounding construct.  The command
@code{backward-sexp} jumps from a token to its parent, but there are
some caveats: for @emph{openers} (tokens which start a construct, like
@code{if}), you need to start with point before the token, while for
others you need to start with point after the token.
@code{backward-sexp} stops with point before the parent token if that is
the @emph{opener} of the token of interest, and otherwise it stops with
point after the parent token.

SMIE indentation rules are specified using a function that takes two
arguments @var{method} and @var{arg} where the meaning of @var{arg} and the
expected return value depend on @var{method}.

@var{method} can be:
@itemize
@item
@code{:after}, in which case @var{arg} is a token and the function
should return the @var{offset} to use for indentation after @var{arg}.
@item
@code{:before}, in which case @var{arg} is a token and the function
should return the @var{offset} to use to indent @var{arg} itself.
@item
@code{:elem}, in which case the function should return either the offset
to use to indent function arguments (if @var{arg} is the symbol
@code{arg}) or the basic indentation step (if @var{arg} is the symbol
@code{basic}).
@item
@code{:list-intro}, in which case @var{arg} is a token and the function
should return non-@code{nil} if the token is followed by a list of
expressions (not separated by any token) rather than an expression.
@end itemize

When @var{arg} is a token, the function is called with point just before
that token.  A return value of @code{nil} always means to fallback on the
default behavior, so the function should return @code{nil} for arguments it
does not expect.

@var{offset} can be:
@itemize
@item
@code{nil}: use the default indentation rule.
@item
@code{(column . @var{column})}: indent to column @var{column}.
@item
@var{number}: offset by @var{number}, relative to a base token which is
the current token for @code{:after} and its parent for @code{:before}.
@end itemize

@node SMIE Indentation Helpers
@subsubsection Helper Functions for Indentation Rules

SMIE provides various functions designed specifically for use in the
indentation rules function (several of those functions break if used in
another context).  These functions all start with the prefix
@code{smie-rule-}.

@defun smie-rule-bolp
Return non-@code{nil} if the current token is the first on the line.
@end defun

@defun smie-rule-hanging-p
Return non-@code{nil} if the current token is @emph{hanging}.
A token is @emph{hanging} if it is the last token on the line
and if it is preceded by other tokens: a lone token on a line is not
hanging.
@end defun

@defun smie-rule-next-p &rest tokens
Return non-@code{nil} if the next token is among @var{tokens}.
@end defun

@defun smie-rule-prev-p &rest tokens
Return non-@code{nil} if the previous token is among @var{tokens}.
@end defun

@defun smie-rule-parent-p &rest parents
Return non-@code{nil} if the current token's parent is among @var{parents}.
@end defun

@defun smie-rule-sibling-p
Return non-@code{nil} if the current token's parent is actually a
sibling.  This is the case for example when the parent of a @code{","}
is just the previous @code{","}.
@end defun

@defun smie-rule-parent &optional offset
Return the proper offset to align the current token with the parent.
If non-@code{nil}, @var{offset} should be an integer giving an
additional offset to apply.
@end defun

@defun smie-rule-separator method
Indent current token as a @emph{separator}.

By @emph{separator}, we mean here a token whose sole purpose is to
separate various elements within some enclosing syntactic construct, and
which does not have any semantic significance in itself (i.e., it would
typically not exist as a node in an abstract syntax tree).

Such a token is expected to have an associative syntax and be closely
tied to its syntactic parent.  Typical examples are @code{","} in lists
of arguments (enclosed inside parentheses), or @code{";"} in sequences
of instructions (enclosed in a @code{@{...@}} or @code{begin...end}
block).

@var{method} should be the method name that was passed to
@code{smie-rules-function}.
@end defun

@node SMIE Indentation Example
@subsubsection Sample Indentation Rules

Here is an example of an indentation function:

@example
(defun sample-smie-rules (kind token)
  (pcase (cons kind token)
    (`(:elem . basic) sample-indent-basic)
    (`(,_ . ",") (smie-rule-separator kind))
    (`(:after . ":=") sample-indent-basic)
    (`(:before . ,(or `"begin" `"(" `"@{")))
     (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "if")
     (and (not (smie-rule-bolp)) (smie-rule-prev-p "else")
          (smie-rule-parent)))))
@end example

@noindent
A few things to note:

@itemize
@item
The first case indicates the basic indentation increment to use.
If @code{sample-indent-basic} is @code{nil}, then SMIE uses the global
setting @code{smie-indent-basic}.  The major mode could have set
@code{smie-indent-basic} buffer-locally instead, but that
is discouraged.

@item
The rule for the token @code{","} make SMIE try to be more clever when
the comma separator is placed at the beginning of lines.  It tries to
outdent the separator so as to align the code after the comma; for
example:

@example
x = longfunctionname (
        arg1
      , arg2
    );
@end example

@item
The rule for indentation after @code{":="} exists because otherwise
SMIE would treat @code{":="} as an infix operator and would align the
right argument with the left one.

@item
The rule for indentation before @code{"begin"} is an example of the use
of virtual indentation:  This rule is used only when @code{"begin"} is
hanging, which can happen only when @code{"begin"} is not at the
beginning of a line.  So this is not used when indenting
@code{"begin"} itself but only when indenting something relative to this
@code{"begin"}.  Concretely, this rule changes the indentation from:

@example
    if x > 0 then begin
            dosomething(x);
        end
@end example
to
@example
    if x > 0 then begin
        dosomething(x);
    end
@end example

@item
The rule for indentation before @code{"if"} is similar to the one for
@code{"begin"}, but where the purpose is to treat @code{"else if"}
as a single unit, so as to align a sequence of tests rather than indent
each test further to the right.  This function does this only in the
case where the @code{"if"} is not placed on a separate line, hence the
@code{smie-rule-bolp} test.

If we know that the @code{"else"} is always aligned with its @code{"if"}
and is always at the beginning of a line, we can use a more efficient
rule:
@example
((equal token "if")
 (and (not (smie-rule-bolp))
      (smie-rule-prev-p "else")
      (save-excursion
        (sample-smie-backward-token)
        (cons 'column (current-column)))))
@end example

The advantage of this formulation is that it reuses the indentation of
the previous @code{"else"}, rather than going all the way back to the
first @code{"if"} of the sequence.
@end itemize

@c In some sense this belongs more in the Emacs manual.
@node SMIE Customization
@subsubsection Customizing Indentation

If you are using a mode whose indentation is provided by SMIE, you can
customize the indentation to suit your preferences.  You can do this
on a per-mode basis (using the option @code{smie-config}), or a
per-file basis (using the function @code{smie-config-local} in a
file-local variable specification).

@defopt smie-config
This option lets you customize indentation on a per-mode basis.
It is an alist with elements of the form @code{(@var{mode} . @var{rules})}.
For the precise form of rules, see the variable's documentation; but
you may find it easier to use the command @code{smie-config-guess}.
@end defopt

@deffn Command smie-config-guess
This command tries to work out appropriate settings to produce
your preferred style of indentation.  Simply call the command while
visiting a file that is indented with your style.
@end deffn

@deffn Command smie-config-save
Call this command after using @code{smie-config-guess}, to save your
settings for future sessions.
@end deffn

@deffn Command smie-config-show-indent &optional move
This command displays the rules that are used to indent the current
line.
@end deffn

@deffn Command smie-config-set-indent
This command adds a local rule to adjust the indentation of the current line.
@end deffn

@defun smie-config-local rules
This function adds @var{rules} as indentation rules for the current buffer.
These add to any mode-specific rules defined by the @code{smie-config} option.
To specify custom indentation rules for a specific file, add an entry
to the file's local variables of the form:
@code{eval: (smie-config-local '(@var{rules}))}.
@end defun


@node Desktop Save Mode
@section Desktop Save Mode
@cindex desktop save mode

@dfn{Desktop Save Mode} is a feature to save the state of Emacs from
one session to another.  The user-level commands for using Desktop
Save Mode are described in the GNU Emacs Manual (@pxref{Saving Emacs
Sessions,,, emacs, the GNU Emacs Manual}).  Modes whose buffers visit
a file, don't have to do anything to use this feature.

For buffers not visiting a file to have their state saved, the major
mode must bind the buffer local variable @code{desktop-save-buffer} to
a non-@code{nil} value.

@defvar desktop-save-buffer
If this buffer-local variable is non-@code{nil}, the buffer will have
its state saved in the desktop file at desktop save.  If the value is
a function, it is called at desktop save with argument
@var{desktop-dirname}, and its value is saved in the desktop file along
with the state of the buffer for which it was called.  When file names
are returned as part of the auxiliary information, they should be
formatted using the call

@example
(desktop-file-name @var{file-name} @var{desktop-dirname})
@end example

@end defvar

For buffers not visiting a file to be restored, the major mode must
define a function to do the job, and that function must be listed in
the alist @code{desktop-buffer-mode-handlers}.

@defvar desktop-buffer-mode-handlers
Alist with elements

@example
(@var{major-mode} . @var{restore-buffer-function})
@end example

The function @var{restore-buffer-function} will be called with
argument list

@example
(@var{buffer-file-name} @var{buffer-name} @var{desktop-buffer-misc})
@end example

and it should return the restored buffer.
Here @var{desktop-buffer-misc} is the value returned by the function
optionally bound to @code{desktop-save-buffer}.
@end defvar
