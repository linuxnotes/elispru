@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2017 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter Функции

  Lisp программы составлены преимущественно из Lisp функций. Данная
глава описывает, что представляют собой функции, как они принимают аргументы,
и как их определять.

@c   A Lisp program is composed mainly of Lisp functions.  This chapter
@c explains what functions are, how they accept arguments, and how to
@c define them.sh

@menu
* What Is a Function::          Терминология Lisp функции и примитивы.
* Lambda Expressions::          Как функции представляются в виде Lisp объектов.
* Function Names::              Символ может выступать в виде имени функции.
* Defining Functions::          Lisp выражения для определения функций.
* Calling Functions::           Как использовать существующую функцию.
* Mapping Functions::           Применение функции к каждому элементу списка или чего-то еще.
* Anonymous Functions::         Lambda выражения или функции без имен.
* Generic Functions::           Полиморфизм, Emacs-стиль.
* Function Cells::              Установка или получение определения функции из символа.
* Closures::                    Замыкания --- функции сохраняющие окружение.
* Advising Functions::          Advising функции расширяющие функционал функции.
* Obsolete Functions::          Объявление функции устаревшей.
* Inline Functions::            Встроенные функции, функции которые компилятор встроит в код.
* Declare Form::                Добавление дополнительной информации о функции.
* Declaring Functions::         Оповещение компилятора о существовании функции.
* Function Safety::             Определение функции безопасной или не безопасной для вызова.
* Related Topics::              Связанные темы по Lisp примитивам, имеющих особое отношение к работе функций.

@end menu

@node What Is a Function
@section Что такое Функция?

@cindex return value
@cindex value of function
@cindex argument
  В общем смысле функции -- это правило выполнения вычислений с
заданными входными значениями называемыми @dfn{аргументами} (@dfn{arguments}).
Результат вычисления называется @dfn{значение} (@dfn{value}) или
@dfn{возвращаемое значение} (@dfn{return value}) функции. Вычисление может
так же иметь побочные эффекты, такие как изменения значение переменных
или содержимого структур данных.

@c   In a general sense, a function is a rule for carrying out a
@c computation given input values called @dfn{arguments}.  The result of
@c the computation is called the @dfn{value} or @dfn{return value} of the
@c function.  The computation can also have side effects, such as lasting
@c changes in the values of variables or the contents of data structures.

  В большинстве компьютерных языков, каждая функция имеет имя. Но в Lisp,
функция в строгом смысле не имеет имени: она является объектом, который
может быть @emph{необязательно} ассоциирован с символом (например @code{car})
который будет служить именем функции. @xref{Function Names}. Когда
функция имеет заданное имя, будем ссылаться на этот символ как на
``функцию'' (например ``функция @code{car}'').
В данном руководстве, различие между именем функции и объектом функции
как правило не важно, но где это не так делается примечание.

@c   In most computer languages, every function has a name.  But in Lisp,
@c a function in the strictest sense has no name: it is an object which
@c can @emph{optionally} be associated with a symbol (e.g., @code{car})
@c that serves as the function name.  @xref{Function Names}.  When a
@c function has been given a name, we usually also refer to that symbol
@c as a ``function'' (e.g., we refer to ``the function @code{car}'').
@c In this manual, the distinction between a function name and the
@c function object itself is usually unimportant, but we will take note
@c wherever it is relevant.

  @dfn{Специальные формы} (@dfn{special forms}) и @dfn{макросы} (@dfn{macros})
похожи на функции, они тоже принимают аргументы и выполняют вычисления.
Но как будет показано ниже, они не считаются функциями в Emacs Lisp.

@c   Certain function-like objects, called @dfn{special forms} and
@c @dfn{macros}, also accept arguments to carry out computations.
@c However, as explained below, these are not considered functions in
@c Emacs Lisp.

  Ниже важные термины для функций и похожих на функции объекты:
  @c Here are important terms for functions and function-like objects:

@table @dfn
@item lambda выражение (lambda expression)
Функция (в строгом смысле, то есть, объект функции) который написан на
Lisp. Описана в следующем разделе.
@c A function (in the strict sense, i.e., a function object) which is
@c written in Lisp.  These are described in the following section.
@ifnottex
@xref{Lambda Expressions}.
@end ifnottex

@item примитив (primitive)
@cindex primitive
@cindex subr
@cindex built-in function
Функция вызываемая из Lisp, но при этом написанная на C@.
Примитивы так же называется @dfn{встроенными функциями} (@dfn{built-in functions}),
или @dfn{subrs}. Примеры включают @code{car} и @code{append}. В дополнении, все
особые формы (см. ниже) так же считаются примитивами.

@c A function which is callable from Lisp but is actually written in C@.
@c Primitives are also called @dfn{built-in functions}, or @dfn{subrs}.
@c Examples include functions like @code{car} and @code{append}.  In
@c addition, all special forms (see below) are also considered
@c primitives.

Обычно, функция реализуется в качестве примитива потому, что является
фундаментальной частью Lisp (например @code{car}), или потому что
предоставляет низкоуровневый интерфейс для работы с операционной системой,
или потому что должна быть быстрой. В отличие от функций определенных в Lisp, примитивы
могут быть изменены или добавлены только путем изменения C кода и
перекомпиляции Emacs. См. @ref{Writing Emacs Primitives}.

@c Usually, a function is implemented as a primitive because it is a
@c fundamental part of Lisp (e.g., @code{car}), or because it provides a
@c low-level interface to operating system services, or because it needs
@c to run fast.  Unlike functions defined in Lisp, primitives can be
@c modified or added only by changing the C sources and recompiling
@c Emacs.  See @ref{Writing Emacs Primitives}.

@item special form
Примитив который похож на функцию, но не вычисляет все свои аргументы обычным
образом. Он может вычислять только некоторые аргументы, или может
вычислять их в необычном порядке, или несколько раз.
Например @code{if}, @code{and}, и @code{while}.

@c A primitive that is like a function but does not evaluate all of its
@c arguments in the usual way.  It may evaluate only some of the
@c arguments, or may evaluate them in an unusual order, or several times.
@c Examples include @code{if}, @code{and}, and @code{while}.
@xref{Special Forms}.

@item macro
@cindex macro
Конструкция определенная в Lisp, которая отличается от функции тем, что
преобразует одно Lisp выражение в другое Lisp выражение, которое и будет
вычислено вместо оригинального вычисления. Макросы позволяют Lisp
программистам делать то, что могут делать специальные формы.
@xref{Macros}.

@c A construct defined in Lisp, which differs from a function in that it
@c translates a Lisp expression into another expression which is to be
@c evaluated instead of the original expression.  Macros enable Lisp
@c programmers to do the sorts of things that special forms can do.
@c @xref{Macros}.

@item command
@cindex команда(command)
Объект который может быть выполнен через @code{command-execute}
примитив, как правило выполняющаяся после нажатия последовательности
клавиш @dfn{привязанных} (@dfn{bound}) к этой команде. @xref{Interactive Call}.
Команда как правило является функций, если функция написана ан Lisp, то она
делается командой при помощи формы @code{interactive} в определении
функции (@pxref{Definition Commands}). Команды которые являются функциями
могут быть вызваны из Lisp выражений, как другие функции.

@c An object which can be invoked via the @code{command-execute}
@c primitive, usually due to the user typing in a key sequence
@c @dfn{bound} to that command.  @xref{Interactive Call}.  A command is
@c usually a function; if the function is written in Lisp, it is made
@c into a command by an @code{interactive} form in the function
@c definition (@pxref{Defining Commands}).  Commands that are functions
@c can also be called from Lisp expressions, just like other functions.

Клавиатурные макросы (строки и векторы) тоже являются командами,
несмотря на то, что они не являются функциями. @xref{Keyboard Macros}.
Символ будем считать командой если его ячейка функции содержит команду
(@pxref{Symbol Components}); такие @dfn{именованные команды} (@dfn{named command})
могут быть выполнены через @kbd{M-x}.

@c Keyboard macros (strings and vectors) are commands also, even though
@c they are not functions.  @xref{Keyboard Macros}.  We say that a symbol
@c is a command if its function cell contains a command (@pxref{Symbol
@c Components}); such a @dfn{named command} can be invoked with
@c @kbd{M-x}.

@item замыкание (closure)
Функциональный объект, который похож на lambda выражение, за исключением того,
что он так же содержит окружение со связываниями лексических переменных.

@c A function object that is much like a lambda expression, except that
@c it also encloses an environment of lexical variable bindings.
@xref{Closures}.

@item функция в байт коде (byte-code function)
Функция которая была скомпилирована байт компилятором.
@c A function that has been compiled by the byte compiler.
@xref{Byte-Code Type}.

@item autoload object
@cindex авто-загружаемый объект (autoload object)
Объект заглушка для реальной функции. Если авто-загружаемый объект вызывается,
Emacs загружает файл содержащий определение реальной функции, и после
этого вызывает реальную функцию. @xref{Autoload}.

@c A place-holder for a real function.  If the autoload object is called,
@c Emacs loads the file containing the definition of the real function,
@c and then calls the real function.  @xref{Autoload}.
@end table

  Для проверки того, является ли объект функцией можно использовать
функцию @code{functionp}:
@c   You can use the function @code{functionp} to test if an object is a
@c function:

@defun functionp object
Функция возвращает @code{t} если @var{object} является любым видом
функции т.е. может быть передан в @code{funcall}. Стоит отметить, что
@code{functionp} возвращает @code{t} для символов, которые являются
именами функций и возвращает @code{nil} для специальных форм.

@c This function returns @code{t} if @var{object} is any kind of
@c function, i.e., can be passed to @code{funcall}.  Note that
@c @code{functionp} returns @code{t} for symbols that are function names,
@c and returns @code{nil} for special forms.
@end defun

@noindent
В отличие от @code{functionp}, следующие три функции @emph{не} рассматривают
символ как определение функции.

@c Unlike @code{functionp}, the next three functions do @emph{not} treat
@c a symbol as its function definition.

@defun subrp object
Данная функция возвращает @code{t} если @var{object} является встроенной
функцией (т.е. Lisp примитивом).

@c This function returns @code{t} if @var{object} is a built-in function
@c (i.e., a Lisp primitive).

@example
@group
(subrp 'message)            ; @r{@code{message} is a symbol,}
     @result{} nil                 ;   @r{not a subr object.}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
Функция возвращает @code{t} если @var{object} является функцией в байт-коде.
Например:

@c This function returns @code{t} if @var{object} is a byte-code
@c function.  For example:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun subr-arity subr
Данная функция предоставляет информацию о списке аргументов примитива,
@var{subr}. Возвращаемое значение является парой @code{(@var{min} . @var{max})}.
@var{min} минимальное количество аргументов, @var{max} максимальное количество
или символ @code{many}, для функции с @code{&rest} аргументами, или символ
@code{unevalled} если @var{subr} специальная форма.

@c This function provides information about the argument list of a
@c primitive, @var{subr}.  The returned value is a pair
@c @code{(@var{min} . @var{max})}.  @var{min} is the minimum number of
@c args.  @var{max} is the maximum number or the symbol @code{many}, for a
@c function with @code{&rest} arguments, or the symbol @code{unevalled} if
@c @var{subr} is a special form.
@end defun

@node Lambda Expressions
@section Lambda Выражения
@c @section Lambda Expressions
@cindex lambda expression

  Lambda выражение это функциональный объект написанный на Lisp. Например:

@c   A lambda expression is a function object written in Lisp.  Here is
@c an example:

@example
(lambda (x)
  "Return the hyperbolic cosine of X."
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
В Emacs Lisp, такой список является корректным выражением, которое
вычисляется в функциональный объект.

@c In Emacs Lisp, such a list is a valid expression which evaluates to
@c a function object.

  Лямбда выражение, само по себе не имеет имени, это @dfn{анонимная функция}
(@dfn{anonymous function}). Хотя лямбда выражение может быть использовано
данным способом (@pxref{Anonymous Functions}), более часто они ассоциируются с
символами и являются @dfn{именованными функциями} (@dfn{named functions})
(@pxref{Function Names}). Прежде чем вдаваться в подробности, в следующей
секции будут описаны компоненты lambda выражения и их назначение.

@c   A lambda expression, by itself, has no name; it is an @dfn{anonymous
@c function}.  Although lambda expressions can be used this way
@c (@pxref{Anonymous Functions}), they are more commonly associated with
@c symbols to make @dfn{named functions} (@pxref{Function Names}).
@c Before going into these details, the following subsections describe
@c the components of a lambda expression and what they do.

@menu
* Lambda Components::           Части lambda выражения.
* Simple Lambda::               Простой пример.
* Argument List::               Детали и специальные возможности списка аргументов.
* Function Documentation::      Как добавить документацию в функцию.
@end menu

@node Lambda Components
@subsection Компоненты Lambda Выражения
@c @subsection Components of a Lambda Expression

  Lambda выражение является списком который выглядит следующим образом:
  @c A lambda expression is a list that looks like this:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  Первый элемент lambda выражения всегда символ @code{lambda}. Это
является индикатором того, что список является определением функции.
Функции начинаются с @code{lambda}, для того, чтобы остальные
списки, предназначенные для других целей, не могли быть интерпретированы
как функция.

@c   The first element of a lambda expression is always the symbol
@c @code{lambda}.  This indicates that the list represents a function.  The
@c reason functions are defined to start with @code{lambda} is so that
@c other lists, intended for other uses, will not accidentally be valid as
@c functions.

  Второй элемент это список символов---имена переменных аргументов.
Он называется @dfn{lambda список} (@dfn{lambda list}). Когда Lisp функция
вызывается, значение аргументов сопоставляются с переменными в lambda списке,
и эти переменные локально связываются с предоставленным
значением (получают локальное значение равное предоставленному значению).
@xref{Local Variables}.

@c   The second element is a list of symbols---the argument variable names.
@c This is called the @dfn{lambda list}.  When a Lisp function is called,
@c the argument values are matched up against the variables in the lambda
@c list, which are given local bindings with the values provided.
@c @xref{Local Variables}.

  Строка документации это Lisp строковый объект внутри определения функции
содержащий описание функции, которая будет в том числе отображена справочной
службой Emacs. @xref{Function Documentation}.

@c   The documentation string is a Lisp string object placed within the
@c function definition to describe the function for the Emacs help
@c facilities.  @xref{Function Documentation}.

  Определение интерактивности (interactive declaration) это список вида
@code{(interactive @var{code-string})}. Данный список описывает как передаются
аргументы если функция вызывается интерактивно. Функция с таким определением
называется @dfn{командой} (@dfn{command}); такие функции могут вызываться
с использованием @kbd{M-x} или через связанную комбинацию. Функция не предназначенная
для вызова таким образом не должна иметь определения интерактивности.
@xref{Defining Commands}, с описанием того как писать определение интерактивности.
  
@c   The interactive declaration is a list of the form @code{(interactive
@c @var{code-string})}.  This declares how to provide arguments if the
@c function is used interactively.  Functions with this declaration are called
@c @dfn{commands}; they can be called using @kbd{M-x} or bound to a key.
@c Functions not intended to be called in this way should not have interactive
@c declarations.  @xref{Defining Commands}, for how to write an interactive
@c declaration.

@cindex body of function
  Оставшиеся элементы являются @dfn{телом} (@dfn{body}) функции: Lisp
код выполняющий работу функции (или, как сказал бы Lisp программист ``список
Lisp форм для вычисления''). Значение возвращаемое последним элементов тела
является становится возвращаемым значением функции.

@c   The rest of the elements are the @dfn{body} of the function: the Lisp
@c code to do the work of the function (or, as a Lisp programmer would say,
@c ``a list of Lisp forms to evaluate'').  The value returned by the
@c function is the value returned by the last element of the body.

@node Simple Lambda
@subsection Простой Пример Lambda Выражения
@c @subsection A Simple Lambda Expression Example

  Рассмотрим следующий пример:
  @c Consider the following example:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
Данная функция может быть вызвана, путем передачи ее в @code{funcall}:
@c We can call this function by passing it to @code{funcall}, like this:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
Данный вызов вычисляет тело lambda выражения с переменной @code{a} связанной с 1, @code{b}
связанной с 2, и @code{c} связанной с 3. Вычисление тела складывает три числа, и
возвращает результат 6; в результате чего функция возвращает 6.

@c This call evaluates the body of the lambda expression  with the variable
@c @code{a} bound to 1, @code{b} bound to 2, and @code{c} bound to 3.
@c Evaluation of the body adds these three numbers, producing the result 6;
@c therefore, this call to the function returns the value 6.

  Стоит отметить, что аргументы могут быть результатом вызова другой функции,
например:
@c   Note that the arguments can be the results of other function calls, as in
@c this example:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
В данном примере, вычисляются аргументы @code{1}, @code{(* 2 3)}, и
@code{(- 5 4)} с лева направо. Затем применяется lambda выражение к
аргументам 1, 6 и 1 и получается результат 8.

@c This evaluates the arguments @code{1}, @code{(* 2 3)}, and @code{(- 5
@c 4)} from left to right.  Then it applies the lambda expression to the
@c argument values 1, 6 and 1 to produce the value 8.

  Как показано в примере, форму с lambda выражением можно использовать
для создания локальных переменных и присвоения им значений. В старые времена,
это был единственный способ создания локальных переменных. Но сегодня, более
понятно будет использовать @code{let} для этой цели (@pxref{Local Variables}).
Lambda выражения преимущественно используются как анонимные функции для
передачи в качестве аргумента в другие функции (@pxref{Anonymous Functions}), или
хранения как определение функции символа, то есть именованных функций.
(@pxref{Funxtion Names}).

@c   As these examples show, you can use a form with a lambda expression
@c as its @sc{car} to make local variables and give them values.  In the
@c old days of Lisp, this technique was the only way to bind and
@c initialize local variables.  But nowadays, it is clearer to use the
@c special form @code{let} for this purpose (@pxref{Local Variables}).
@c Lambda expressions are mainly used as anonymous functions for passing
@c as arguments to other functions (@pxref{Anonymous Functions}), or
@c stored as symbol function definitions to produce named functions
@c (@pxref{Function Names}).

@node Argument List
@subsection Другие Возможности Списка Аргументов
@c @subsection Other Features of Argument Lists
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  Функция из примера, @code{(lambda (a b c) (+ a b c))}, определяет
три переменных аргумента, поэтому она должна вызываться с тремя аргументами:
если попытаться вызвать ее только с двумя аргументами или четырьмя аргументами
будет ошибка @code{wrong-number-of-arguments}. (@pxref{Errors}).

@c   Our simple sample function, @code{(lambda (a b c) (+ a b c))},
@c specifies three argument variables, so it must be called with three
@c arguments: if you try to call it with only two arguments or four
@c arguments, you get a @code{wrong-number-of-arguments} error
@c (@pxref{Errors}).

  Как правило удобно писать функции в которых некоторые аргументы можно опустить.
Например, функция @code{substring} принимает три аргумента---строку, начальный индекс
и конечный индекс---но третий аргумент по умолчанию @var{length} (@var{длина}) строки
если он опущен при вызове. Так же удобно иметь возможность для некоторых функций
принимать бесконечное(произвольное) число аргументов, таким как например функция
@code{list} и @code{+}.

@c   It is often convenient to write a function that allows certain
@c arguments to be omitted.  For example, the function @code{substring}
@c accepts three arguments---a string, the start index and the end
@c index---but the third argument defaults to the @var{length} of the
@c string if you omit it.  It is also convenient for certain functions to
@c accept an indefinite number of arguments, as the functions @code{list}
@c and @code{+} do.

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  Для определения не обязательного аргумента, который может быть пропущен
при вызове функции, нужно просто включить слово @code{&optional} перед
не обязательными аргументами. Для определения списка из произвольного числа
аргументов нужно включить @code{&rest} перед последним аргументом.

@c   To specify optional arguments that may be omitted when a function
@c is called, simply include the keyword @code{&optional} before the optional
@c arguments.  To specify a list of zero or more extra arguments, include the
@c keyword @code{&rest} before one final argument.

  Таким образом, полный синтаксис списка аргументов следующий:
  @c Thus, the complete syntax for an argument list is as follows:

@example
@group
(@var{required-vars}@dots{}
 @r{[}&optional @var{optional-vars}@dots{}@r{]}
 @r{[}&rest @var{rest-var}@r{]})
@end group
@end example

@noindent
Квадратные скобки указывают, что @code{&optional} и @code{&rest}, и переменные
которые следуют за ними, не обязательны.
@c The square brackets indicate that the @code{&optional} and @code{&rest}
@c clauses, and the variables that follow them, are optional.

  Вызов функции требует одного фактического аргумента для каждого
@var{required-vars} (обязательных аргументов).
 Может быть ноль и более аргументов для @var{optional-vars} (необязательных аргументов),
и других аргументов быть не может, кроме случаев когда используется @code{&rest}. В
этом случае (если есть @code{&rest}), может быть любое количество дополнительных
фактических аргументов.
 
@c   A call to the function requires one actual argument for each of the
@c @var{required-vars}.  There may be actual arguments for zero or more of
@c the @var{optional-vars}, and there cannot be any actual arguments beyond
@c that unless the lambda list uses @code{&rest}.  In that case, there may
@c be any number of extra actual arguments.

  Если фактические аргументы для необязательных или остальных(rest) параметров
опускаются, их значение по умолчанию @code{nil}. В функции нет возможности
определить был ли явно передан аргумент @code{nil} или аргумент
не был задан. Но, в теле функции можно рассматривать @code{nil} как
сокращение для любого другого значащего значения. Например, так
делается в @code{substring}, где @code{nil} в качестве третьего аргумента
равнозначно использованию длины строки в качестве значения.

@c   If actual arguments for the optional and rest variables are omitted,
@c then they always default to @code{nil}.  There is no way for the
@c function to distinguish between an explicit argument of @code{nil} and
@c an omitted argument.  However, the body of the function is free to
@c consider @code{nil} an abbreviation for some other meaningful value.
@c This is what @code{substring} does; @code{nil} as the third argument to
@c @code{substring} means to use the length of the string supplied.

@cindex CL note---default optional arg
@quotation
@b{Common Lisp примечание:} Common Lisp позволяет функции определить
значение по умолчанию для необязательных аргументов; Emacs Lisp
всегда использует @code{nil}. Emacs Lisp не поддерживает @code{supplied-p}
переменные которые указывают был ли действительно передан аргумент.

@c @b{Common Lisp note:} Common Lisp allows the function to specify what
@c default value to use when an optional argument is omitted; Emacs Lisp
@c always uses @code{nil}.  Emacs Lisp does not support @code{supplied-p}
@c variables that tell you whether an argument was explicitly passed.
@end quotation

  Например, список аргументов который выглядит как:
  @c For example, an argument list that looks like this:

@example
(a b &optional c d &rest e)
@end example

@noindent
связывает @code{a} и @code{b} с первыми двумя фактическими аргументами, которые
являются обязательными. Если передано больше аргументов, до первые два из
них будут связаны с @code{c} и @code{d}, а все остальные будут доступны через @code{е}
которая будет списком. Если передано только два аргумента, @code{c} будет
@code{nil}, если два или три @code{d} будет @code{nil}, если четыре или
менее @code{e} будет @code{nil}.

@c binds @code{a} and @code{b} to the first two actual arguments, which are
@c required.  If one or two more arguments are provided, @code{c} and
@c @code{d} are bound to them respectively; any arguments after the first
@c four are collected into a list and @code{e} is bound to that list.  If
@c there are only two arguments, @code{c} is @code{nil}; if two or three
@c arguments, @code{d} is @code{nil}; if four arguments or fewer, @code{e}
@c is @code{nil}.

  Нельзя задать обязательные аргументы после не обязательных.
Так как в этом случае нельзя определить какие были заданы аргументы.
Например пусть в примере выше @code{c} будет не обязательным, а @code{d}
обязательным. Пусть передано три фактических аргумента, тогда
какую переменную задает третий аргумент ? Он должен быть использован
для @code{c} или @code{d}. Аналогично, не может быть никаких
аргументов (обязательных или не обязательных) после @code{&rest} аргумента.

@c   There is no way to have required arguments following optional
@c ones---it would not make sense.  To see why this must be so, suppose
@c that @code{c} in the example were optional and @code{d} were required.
@c Suppose three actual arguments are given; which variable would the
@c third argument be for?  Would it be used for the @var{c}, or for
@c @var{d}?  One can argue for both possibilities.  Similarly, it makes
@c no sense to have any more arguments (either required or optional)
@c after a @code{&rest} argument.

  Ниже несколько примеров со списками аргументов и подходящим
для них вызовам:
  @c Here are some examples of argument lists and proper calls:

@example
(funcall (lambda (n) (1+ n))        ; @r{Один обязательный:}
         1)                         ; @r{Требуется 1 обязательный аргумент.}
     @result{} 2
(funcall (lambda (n &optional n1)   ; @r{Один обязательный и один не обязательный:}
           (if n1 (+ n n1) (1+ n))) ; @r{1 или 2 аргумента.}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns)       ; @r{Один обязательный и один rest (произвольной длины):}
           (+ n (apply '+ ns)))     ; @r{1 или более аргументов.}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection Строка документации функции
@cindex documentation of function

  Lambda выражение может содержать @dfn{строку документации} (@dfn{documentation string})
сразу после списка аргументов (lambda list). Такая строка не влияет на выполнение
функции, и является видом комментария, но является систематизированным и может
использоваться средствами помощи Emacs. @xref{Documenation} с
описанием доступа к строкам документации.

@c   A lambda expression may optionally have a @dfn{documentation string}
@c just after the lambda list.  This string does not affect execution of
@c the function; it is a kind of comment, but a systematized comment
@c which actually appears inside the Lisp world and can be used by the
@c Emacs help facilities.  @xref{Documentation}, for how the
@c documentation string is accessed.

  Стоит предоставлять документация для всех функций в программе, даже
если они вызываются только внутри вашей программы. Строка документации
работает как комментарий, но доступ к ней проще.

@c   It is a good idea to provide documentation strings for all the
@c functions in your program, even those that are called only from within
@c your program.  Documentation strings are like comments, except that they
@c are easier to access.

  Первая строка документации должна быть самодостаточной, потому
что @code{apropos} показывает только первую строку. Она должна состоять
из одного или двух законченных предложений кратко описывающих
назначение функции.

@c   The first line of the documentation string should stand on its own,
@c because @code{apropos} displays just this first line.  It should consist
@c of one or two complete sentences that summarize the function's purpose.

  Начало строки документации как правило имеет отступ в исходном файле,
но эти пробелы находятся до двойных кавычек и не являются частью документации.
Некоторые при этом делают отступы и в других строках документации, что
является @emph{ошибочным}. Отступы в не первой строке документации
находятся внутри документации, и хотя в коде такие отступы выглядят хорошо,
при показе помощи они будут выглядеть не очень.

@c   The start of the documentation string is usually indented in the
@c source file, but since these spaces come before the starting
@c double-quote, they are not part of the string.  Some people make a
@c practice of indenting any additional lines of the string so that the
@c text lines up in the program source.  @emph{That is a mistake.}  The
@c indentation of the following lines is inside the string; what looks
@c nice in the source code will look ugly when displayed by the help
@c commands.

  Может показаться необычным то, что строка документации может быть
на обязательной, так как в функции есть обязательная часть после нее
(тело функции). Так как вычисление строки, возвращает эту же строку без
побочных эффектов, она не оказывает влияния, если не является последней формой
тела. Таким образом, на практике, нет противоречия между первой
формой тела и строкой документации; если тело формы строк, тогда она является
и возвращаемым значением и документацией.

@c   You may wonder how the documentation string could be optional, since
@c there are required components of the function that follow it (the body).
@c Since evaluation of a string returns that string, without any side effects,
@c it has no effect if it is not the last form in the body.  Thus, in
@c practice, there is no confusion between the first form of the body and the
@c documentation string; if the only body form is a string then it serves both
@c as the return value and as the documentation.

  Последняя строка документации может определять соглашения отличные
от фактических аргументов функции. Текст наподобие следующего:
@c   The last line of the documentation string can specify calling
@c conventions different from the actual function arguments.  Write
@c text like this:

@example
\(fn @var{arglist})
@end example

@noindent
со следующей пустой строкой, в начале, без перевода строки внутри строки
документации.  (@samp{\} используется чтобы исключить путаницу с командами
перемещения курсора в Emacs.) Указанный способ вызова, будет
показан в описании функции вместо описания по умолчанию, получаемого
из аргументов в описании функции.

@c following a blank line, at the beginning of the line, with no newline
@c following it inside the documentation string.  (The @samp{\} is used
@c to avoid confusing the Emacs motion commands.)  The calling convention
@c specified in this way appears in help messages in place of the one
@c derived from the actual arguments of the function.

  Данная возможность применима при определении макросов, потому что
аргументы записанные в определении макроса часто не соответствуют
представлению пользователя о элементах макроса.
 
@c   This feature is particularly useful for macro definitions, since the
@c arguments written in a macro definition often do not correspond to the
@c way users think of the parts of the macro call.

@node Function Names
@section Именование Функции
@c @section Naming a Function
@cindex function definition
@cindex named function
@cindex function name

  Символ может служить именем функции. Так происходит если
@dfn{ячейка функции} (@dfn{function cell}) (@pxref{Symbol Components}) содержит
функциональный объект (например lambda выражение). В этом случае символ
становится корректной, вызываемой функцией, эквивалентным функциональному
объекту в его ячейки функции.

@c   A symbol can serve as the name of a function.  This happens when the
@c symbol's @dfn{function cell} (@pxref{Symbol Components}) contains a
@c function object (e.g., a lambda expression).  Then the symbol itself
@c becomes a valid, callable function, equivalent to the function object
@c in its function cell.

  Содержимое ячейки функции называют @dfn{определением функции}
(@dfn{function definition}) символа.  Процедура использования
функции из символа в место символа называется @dfn{косвенное
обращение к функции символа} (@dfn{symbol function indirection});
см. @ref{Function Indirection}. Если для символа не задать функцию, то
ячейка функции будет @dfn{пустой}(@dfn{void}) и такой символ нельзя
будет использовать в качестве функции.

@c   The contents of the function cell are also called the symbol's
@c @dfn{function definition}.  The procedure of using a symbol's function
@c definition in place of the symbol is called @dfn{symbol function
@c indirection}; see @ref{Function Indirection}.  If you have not given a
@c symbol a function definition, its function cell is said to be
@c @dfn{void}, and it cannot be used as a function.

  На практике, почти все функции имеют имена, и обращение производится
по имени. Можно создать именованную Lisp функцию путем создания
lambda выражения и сохранения его в ячейку функции (@pxref{Function Cells}).
Но более распространенным и простым способом является использование специальной
формы @code{defun}, описанной в следующей секции.

@c   In practice, nearly all functions have names, and are referred to by
@c their names.  You can create a named Lisp function by defining a
@c lambda expression and putting it in a function cell (@pxref{Function
@c Cells}).  However, it is more common to use the @code{defun} special
@c form, described in the next section.
@ifnottex
@xref{Defining Functions}.
@end ifnottex

  Имена функциям даются потому, что по ним удобно обращаться в выражениях
Lisp. Кроме того в именованной функции легко сослаться на себя---то
есть сделать ее рекурсивной. Более того, примитивные (primitives)
могут быть вызвана только по имени, потому что такие функциональные
объекты не имеют синтаксиса для чтения (@pxref{Primitive Function Type}).
(Прим. Примитивы не могут быть записаны в качестве выражений.)

@c   We give functions names because it is convenient to refer to them by
@c their names in Lisp expressions.  Also, a named Lisp function can
@c easily refer to itself---it can be recursive.  Furthermore, primitives
@c can only be referred to textually by their names, since primitive
@c function objects (@pxref{Primitive Function Type}) have no read
@c syntax.

  Функция не обязана иметь уникальное имя. Функциональный объект
@emph{как правило} (@emph{usually}) находится в ячейке функции
только одного символа, но это всего лишь соглашение. Можно просто
сохранить одну и туже функцию в несколько символов используя
@code{fset}; и в этом случае каждый из символов будет корректным
именем функции.

@c   A function need not have a unique name.  A given function object
@c @emph{usually} appears in the function cell of only one symbol, but
@c this is just a convention.  It is easy to store it in several symbols
@c using @code{fset}; then each of the symbols is a valid name for the
@c same function.

  Стоит отметить, что символ используемый в качестве имени функции
может использоваться и в качестве переменной, и оба эти способа использования
будут независимыми и не конфликтующими. (В некоторых диалектах Lisp, таких
как Scheme это не так.)

@c   Note that a symbol used as a function name may also be used as a
@c variable; these two uses of a symbol are independent and do not
@c conflict.  (This is not the case in some dialects of Lisp, like
@c Scheme.)

@node Defining Functions
@c @section Defining Functions
@section Определение Функций
@cindex defining a function

  Как правило имя функции задается при ее создании @dfn{определении функции}
(@dfn{defining a function}). Данное действие выполняется с помощью
макроса @code{defun}.

@c   We usually give a name to a function when it is first created.  This
@c is called @dfn{defining a function}, and it is done with the
@c @code{defun} macro.

@defmac defun name args [doc] [declare] [interactive] body@dots{}
Макрос @code{defun} является стандартным способом определения
новой Lisp функции. Макрос определяет символ @var{name} как функцию
с аргументами @var{args} и телом @var{body}. @var{name} и @var{args}
не должны быть закавычены (quoted).

@c @code{defun} is the usual way to define new Lisp functions.  It
@c defines the symbol @var{name} as a function with argument list
@c @var{args} and body forms given by @var{body}.  Neither @var{name} nor
@c @var{args} should be quoted.

Если задано @var{doc}, то оно должно быть строкой задающей строку
документации (@pxref{Function Documentation}). Если задано @var{declare}
должно быть формой @code{declare} определяющей метаданные функции (@pxref{Declare Form}).
Если задано @var{interactive}, то она должна быть @code{interactive} формой
определяющей способ интерактивного вызова функции (интерактивный если вызывается
например по execute-extended-command или при нажатии связанного набора клавиш)
(@pxref{Interactive Call}).

@c @var{doc}, if present, should be a string specifying the function's
@c documentation string (@pxref{Function Documentation}).  @var{declare},
@c if present, should be a @code{declare} form specifying function
@c metadata (@pxref{Declare Form}).  @var{interactive}, if present,
@c should be an @code{interactive} form specifying how the function is to
@c be called interactively (@pxref{Interactive Call}).

Возвращаемое значение @code{defun} не определено.
@c The return value of @code{defun} is undefined.

Несколько примеров:
@c Here are some examples:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Wrong number of arguments.
@end group

@group
(defun capitalize-backwards ()
  "Upcase the last letter of the word at point."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example
Нужно стараться не переопределить нечаянно существующие функции.
@code{defun} выполняет переопределение даже примитивных функций таких
как @code{car} без сомнений и предупреждений. Emacs не препятствует
таким переопределениям, потому что переопределения время от времени
делаются намеренно, и нет способа различить умышленное переопределение
от случайного.

@c Be careful not to redefine existing functions unintentionally.
@c @code{defun} redefines even primitive functions such as @code{car}
@c without any hesitation or notification.  Emacs does not prevent you
@c from doing this, because redefining a function is sometimes done
@c deliberately, and there is no way to distinguish deliberate
@c redefinition from unintentional redefinition.
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
Функция указывает, символ @var{name} является синонимом функции
с определением @var{definition} (который может быть любой
корректной Lisp функцией). Возвращается значение @emph{не определено}
(@emph{undefined}).

@c This function defines the symbol @var{name} as a function, with
@c definition @var{definition} (which can be any valid Lisp function).
@c Its return value is @emph{undefined}.

Если @var{doc} не-@code{nil}, то эта строка становится документацией для
функции @var{name}. Иначе используется документация из
@var{definition}.

@c If @var{doc} is non-@code{nil}, it becomes the function documentation
@c of @var{name}.  Otherwise, any documentation provided by
@c @var{definition} is used.

@cindex defalias-fset-function property
В реализации, @code{defalias} как правило используется @code{fset} для
задания определения. Если символ @var{name} имеет свойство @code{defalias-fset-function},
то значение этого свойства будет использоваться для установки значения
вместо @code{fset}.

@c Internally, @code{defalias} normally uses @code{fset} to set the definition.
@c If @var{name} has a @code{defalias-fset-function} property, however,
@c the associated value is used as a function to call in place of @code{fset}.


Подходящим местом использования @code{defalias} является место
определения специальной функции---особенно если имя появляется в
загружаемом файле. @code{defalias} сохраняет в каком файле определена функция,
так же как и @code{defun} (@pxref{Unloading}).

@c The proper place to use @code{defalias} is where a specific function
@c name is being defined---especially where that name appears explicitly in
@c the source file being loaded.  This is because @code{defalias} records
@c which file defined the function, just like @code{defun}
@c (@pxref{Unloading}).

При этом в программах которые изменяют определения функций (манипулируют ими),
предпочтительнее использовать @code{fset}, которая не сохраняет
дополнительной информации. @xref{Function Cells}.

@c By contrast, in programs that manipulate function definitions for other
@c purposes, it is better to use @code{fset}, which does not keep such
@c records.  @xref{Function Cells}.
@end defun

  Пользователь не может создать новую примитивную функцию
используя @code{defun} или @code{defalias}, но их можно использовать
для изменения определения функции любого символа, даже таких как
@code{car} или @code{x-popup-menu} обычное определение для
которых является примитивом. Правда такие переопределения
рискованны, потому что например не возможно переопределить
@code{car} без того, чтобы не поломать Lisp. Переопределение
не совсем понятной функции @code{x-popup-menu} менее опасно, но
все равно такое переопределение может не работать как ожидается.
Так как вызовы таких примитивов из C кода будут вызывать оригинальные
определения, и сделанное переопределение в этих случаях работать
не будет.

@c   You cannot create a new primitive function with @code{defun} or
@c @code{defalias}, but you can use them to change the function definition of
@c any symbol, even one such as @code{car} or @code{x-popup-menu} whose
@c normal definition is a primitive.  However, this is risky: for
@c instance, it is next to impossible to redefine @code{car} without
@c breaking Lisp completely.  Redefining an obscure function such as
@c @code{x-popup-menu} is less dangerous, but it still may not work as
@c you expect.  If there are calls to the primitive from C code, they
@c call the primitive's C definition directly, so changing the symbol's
@c definition will have no effect on them.

  Так же стоит посмотреть @code{defsubst}, которая определяет функцию
как @code{defun} и указывает Lisp компилятору выполнять встраивание
кода  этой функции. @xref{Inline Functions}.

@c   See also @code{defsubst}, which defines a function like @code{defun}
@c and tells the Lisp compiler to perform inline expansion on it.
@c @xref{Inline Functions}.

  Другим способом создания встраиваемой (inline) функции является
предоставление кода который будет встраивать ее как компилируемый
макрос. Это позволяет сделать следующий макрос.

@c   Alternatively, you can define a function by providing the code which
@c will inline it as a compiler macro.  The following macros make this
@c possible.

@c FIXME: Can define-inline use the interactive spec?
@defmac define-inline name args [doc] [declare] body@dots{}
Определяет функцию @var{name} путем предоставления кода который
выполняет встраивание, как компилируемый макрос. Функция будет принимать
список аргументов @var{args} и будет иметь заданное тело @var{body}.

@c Define a function @var{name} by providing code that does its inlining,
@c as a compiler macro.  The function will accept the argument list
@c @var{args} and will have the specified @var{body}.

Если задано @var{doc}, то она должна быть строкой документации
(@pxref{Function Documentation}); Если задано @var{declare}, то
оно должно быть формой @code{declare} (@pxref{Declare Form}) задающей
служебную информацию функции (function's metadata).

@c If present, @var{doc} should be the function's documentation string
@c (@pxref{Function Documentation}); @var{declare}, if present, should be
@c a @code{declare} form (@pxref{Declare Form}) specifying the function's
@c metadata.
@end defmac

Функция определенная через @code{define-inline} имеет несколько
преимуществ по сравнению с определением макроса через @code{defsubst}
или @code{defmacro}:

@c Functions defined via @code{define-inline} have several advantages
@c with respect to macros defined by @code{defsubst} or @code{defmacro}:

@itemize @minus
@item
Они могут быть переданы в @code{mapcar} (@pxref{Mapping Functions}).
@c They can be passed to @code{mapcar} (@pxref{Mapping Functions}).

@item
Они более производительны.
@c They are more efficient.

@item
Они могут использоваться как @dfn{формы определения значения} (@dfn{place forms})
для сохранения значения (@pxref{Generalized Variables}).
@c They can be used as @dfn{place forms} to store values
@c (@pxref{Generalized Variables}).

@item
Такие функции работают более предсказуемо чем @code{cl-defsubst}
(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs Lisp}).

@c They behave in a more predictable way than @code{cl-defsubst}
@c (@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs
@c Lisp}).
@end itemize

Как @code{defmacro}, функция встраиваемая с использованием @code{define-inline}
наследует правила области видимости (scoping rules), динамическое
или лексическое, из места вызова. @xref{Variable Scoping}.

@c Like @code{defmacro}, a function inlined with @code{define-inline}
@c inherits the scoping rules, either dynamic or lexical, from the call
@c site.  @xref{Variable Scoping}.

Следующий макрос должен быть использован в теле определения функции
@code{define-inline}.

@c The following macros should be used in the body of a function defined
@c by @code{define-inline}.

@defmac inline-quote expression
Выражение закавычивания (quote) @var{expression} для @code{define-inline}.
Данный макрос аналогичен обратной кавычке (@pxref{Backquote}), но заковычивает код
и допускает только @code{,}, не допуская @code{,@@}.

@c Quote @var{expression} for @code{define-inline}.  This is similar to
@c the backquote (@pxref{Backquote}), but quotes code and accepts only
@c @code{,}, not @code{,@@}.
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
Данный макрос похож на @code{let} (@pxref{Local Variables}): он
устанавливает локальные переменные как определено в
@var{bindings}, и после этого вычисляет @var{body}. Каждый элемент @var{bindings}
должен быть символом или иметь форму @w{@code{(@var{var} @var{expr})}};
при этом результат вычисления @var{expr} связывается с @var{var}. Окончанием
@var{bindings}  может быть @code{nil} или символ хранящий список
аргументов. Во втором случае каждый аргумент будет вычислен, и символ
будет связан с полученным списком.

@c This is is similar to @code{let} (@pxref{Local Variables}): it sets up
@c local variables as specified by @var{bindings}, and then evaluates
@c @var{body} with those bindings in effect.  Each element of
@c @var{bindings} should be either a symbol or a list of the form
@c @w{@code{(@var{var} @var{expr})}}; the result is to evaluate
@c @var{expr} and bind @var{var} to the result.  The tail of
@c @var{bindings} can be either @code{nil} or a symbol which should hold
@c a list of arguments, in which case each argument is evaluated, and the
@c symbol is bound to the resulting list.
@end defmac

@defmac inline-const-p expression
Возвращает не-@code{nil} если значение @var{expression}
уже известно.

@c Return non-@code{nil} if the value of @var{expression} is already
@c known.
@end defmac

@defmac inline-const-val expression
Возвращает значение выражения @var{expression}.
@c Return the value of @var{expression}.
@end defmac

@defmac inline-error format &rest args
Сигнализирует об ошибки, форматирования @var{args} в соответствии с форматом @var{format}.
@c Signal an error, formatting @var{args} according to @var{format}.
@end defmac

Ниже пример использования @code{define-inline}:
@c Here's an example of using @code{define-inline}:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
Это определение эквивалентно
@c This is equivalent to

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Calling Functions
@section Вызов функций
@c @section Calling Functions
@cindex function invocation
@cindex calling a function

  Определение функции это только полдела. Функция ничего не делает
пока она не будет @dfn{вызвана} (@dfn{call}), т.е. ей не будет сказано
выполнится. Обращение к функции так же называется вызов (@dfn{invocation}).
@c   Defining functions is only half the battle.  Functions don't do
@c anything until you @dfn{call} them, i.e., tell them to run.  Calling a
@c function is also known as @dfn{invocation}.

  Наиболее общим способом вызова функции является вычисление списка.
Например, вычисление списка @code{(concat "a" "b")} вызовет функцию
@code{concat} с аргументами @code{"a"} и @code{"b"}.
@xref{Evaluation}, для получения информации по вычислению.

@c   The most common way of invoking a function is by evaluating a list.
@c For example, evaluating the list @code{(concat "a" "b")} calls the
@c function @code{concat} with arguments @code{"a"} and @code{"b"}.
@c @xref{Evaluation}, for a description of evaluation.

  При записи списка в качестве выражения программы, определяется какая
будет вызываться функция, и как много ей будет передано аргументов в
тексте программы. Как правило это, то что нужно. Но время от времени нужно
при выполнении программы определить какую нужно вызвать функцию.
В этом случае нужно использовать @code{funcall}. Когда при вызове и
количество аргументов нужно вычислить стоит использовать @code{apply}.

@c   When you write a list as an expression in your program, you specify
@c which function to call, and how many arguments to give it, in the text
@c of the program.  Usually that's just what you want.  Occсasionally you
@c need to compute at run time which function to call.  To do that, use
@c the function @code{funcall}.  When you also need to determine at run
@c time how many arguments to pass, use @code{apply}.

@defun funcall function &rest arguments
@code{funcall} вызывает @var{function} с аргументами @var{arguments},
и возвращает результат выполнения @var{function}.

@c @code{funcall} calls @var{function} with @var{arguments}, and returns
@c whatever @var{function} returns.

Так как @code{funcall} функция, все аргументы, включая @var{function},
вычисляются до выполнения @code{funcall}. Таким образом можно
использовать выражения для определения того, какая функция будет выполняться.
Кроме того получается, что @code{funcall} не видит выражения записанные
для @var{arguments}, а только их значения. Эти выражения @emph{не} вычисляются
второй раз при вызове @var{function}; действие @code{funcall} аналогично
обычной процедуре вызова функции, только аргументы передаются уже вычисленными.

@c Since @code{funcall} is a function, all of its arguments, including
@c @var{function}, are evaluated before @code{funcall} is called.  This
@c means that you can use any expression to obtain the function to be
@c called.  It also means that @code{funcall} does not see the
@c expressions you write for the @var{arguments}, only their values.
@c These values are @emph{not} evaluated a second time in the act of
@c calling @var{function}; the operation of @code{funcall} is like the
@c normal procedure for calling a function, once its arguments have
@c already been evaluated.

Аргумент @var{function} должен быть Lisp функцией или примитивной функцией.
Не допускаются специальные формы или макросы, потому что они могут
правильно работать только когда выражения аргументов не вычисляются заранее.
@code{funcall} не может этого реализовать, что было описано выше.

@c The argument @var{function} must be either a Lisp function or a
@c primitive function.  Special forms and macros are not allowed, because
@c they make sense only when given the unevaluated argument
@c expressions.  @code{funcall} cannot provide these because, as we saw
@c above, it never knows them in the first place.

Если нужно использовать @code{funcall} для вызова команды и сделать
это как будто она выполняется интерактивно стоит использовать
@code{funcall-interactively} (@pxref{Interactive Call}).

@c If you need to use @code{funcall} to call a command and make it behave
@c as if invoked interactively, use @code{funcall-interactively}
@c (@pxref{Interactive Call}).

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Invalid function: #<subr and>
@end group
@end example

Сравните примеры с примерами для @code{apply}.
@c Compare these examples with the examples of @code{apply}.
@end defun

@defun apply function &rest arguments
@code{apply} вызывает @var{function} с аргументами @var{arguments},
как @code{funcall} с одним отличием: аргумент @var{arguments} это
списочный объект, который передается в @var{function} в качестве отдельных
аргументов, а не одним списком. Будем говорить, что @code{apply}
@dfn{раскрывает} (@dfn{spread}) список понимая под этим, что каждый отдельный
элемент становится аргументом.
@c @code{apply} calls @var{function} with @var{arguments}, just like
@c @code{funcall} but with one difference: the last of @var{arguments} is a
@c list of objects, which are passed to @var{function} as separate
@c arguments, rather than a single list.  We say that @code{apply}
@c @dfn{spreads} this list so that each individual element becomes an
@c argument.

@code{apply} возвращает результат вызова @var{function}. Так же как для
@code{funcall}, @var{function} должна быть Lisp функцией или
примитивной функцией; специальные формы и макросы не могут выполняться
через @code{apply}.

@c @code{apply} returns the result of calling @var{function}.  As with
@c @code{funcall}, @var{function} must either be a Lisp function or a
@c primitive function; special forms and macros do not make sense in
@c @code{apply}.

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

Больше интересных примером использования @code{apply} можно найти
в @ref{Defintion of mapcar}.

@c For an interesting example of using @code{apply}, see @ref{Definition
@c of mapcar}.
@end defun

@cindex partial application of functions
@cindex currying
  Временами бывает полезным зафиксировать часть аргументов функции
в какие-то значения, и передавать только часть аргументов при вызове
функции. Такое действие по фиксированию части аргументов называется
@dfn{частичное применение} (@dfn{partial application}) функции
@footnote{Данное действие связано, но отличается от @dfn{каррирования}
которое заключается в преобразовании функции принимающей множество аргументов
в последовательность функций принимающих один аргумент}.
Результатом является новая функция которая принимает часть аргументов
и вызывает оригинальную функцию со всеми аргументами.

@c   Sometimes it is useful to fix some of the function's arguments at
@c certain values, and leave the rest of arguments for when the function
@c is actually called.  The act of fixing some of the function's
@c arguments is called @dfn{partial application} of the function@footnote{
@c This is related to, but different from @dfn{currying}, which
@c transforms a function that takes multiple arguments in such a way that
@c it can be called as a chain of functions, each one with a single
@c argument.}.
@c The result is a new function that accepts the rest of
@c arguments and calls the original function with all the arguments
@c combined.

  Ниже описывается способ создания частичного применения в Emacs Lisp.
  @c Here's how to do partial application in Emacs Lisp:

@defun apply-partially func &rest args
Функция возвращает новую функцию, которая когда вызывается, вызовет
@var{func} со списком аргументов состоящем из @var{args} и дополнительных
аргументов заданных при вызове. Если @var{func} принимает @var{n} аргументов,
тогда вызов @code{apply-partially} с @w{@code{@var{m} < @var{n}}} аргументами
будет создавать новую функцию @w{@code{@var{n} - @var{m}}} аргументов.

@c This function returns a new function which, when called, will call
@c @var{func} with the list of arguments composed from @var{args} and
@c additional arguments specified at the time of the call.  If @var{func}
@c accepts @var{n} arguments, then a call to @code{apply-partially} with
@c @w{@code{@var{m} < @var{n}}} arguments will produce a new function of
@c @w{@code{@var{n} - @var{m}}} arguments.

Ниже показано как можно определить встроенную функцию @code{1+},
если она не задана, с использованием @code{apply-partially} и
@code{+}, другой встроенной функции:

@c Here's how we could define the built-in function @code{1+}, if it
@c didn't exist, using @code{apply-partially} and @code{+}, another
@c built-in function:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Increment argument by one.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  В Lisp функции могут принимать другие функции в качестве аргументов
или находить их в структурах данных (особенно в переменных перехватчиков
или списках свойств) и вызывать их с использованием @code{funcall} или
@code{apply}. Функции, которые принимают функции в качестве аргументов
часто называют @dfn{функционалами} (@dfn{functionals}).

@c   It is common for Lisp functions to accept functions as arguments or
@c find them in data structures (especially in hook variables and property
@c lists) and call them using @code{funcall} or @code{apply}.  Functions
@c that accept function arguments are often called @dfn{functionals}.

  Иногда, при вызове функционала, нужно передать функцию заглушку (которая ничего не делает).
Есть два вида функций которые ничего не делают:

@c   Sometimes, when you call a functional, it is useful to supply a no-op
@c function as the argument.  Here are two different kinds of no-op
@c function:

@defun identity arg
Функция возвращает @var{arg} и не имеет побочных эффектов.
@c This function returns @var{arg} and has no side effects.
@end defun

@defun ignore &rest args
Функция игнорирует любые аргументы и возвращает @code{nil}.
@c This function ignores any arguments and returns @code{nil}.
@end defun

  Некоторые функции доступны пользователю @dfn{commands}, которые
к тому же могут быть вызваны интерактивно (как правило при помощи определенной комбинации клавиш).
Так же возможно вызвать такую команду, как если бы она была вызвана
интерактивно используя функцию @code{call-interactively}. @xref{Interactive Call}.
  
@c   Some functions are user-visible @dfn{commands}, which can be called
@c interactively (usually by a key sequence).  It is possible to invoke
@c such a command exactly as though it was called interactively, by using
@c the @code{call-interactively} function.  @xref{Interactive Call}.

@node Mapping Functions
@section Функции Отображения
@c @section Mapping Functions
@cindex mapping functions

  @dfn{Функции отображения} (@dfn{mapping function}) применяют заданную
функцию (@emph{не} специальную форму или макрос) к каждому элементу списка
или другой коллекции. Emacs Lisp имеет несколько таких функций; данный
раздел описывает @code{mapcar}, @code{mapc}, и @code{mapconcat}, которые
выполняют отображение для списка. @xref{Definition of mapatoms}, с описанием
@code{mapatoms} которая выполняет отображение символов в obarray. @xref{Definition of
maphash}, с описанием @code{maphash}, которая выполняет отображение для пар ключ-значение
в хеш таблице.

@c   A @dfn{mapping function} applies a given function (@emph{not} a
@c special form or macro) to each element of a list or other collection.
@c Emacs Lisp has several such functions; this section describes
@c @code{mapcar}, @code{mapc}, and @code{mapconcat}, which map over a
@c list.  @xref{Definition of mapatoms}, for the function @code{mapatoms}
@c which maps over the symbols in an obarray.  @xref{Definition of
@c maphash}, for the function @code{maphash} which maps over key/value
@c associations in a hash table.

  Рассматриваемые функции отображения не принимают символьные таблицы,
потому что символьные таблицы являются разреженными массивами набор значений
в которых очень большой. Для выполнения отображения таблиц символов
способом который учитывает их структуру, стоит использовать @code{map-char-table}.
(@pxref{Char-Tables}).

@c   These mapping functions do not allow char-tables because a char-table
@c is a sparse array whose nominal range of indices is very large.  To map
@c over a char-table in a way that deals properly with its sparse nature,
@c use the function @code{map-char-table} (@pxref{Char-Tables}).

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar} применяет @var{function} к каждому элементу @var{sequence}
по очереди, и возвращает список результатов.

@c @code{mapcar} applies @var{function} to each element of @var{sequence}
@c in turn, and returns a list of the results.

Аргумент @code{sequence} может быть любым видом последовательности
за исключением символьной таблицы, то есть списком, вектором, двоичным вектором или строкой.
Результат всегда является списком. Длина результата равна длине
@code{sequence}. Например:

@c The argument @var{sequence} can be any kind of sequence except a
@c char-table; that is, a list, a vector, a bool-vector, or a string.  The
@c result is always a list.  The length of the result is the same as the
@c length of @var{sequence}.  For example:

@example
@group
(mapcar 'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar '1+ [1 2 3])
     @result{} (2 3 4)
(mapcar 'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{Call each function in @code{my-hooks}.}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Apply FUNCTION to successive cars of all ARGS.
Return the list of results."
  ;; @r{If no list is exhausted,}
  (if (not (memq nil args))
      ;; @r{apply function to @sc{car}s.}
      (cons (apply function (mapcar 'car args))
            (apply 'mapcar* function
                   ;; @r{Recurse for rest of elements.}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* 'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc} как @code{mapcar} за исключением того, что @var{function}
используется только ради побочных эффектов---при этом возвращаемые значения
игнорируются, а не собираются в список. @code{mapc} всегда возвращает
@var{sequence}.

@c @code{mapc} is like @code{mapcar} except that @var{function} is used for
@c side-effects only---the values it returns are ignored, not collected
@c into a list.  @code{mapc} always returns @var{sequence}.
@end defun

@defun mapconcat function sequence separator
@code{mapconcat} применяет функцию @var{function} к каждому элементу
@var{sequence}, а результаты, которые должны быть последовательностями
символов (строк, векторов или списков), объединяются в одну строку, которая
является возвращаемым значением. Между элементами возвращаемой последовательности
вставляется @var{separator}, который тоже должен быть строкой или вектором
или списком символов (знаков). @xref{Sequences Arrays Vectors}.

@c @code{mapconcat} applies @var{function} to each element of
@c @var{sequence}; the results, which must be sequences of characters
@c (strings, vectors, or lists), are concatenated into a single string
@c return value.  Between each pair of result sequences, @code{mapconcat}
@c inserts the characters from @var{separator}, which also must be a
@c string, or a vector or list of characters.  @xref{Sequences Arrays
@c Vectors}.

Аргумент @var{function} должен быть функцией, которая принимает один аргумент
и возвращает последовательность символов(знаков): строку, вектор, или
список. Аргумент @var{sequences} может быть любым видом последовательности
за исключением таблицы символов, то есть списком, вектором, двоичным вектором
или строкой.

@c The argument @var{function} must be a function that can take one
@c argument and returns a sequence of characters: a string, a vector, or
@c a list.  The argument @var{sequence} can be any kind of sequence
@c except a char-table; that is, a list, a vector, a bool-vector, or a
@c string.

@example
@group
(mapconcat 'symbol-name
           '(The cat in the hat)
           " ")
     @result{} "The cat in the hat"
@end group

@group
(mapconcat (function (lambda (x) (format "%c" (1+ x))))
           "HAL-8000"
           "")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section Анонимные функции
@c @section Anonymous Functions
@cindex anonymous function

  Хотя функции как правило определяются с использованием @code{defun}
и при этом сразу задается имя, иногда бывает удобно использовать
явное lambda выражение---@dfn{анонимную функцию} (@dfn{anonymous function}).
Анонимные функции применимы там же где и имена функций. Часто они
присваиваются переменным, или передаются в качестве аргументов
при вызове функций, например можно передать такую функцию в качестве аргумента
@var{function} в @code{mapcar}, который применит ее ко всем элементам
списка (@pxref{Mapping Functions}). @xref{describe-symbols example}, с
более полезным примером.

@c   Although functions are usually defined with @code{defun} and given
@c names at the same time, it is sometimes convenient to use an explicit
@c lambda expression---an @dfn{anonymous function}.  Anonymous functions
@c are valid wherever function names are.  They are often assigned as
@c variable values, or as arguments to functions; for instance, you might
@c pass one as the @var{function} argument to @code{mapcar}, which
@c applies that function to each element of a list (@pxref{Mapping
@c Functions}).  @xref{describe-symbols example}, for a realistic example
@c of this.

  При определении lambda выражения, которое должно использоваться
в качестве анонимной функции, в принципе можно использовать любой метод
для создания списка. Но обычно используется @code{lambda} макрос, или
специальная форма @code{function}, или @code{#'} синтаксис:

@c   When defining a lambda expression that is to be used as an anonymous
@c function, you can in principle use any method to construct the list.
@c But typically you should use the @code{lambda} macro, or the
@c @code{function} special form, or the @code{#'} read syntax:

@defmac lambda args [doc] [interactive] body@dots{}
Макрос возвращает анонимную функцию со списком аргументов @var{args},
строкой документации @var{doc} (если задано), конфигурацией
интерактивного вызова @var{interactive} (если задано), и телом
заданным @var{body}.

@c This macro returns an anonymous function with argument list
@c @var{args}, documentation string @var{doc} (if any), interactive spec
@c @var{interactive} (if any), and body forms given by @var{body}.

Данный макрос создает само-вычислимую @code{lambda} форму:
вычисление формы, @sc{car} которой @code{lambda} производит
саму эту форму:

@c In effect, this macro makes @code{lambda} forms self-quoting:
@c evaluating a form whose @sc{car} is @code{lambda} yields the form
@c itself:

@example
(lambda (x) (* x x))
     @result{} (lambda (x) (* x x))
@end example

@code{lambda} форма имеет свойство, сообщить вычислителю Emacs или
байт-компилятору, что аргумент формы это функция, путем использования
@code{fucntion} в качестве подпрограммы (см. ниже).

@c The @code{lambda} form has one other effect: it tells the Emacs
@c evaluator and byte-compiler that its argument is a function, by using
@c @code{function} as a subroutine (see below).
@end defmac

@defspec function function-object
@cindex function quoting
Специальная форма возвращает @var{function-object} без его вычисления.
То есть, данная форма схожа с @code{quote} (@pxref{Quoting}). Но в отличие
от @code{quote}, форма служит в качестве указания вычислителю Emacs и
байт-компилятору, что @var{function-object} предназначен для использования
в качестве функции. Полагая, что @var{function-object} корректное lambda
выражение, выполнение формы будет иметь два эффекта:

@c This special form returns @var{function-object} without evaluating it.
@c In this, it is similar to @code{quote} (@pxref{Quoting}).  But unlike
@c @code{quote}, it also serves as a note to the Emacs evaluator and
@c byte-compiler that @var{function-object} is intended to be used as a
@c function.  Assuming @var{function-object} is a valid lambda
@c expression, this has two effects:

@itemize
@item
При компиляции кода байт-компилятором, @var{function-object} будет
скомпилирован в байт код функции (@pxref{Byte Compilation}).

@c When the code is byte-compiled, @var{function-object} is compiled into
@c a byte-code function object (@pxref{Byte Compilation}).

@item
Если активно лексическое связывание, @var{function-object} будет преобразован
в замыкание. @xref{Closures}.

@c When lexical binding is enabled, @var{function-object} is converted
@c into a closure.  @xref{Closures}.
@end itemize
@end defspec

@cindex @samp{#'} syntax
Синтаксис чтения @code{#'} является краткой записью @code{function}.
Следующие формы эквиваленты:

@c The read syntax @code{#'} is a short-hand for using @code{function}.
@c The following forms are all equivalent:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  В следующем примере, определяется функция @code{change-property}
которая получает функцию в качестве третьего аргумента, и следующую
за ней функцию @code{double-property} которая использует
@code{change-property} и передает ей анонимную функцию в качестве аргумента:

@c   In the following example, we define a @code{change-property}
@c function that takes a function as its third argument, followed by a
@c @code{double-property} function that makes use of
@c @code{change-property} by passing it an anonymous function:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
@code{lambda} форму не нужно квотировать (закавычивать).

@c Note that we do not quote the @code{lambda} form.

  Если скомпилировать код из примера выше, анонимная функция тоже будет
скомпилирована. При этом, если создать анонимную функцию с помощью квотирования
списка, она скомпилирована не будет:

@c   If you compile the above code, the anonymous function is also
@c compiled.  This would not happen if, say, you had constructed the
@c anonymous function by quoting it as a list:

@c Do not unquote this lambda!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
В этом случае, анонимная функция остается lambda выражением в скомпилированном
коде. Байт-компилятор не считает, что этот список функция, хотя он и похож на функцию,
так как компилятор не знаю, что @code{change-property} будет использовать
эту функцию в качестве функции.

@c In that case, the anonymous function is kept as a lambda expression in
@c the compiled code.  The byte-compiler cannot assume this list is a
@c function, even though it looks like one, since it does not know that
@c @code{change-property} intends to use it as a function.

@node Generic Functions
@section Обобщенные Функции
@c @section Generic Functions
@cindex generic functions
@cindex polymorphism

  Функции определенные с использованием @code{defun} имеют строго
определенные представления о типах и ожидаемых значениях аргументов.
Например, функция которая созданная для обработки значений являющихся
числами или списками чисел, завершится с ошибкой если будет
вызвана со значениями других типов, например с векторами или строками.
Так происходит потому что, функция не готова работать с типами отличными
от тех для работы с которыми она разработана.

@c   Functions defined using @code{defun} have a hard-coded set of
@c assumptions about the types and expected values of their arguments.
@c For example, a function that was designed to handle values of its
@c argument that are either numbers or lists of numbers will fail or
@c signal an error if called with a value of any other type, such as a
@c vector or a string.  This happens because the implementation of the
@c function is not prepared to deal with types other than those assumed
@c during the design.

  В отличие от этого, объектно ориентированные программы используют
@dfn{полиморфные функции} (@dfn{polymorphic functions}), которые являются
множеством специализированных функций с одним именем, каждая из которых
может обрабатывать определенный конкретный набор типов аргументов.
Какая именно будет вызвана функция определяется во время выполнения
на основе типов переданных параметров.

@c   By contrast, object-oriented programs use @dfn{polymorphic
@c functions}: a set of specialized functions having the same name, each
@c one of which was written for a certain specific set of argument types.
@c Which of the functions is actually called is decided at run time based
@c on the types of the actual arguments.

@cindex CLOS
  Emacs предоставляет поддержку полиморфизма. Как и другие Lisp окружения,
в частности Common Lisp и его Common Lisp Object System (@acronym{CLOS}),
данная возможность базируется на @dfn{обобщенных функциях} (@dfn{generic functions}).
Обобщенные функции в Emacs очень похожи на @acronym{CLOS}, в том числе
используются похожие имена, поэтому если вы работали с @acronym{CLOS},
следующая часть будет знакомой.

@c   Emacs provides support for polymorphism.  Like other Lisp
@c environments, notably Common Lisp and its Common Lisp Object System
@c (@acronym{CLOS}), this support is based on @dfn{generic functions}.
@c The Emacs generic functions closely follow @acronym{CLOS}, including
@c use of similar names, so if you have experience with @acronym{CLOS},
@c the rest of this section will sound very familiar.

  Обобщенная функция определяет абстрактное действие, путем определения
его имени и списка аргументов, но (обычно) не определяющее реализацию.
Реализация для разных конкретных классов аргументов предоставляется
@dfn{методов} (@dfn{methods}), которые должны быть определены отдельно.
Каждый метод который содержит реализацию обобщенной функции имеет то же
имя, что и обобщенная функция, но в определение метода так же определяется
с какими видами аргументов он работает, путем @dfn{специализации} (@dfn{specializing})
аргументов в определении метода. @dfn{специализация аргументов} (@dfn{arguments specializers})
может быть более или менее строгой (узкой), например тип @code{string} это более
строгая специализация чем, более общий тип @code{sequence}.

@c   A generic function specifies an abstract operation, by defining its
@c name and list of arguments, but (usually) no implementation.  The
@c actual implementation for several specific classes of arguments is
@c provided by @dfn{methods}, which should be defined separately.  Each
@c method that implements a generic function has the same name as the
@c generic function, but the method's definition indicates what kinds of
@c arguments it can handle by @dfn{specializing} the arguments defined by
@c the generic function.  These @dfn{argument specializers} can be more
@c or less specific; for example, a @code{string} type is more specific
@c than a more general type, such as @code{sequence}.

  Стоит отменить, что в отличие от ООП языков на основе передачи
сообщений, таких как C@t{++} и Simula, методы выполняемые обобщенными
функциями не относятся к классу, они относятся к обобщенной функции которую
они реализуют.

@c   Note that, unlike in message-based OO languages, such as C@t{++} and
@c Simula, methods that implement generic functions don't belong to a
@c class, they belong to the generic function they implement.

  При выполнении обобщенной функции, определяется применимый метод,
путем сравнения фактических аргументов переданных в вызов со специализациями
аргументов методов обобщенной функции. Метод применим если
фактические аргументы вызова совместимы со специализацией метода.
Если применимо более одного метода, они комбинируются, по
заданным правилам (см. ниже) и полученная комбинация используется
для обработки вызова.

@c   When a generic function is invoked, it selects the applicable
@c methods by comparing the actual arguments passed by the caller with
@c the argument specializers of each method.  A method is applicable if
@c the actual arguments of the call are compatible with the method's
@c specializers.  If more than one method is applicable, they are
@c combined using certain rules, described below, and the combination
@c then handles the call.

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
Макрос определяет обобщенную функцию с именем @var{name}
и @var{arguments}. Если @var{body} задано, оно считается поведением
по умолчанию. Если @var{documentation} задано (желательно, чтобы
оно всегда было), оно задает строку документации для обобщенной функции, в
форме @code{(:documentation @var{docstring})}. Не обязательный аргументы
@var{options-and-methods} могут иметь следующие формы:

@c This macro defines a generic function with the specified @var{name}
@c and @var{arguments}.  If @var{body} is present, it provides the
@c default implementation.  If @var{documentation} is present (it should
@c always be), it specifies the documentation string for the generic
@c function, in the form @code{(:documentation @var{docstring})}.  The
@c optional @var{options-and-methods} can be one of the following forms:

@table @code
@item (declare @var{declarations})
Форма декларации, как описано в @ref{Declare Form}.
@item (:arument-precedence-order &rest @var{args})
Данная форма влияет на порядок сортировки применимых методов.
Обычно, когда два метода сравниваются при комбинировании, аргументы
проверяются слева направо, и первым будет метод чей соответствующий аргумент
является более специализированным. Порядок, определяемый данной формой
изменяет это поведение, и аргументы сравниваются в порядке задаваемом
данной формой, а не слева направо.
@item (:method [@var{qualifiers}@dots{}] args &rest body)
Данная форма определяет метод как это делает @code{cl-defmethod}.

@c A declare form, as described in @ref{Declare Form}.
@c @item (:argument-precedence-order &rest @var{args})
@c This form affects the sorting order for combining applicable methods.
@c Normally, when two methods are compared during combination, method
@c arguments are examined left to right, and the first method whose
@c argument specializer is more specific will come before the other one.
@c The order defined by this form overrides that, and the arguments are
@c examined according to their order in this form, and not left to right.
@c @item (:method [@var{qualifiers}@dots{}] args &rest body)
@c This form defines a method like @code{cl-defmethod} does.
@c @end table
@end defmac

@defmac cl-defmethod name [qualifier] arguments &rest [docstring] body
Макрос определяет конкретную реализацию для обобщенной функции
с именем @var{name}. Код реализации задается в @var{body}. Если
задано, @var{docstring}, от оно будет использовано как строка
документации для метода. Список @var{arguments}, которые должны
быть идентичны во всех методах реализующих обобщенную функцию, и
соответствовать списку аргументов данной функции, предоставляют
специализацию в форме @code{(@var{arg} @var{spec})}, где @var{arg}
имя аргумента, такое же как было задано в вызове @code{cl-defgeneric},
а @var{spec} одна из следующих форм специализации:

@c This macro defines a particular implementation for the generic
@c function called @var{name}.  The implementation code is given by
@c @var{body}.  If present, @var{docstring} is the documentation string
@c for the method.  The @var{arguments} list, which must be identical in
@c all the methods that implement a generic function, and must match the
@c argument list of that function, provides argument specializers of the
@c form @code{(@var{arg} @var{spec})}, where @var{arg} is the argument
@c name as specified in the @code{cl-defgeneric} call, and @var{spec} is
@c one of the following specializer forms:
 
@table @code
@item @var{type}
Данная специализация требует, чтобы аргумент был заданного типа @var{type},
или одного из типов в иерархии, что будет описана ниже.
@c This specializer requires the argument to be of the given @var{type},
@c one of the types from the type hierarchy described below.
@item (eql @var{object})
Данная специализация требует, чтоб аргумент был @code{eql} заданному
@var{object}.
@c This specializer requires the argument be @code{eql} to the given
@c @var{object}.
@item (head @var{object})
Аргумент должен быть cons ячейкой, чей @code{car} @code{eql}
@var{object}.
@c The argument must be a cons cell whose @code{car} is @code{eql} to
@c @var{object}.
@item @var{struct-tag}
Аргумент должен быть экземпляром класса с именем @var{struct-tag}
определенному с использованием @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp
Extensions for GNU Emacs Lisp}), или одного из его родительских классов. (Прим. возможно дочерних ?)
@c The argument must be an instance of a class named @var{struct-tag}
@c defined with @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp
@c Extensions for GNU Emacs Lisp}), or of one of its parent classes.
@end table

Кроме того, специализация аргумента может быть задана в форме
@code{&context (@var{expr} @var{spec})}, @var{expr} при этом должно
быть совместимо со специализацией задаваемой @var{spec}; @var{spec} может
быть одно из описанных выше форм. Другими словами, данная форма использует
значение @var{expr} вместо аргументов для принятия решения о применимости
метода. Например, для формы @code{&context (overwrite-mode (eql t))}
метод будет применим, только когда @code{overwrite-mode}
включено.

@c Alternatively, the argument specializer can be of the form
@c @code{&context (@var{expr} @var{spec})}, in which case the value of
@c @var{expr} must be compatible with the specializer provided by
@c @var{spec}; @var{spec} can be any of the forms described above.  In
@c other words, this form of specializer uses the value of @var{expr}
@c instead of arguments for the decision whether the method is
@c applicable.  For example, @code{&context (overwrite-mode (eql t))}
@c will make the method compatible only when @code{overwrite-mode} is
@c turned on.

Специализация типа, @code{(@var{arg} @var{type})}, может задавать
один из @dfn{системных типов} (@dfn{system type}) перечисленных ниже.
Когда задан родительский тип, аргумент чей тип относится к более
специфичному дочернему типа, так же как и ``внчатому''(grand-children) и
``правнучатому'' (grand-grand-children) и т.д. так же будут совместимы.

@c The type specializer, @code{(@var{arg} @var{type})}, can specify one
@c of the @dfn{system types} in the following list.  When a parent type
@c is specified, an argument whose type is any of its more specific child
@c types, as well as grand-children, grand-grand-children, etc. will also
@c be compatible.

@table @code
@item integer
Родительский тип: @code{number}.
@c Parent type: @code{number}.
@item number
@item null
Родительский тип: @code{symbol}.
@c Parent type: @code{symbol}
@item symbol
@item string
Родительский тип: @code{array}.
@c Parent type: @code{array}.
@item array
Родительский тип: @code{sequence}.
@c Parent type: @code{sequence}.
@item cons
Родительский тип: @code{list}.
@c Parent type: @code{list}.
@item list
Родительский тип: @code{sequence}.
@c Parent type: @code{sequence}.
@item marker
@item overlay
@item float
Родительский тип: @code{number}.
@c Parent type: @code{number}.
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
Родительский тип: @code{array}.
@c Parent type: @code{array}.
@item bool-vector
Родительский тип: @code{array}.
@c Parent type: @code{array}.
@item vector
Родительский тип: @code{array}.
@c Parent type: @code{array}.
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

Не обязательный @var{qualifier} позволяет комбинировать несколько применимых
методов. Если @var{qualifier} не задан, определяемый метод является
@dfn{основным} (@dfn{primary}) методом, предоставляющий основную
реализацию обобщенной функции для данной специализации аргументов.
Может определить @dfn{вспомогательные методы} (@dfn{auxiliary methods}),
используя одно из следующих значений в качестве @var{qualifier}:

@c The optional @var{qualifier} allows combining several applicable
@c methods.  If it is not present, the defined method is a @dfn{primary}
@c method, responsible for providing the primary implementation of the
@c generic function for the specialized arguments.  You can also define
@c @dfn{auxiliary methods}, by using one of the following values as
@c @var{qualifier}:

@table @code
@item :before
Данный вспомогательный метод будет выполнен перед основным методом.
Более точно, все @code{:before} методы будут выполнены до основного,
в порядке от более специализированного к менее.

@c This auxiliary method will run before the primary method.  More
@c accurately, all the @code{:before} methods will run before the
@c primary, in the most-specific-first order.
@item :after
Данный вспомогательный метод будет выполнен после основного метода.
Более точно, все @code{:after} методы будут выполнены после основного,
в порядке от менее специализированного к более.

@c This auxiliary method will run after the primary method.  More
@c accurately, all such methods will run after the primary, in the
@c most-specific-last order.
@item :around
Вспомогательный метод будет запущен @emph{вместо} основного
метода. Более специализированные методы будут запускаться
раньше. Такие методы, как правило используют @code{cl-call-next-method},
описанный ниже, для запуска других вспомогательных или основных
методов.

@c This auxiliary method will run @emph{instead} of the primary method.
@c The most specific of such methods will be run before any other method.
@c Such methods normally use @code{cl-call-next-method}, described below,
@c to invoke the other auxiliary or primary methods.
@item :extra @var{string}
Позволяет добавить больше методов, отличающихся @var{string},
для одной специализации и определителя (qualifier).
@c This allows you to add more methods, distinguished by @var{string},
@c for the same specializers and qualifiers.
@end table
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
Каждый раз при вызове обобщенной функции, строится @dfn{эффективный метод}
(@dfn{effective method}), для обработки вызова, путем комбинирования
применимых методов функции. Процесс определения применимых методов
и создания эффективного метода называется @dfn{диспетчеризация} (@dfn{dispatch}, @dfn{отправка сообщения ?}).
Применимые методы, это все методы специализация которых совместима с фактическими аргументами вызова.
Методы которые явно специализируют более одного аргумента
называются @dfn{методами с множественной диспетчеризацией}
(@dfn{multiple-dispatch methods}).

@c Each time a generic function is called, it builds the @dfn{effective
@c method} which will handle this invocation by combining the applicable
@c methods defined for the function.  The process of finding the
@c applicable methods and producing the effective method is called
@c @dfn{dispatch}.  The applicable methods are those all of whose
@c specializers are compatible with the actual arguments of the call.
@c Since all of the arguments must be compatible with the specializers,
@c they all determine whether a method is applicable.  Methods that
@c explicitly specialize more than one argument are called
@c @dfn{multiple-dispatch methods}.

Применимые методы сортируются в порядке к котором
они будут скомбинированы. Метод, чей самый левый операнд наиболее специфичен
будет стоять сначала (то есть по операндам от левого к правому, более специфичные
сначала.) (Задание @code{:argument-precedence-order} при определении
@code{cl-defmethod}, может изменить порядок, как описано выше.) Если
тело метода вызывает @code{cl-call-next-method}, будет запущен следующий
наиболее специфичный метод.
Если есть применимые @code{:around} методы, наиболее специфичный из них
будет запущен, метод может использовать @code{cl-call-next-method} для
запуска других менее специфичных @code{:around} методов. Затем вызываются
@code{:before} методы в порядке специфичности, затем выполняются
основные (primary) методы, и в завершении @code{:after} методы в
обратном порядке в соответствии со специфичностью.

@c The applicable methods are sorted into the order in which they will be
@c combined.  The method whose left-most argument specializer is the most
@c specific one will come first in the order.  (Specifying
@c @code{:argument-precedence-order} as part of @code{cl-defmethod}
@c overrides that, as described above.)  If the method body calls
@c @code{cl-call-next-method}, the next most-specific method will run.
@c If there are applicable @code{:around} methods, the most-specific of
@c them will run first; it should call @code{cl-call-next-method} to run
@c any of the less specific @code{:around} methods.  Next, the
@c @code{:before} methods run in the order of their specificity, followed
@c by the primary method, and lastly the @code{:after} methods in the
@c reverse order of their specificity.

@defun cl-call-next-method &rest args
При выполнении внутри тела основного (primary) или @code{:around}
вспомогательного метода, вызывает следующий применимый метод той же
обобщенной функции. Обычно, вызывается без аргументов, что означает
вызов следующего применимого метода с теми же аргументами, что
и метод из которого вызывается cl-call-next-method. Иначе, будут использованы
переданные аргументы.

@c When invoked from within the lexical body of a primary or an
@c @code{:around} auxiliary method, call the next applicable method for
@c the same generic function.  Normally, it is called with no arguments,
@c which means to call the next applicable method with the same arguments
@c that the calling method was invoked.  Otherwise, the specified
@c arguments are used instead.
@end defun

@defun cl-next-method-p
Функция при вызове из тела основного(primary) или @code{:around} вспомогательного
метода, возвращает non-@code{nil} если есть следующий метод для вызова.

@c This function, when called from within the lexical body of a primary
@c or an @code{:around} auxiliary method, returns non-@code{nil} if there
@c is a next method to call.
@end defun


@node Function Cells
@section Обращение к Содержимому Ячейки Функции
@c @section Accessing Function Cell Contents

  @dfn{Определение функции} (@dfn{function definition}) символа это объект
сохраненный в ячейки функции символа. Функции в данном разделе описывают
получение доступа, выполнение проверки, и установки значения ячейки функции
символа.

@c   The @dfn{function definition} of a symbol is the object stored in the
@c function cell of the symbol.  The functions described here access, test,
@c and set the function cell of symbols.

  См. @code{inderect-function}. @xref{Definition of inderect-function}.
@c   See also the function @code{indirect-function}.  @xref{Definition of
@c indirect-function}.

@defun symbol-function symbol
@kindex void-function
Функция возвращает объект из ячейки функции @var{symbol}. Проверка на
то, что возвращаемый объект корректная функция не выполняется.

@c This returns the object in the function cell of @var{symbol}.  It does
@c not check that the returned object is a legitimate function.

Если значение ячейки функции не определено, возвращается @code{nil}.
Для того, чтобы отличить отсутствие значения от значения @code{nil},
стоит использовать @code{fboundp} (см. ниже).

@c If the function cell is void, the return value is @code{nil}.  To
@c distinguish between a function cell that is void and one set to
@c @code{nil}, use @code{fboundp} (see below).

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} (lambda (n) (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  Если для символа никогда не задавалось определение функции, считается
что ячейка функции имеет значение @dfn{void} (@dfn{пусто}). То есть,
ячейка функции не имеет никакого значения. Если попытаться вызвать
такой символ как функцию, Emacs просигнализирует об ошибке @code{void-function}.

@c   If you have never given a symbol any function definition, we say
@c that that symbol's function cell is @dfn{void}.  In other words, the
@c function cell does not have any Lisp object in it.  If you try to call
@c the symbol as a function, Emacs signals a @code{void-function} error.

  Отметим, что void(пусто) не то же самое, что @code{nil} или
символ @code{void}. Символы @code{nil} и @code{void} являются Lisp
объектами, и могут быть сохранены в ячейку функции как и любой другой
объект(и они даже могут быть корректными функциями если определить их
с помощью @code{defun}). При этом void ячейка функции не содержит вообще никакого
значения.

@c   Note that void is not the same as @code{nil} or the symbol
@c @code{void}.  The symbols @code{nil} and @code{void} are Lisp objects,
@c and can be stored into a function cell just as any other object can be
@c (and they can be valid functions if you define them in turn with
@c @code{defun}).  A void function cell contains no object whatsoever.

  Проверить ячейку на пустоту можно с помощью функции @code{fboundp}. После
задания для символа значения функции, снова сделать ячейку функции пустой
можно с помощью функции @code{fmakunbound}.

@c   You can test the voidness of a symbol's function definition with
@c @code{fboundp}.  After you have given a symbol a function definition, you
@c can make it void once more using @code{fmakunbound}.

@defun fboundp symbol
Функция возвращает @code{t} если ячейка функции символа имеет значение,
иначе @code{nil}. Данная функция не проверяет, что значение ячейки
является корректной функцией.

@c This function returns @code{t} if the symbol has an object in its
@c function cell, @code{nil} otherwise.  It does not check that the object
@c is a legitimate function.
@end defun

@defun fmakunbound symbol
Функция выполняет очистку значения ячейки функции символа @var{symbol}.
После чего попытка вызвать данную функцию приведет к ошибке @code{void-function}.
Функция возвращает @var{symbol}. (См. так же @code{makunbound} в @ref{Void Variables}.)

@c This function makes @var{symbol}'s function cell void, so that a
@c subsequent attempt to access this cell will cause a
@c @code{void-function} error.  It returns @var{symbol}.  (See also
@c @code{makunbound}, in @ref{Void Variables}.)

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void: foo
@end group
@end example
@end defun

@defun fset symbol definition
Функция сохраняет @var{definitoin} в ячейку функции символа @var{symbol}.
Результатом является @var{definition}. Как правило @var{definition} должно
быть функцией или именем функции, но такая проверка не выполняется.
Аргумент @var{symbol} является обычным аргументом (он вычисляется).

@c This function stores @var{definition} in the function cell of
@c @var{symbol}.  The result is @var{definition}.  Normally
@c @var{definition} should be a function or the name of a function, but
@c this is not checked.  The argument @var{symbol} is an ordinary evaluated
@c argument.

В основном функция используется как вспомогательная в конструкциях которые
определяют или изменяют функции, таких как @code{defun} или @code{advice-add}
(@pxref{Advising Functions}). Так же функция может использоваться для
сохранения в ячейку функции объекта не являющегося функцией, например,
клавиатурного макроса (@pxref{Keyborad Macros}):

@c The primary use of this function is as a subroutine by constructs that define
@c or alter functions, like @code{defun} or @code{advice-add} (@pxref{Advising
@c Functions}).  You can also use it to give a symbol a function definition that
@c is not a function, e.g., a keyboard macro (@pxref{Keyboard Macros}):

@example
;; @r{Define a named keyboard macro.}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

Если нужно сделать синоним для функции, то вместо @code{fset},
лучше использовать @code{defalias}. @xref{Definition of defalias}.

@c It you wish to use @code{fset} to make an alternate name for a
@c function, consider using @code{defalias} instead.  @xref{Definition of
@c defalias}.
@end defun

@node Closures
@section Замыкание
@c @section Closures

  Как описано в @ref{Variable Scoping}, Emacs может поддерживать
лексическое связывание для переменных. При включенном лексическом
связывании, любая созданная именованная функция (например, с помощью @code{defun}),
как и любая анонимная функция, которая создается с использованием @code{lambda}
макроса или специальной формы @code{function} или с помощью синтаксиса @code{#'}
(@pxref{Anonymous Function}), автоматически преобразуется в @dfn{замыкание} (@dfn{closure}).

@c   As explained in @ref{Variable Scoping}, Emacs can optionally enable
@c lexical binding of variables.  When lexical binding is enabled, any
@c named function that you create (e.g., with @code{defun}), as well as
@c any anonymous function that you create using the @code{lambda} macro
@c or the @code{function} special form or the @code{#'} syntax
@c (@pxref{Anonymous Functions}), is automatically converted into a
@c @dfn{closure}.

@cindex closure
  Замыканием является функция которая хранит состояние лексического окружения
в момент определения функции. При вызове замыкания ссылки на лексические
переменные указывают на сохраненные значения лексического окружения. В остальном
замыкание работает, как обычная функция, в частности, они могут быть вызваны
тем же способом как и обычная функция.

@c   A closure is a function that also carries a record of the lexical
@c environment that existed when the function was defined.  When it is
@c invoked, any lexical variable references within its definition use the
@c retained lexical environment.  In all other respects, closures behave
@c much like ordinary functions; in particular, they can be called in the
@c same way as ordinary functions.

  Примеры использования замыканий, @xref{Lexical Binding}.
  @c @xref{Lexical Binding}, for an example of using a closure.

  В текущей реализации Emacs Lisp, объект замыкания представляется
в виде списка с символом @code{closure} в качестве первого элемента,
и списком представляющем лексическое окружение в качестве второго,
списка аргументов и тела в качестве третьего и последующих:

@c   Currently, an Emacs Lisp closure object is represented by a list
@c with the symbol @code{closure} as the first element, a list
@c representing the lexical environment as the second element, and the
@c argument list and body forms as the remaining elements:

@example
;; @r{lexical binding is enabled.}
(lambda (x) (* x x))
     @result{} (closure (t) (x) (* x x))
@end example

@noindent
Внутреннюю структуру замыкания стоит рассматривать как детали реализации,
и не стоит напрямую проверять или изменять объекты замыканий.
(Так как они например могут измениться).

@c However, the fact that the internal structure of a closure is
@c exposed to the rest of the Lisp world is considered an internal
@c implementation detail.  For this reason, we recommend against directly
@c examining or altering the structure of closure objects.

@node Advising Functions
@section Дополнения Функций Emacs Lisp
@c @section Advising Emacs Lisp Functions
@cindex advising functions
@cindex piece of advice

Когда нужно изменить функцию определенную в другой библиотеке, или изменить
перехватчик наподобие @@code{@var{foo}-function}, фильтр процесса или любую
переменную или объект хранящие функцию, можно использовать
соответствующий установщик для функции, @code{fset} или @code{defun} для
именованной функции, @code{setq} для переменной перехватчика, или @code{set-process-filter}
для фильма процесса, но данный подход является довольно грубым потому, что полностью
выкидывает исходное значение.

@c When you need to modify a function defined in another library, or when you need
@c to modify a hook like @code{@var{foo}-function}, a process filter, or basically
@c any variable or object field which holds a function value, you can use the
@c appropriate setter function, such as @code{fset} or @code{defun} for named
@c functions, @code{setq} for hook variables, or @code{set-process-filter} for
@c process filters, but those are often too blunt, completely throwing away the
@c previous value.

  Возможность @dfn{дополнений} (@dfn{advice} feature) позволяет расширять существующие
определения функции, путем @dfn{расширения функции} (@dfn{advising the function}).
Такой способ является более подходящим, чем переопределение всей функции.

@c   The @dfn{advice} feature lets you add to the existing definition of
@c a function, by @dfn{advising the function}.  This is a cleaner method
@c than redefining the whole function.

Система создания дополнений Emacs предоставляет два множества примитивов:
базовое множество для значений функций хранящихся в полях переменных и объектов
(примитивы @code{add-function} и @code{remove-function}) и другим множеством,
строящемся поверх первого в которое входят @code{advice-add} и @code{advice-remove}.

@c Emacs's advice system provides two sets of primitives for that: the core set,
@c for function values held in variables and object fields (with the corresponding
@c primitives being @code{add-function} and @code{remove-function}) and another
@c set layered on top of it for named functions (with the main primitives being
@c @code{advice-add} and @code{advice-remove}).

Например, чтобы получить информацию о вызовах фильтра процессов для процесса
@var{proc}, можно сделать так:

@c For example, in order to trace the calls to the process filter of a process
@c @var{proc}, you could use:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

Данный код, приведет к тому что, вывод процесса будет передаваться
в @code{my-tracing-function} до передачи оригинальному фильтру.
@code{my-tracing-function} будет вызвана с теми же аргументами, что и оригинальная
функция. Вернуть исходное поведение можно так:

@c This will cause the process's output to be passed to @code{my-tracing-function}
@c before being passed to the original process filter.  @code{my-tracing-function}
@c receives the same arguments as the original function.  When you're done with
@c it, you can revert to the untraced behavior with:

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

Аналогично, если нужно отследить вызовы функции с именем @code{display-buffer},
можно использовать следующий код:

@c Similarly, if you want to trace the execution of the function named
@c @code{display-buffer}, you could use:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

В данном примере, @code{his-tracing-function} вызывается вместо исходной
функции и получает исходную функцию в параметрах (в дополнение к аргументам
исходной функции), и вызывает оригинальную функцию тогда, когда нужно.
Вернуть исходное поведение можно следующим образом:

@c Here, @code{his-tracing-function} is called instead of the original function
@c and receives the original function (additionally to that function's arguments)
@c as argument, so it can call it if and when it needs to.
@c When you're tired of seeing this output, you can revert to the untraced
@c behavior with:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

Аргументы @code{:before} и @code{:around} используются для задания способа
композиции функций, так как есть несколько способов сделать это. Добавленные
функции называются частью @emph{дополнения} (@emph{advice}).

@c The arguments @code{:before} and @code{:around} used in the above examples
@c specify how the two functions are composed, since there are many different
@c ways to do it.  The added function is also called a piece of @emph{advice}.

@menu
* Core Advising Primitives::    Примитивы для работы с дополнениями (advice).
* Advising Named Functions::    Дополнение именованных функций.
* Advice combinators::          Способы составления дополнений.
* Porting old advice::          Портирование кода использующего устаревший вызов defadvice.
@end menu

@c @menu
@c * Core Advising Primitives::    Primitives to manipulate advice.
@c * Advising Named Functions::    Advising named functions.
@c * Advice combinators::          Ways to compose advice.
@c * Porting old advice::          Adapting code using the old defadvice.
@c @end menu

@node Core Advising Primitives
@subsection Примитивы для работы с дополнениями
@c @subsection Primitives to manipulate advices
@cindex advice, add and remove

@defmac add-function where place function &optional props
Макрос предоставляет удобный способ добавить дополнение @var{function} к
функции хранящейся в @var{place} (@pxref{Generalized Variables}).

@c This macro is the handy way to add the advice @var{function} to the function
@c stored in @var{place} (@pxref{Generalized Variables}).

@var{where} определяет как @var{function} комбинируется с
существующей функцией, например, будет ли @var{function} вызвана до или
после исходной функции. Для получения всех способов
комбинирования дополнений @xref{Advice combinators}.

@c @var{where} determines how @var{function} is composed with the
@c existing function, e.g., whether @var{function} should be called before, or
@c after the original function.  @xref{Advice combinators}, for the list of
@c available ways to compose the two functions.

При изменении переменной (имя которой как правило оканчивается на @code{-function}),
можно определить будет ли @var{function} использоваться глобально
или только в текущем буфере. Если @var{place} символ, @var{function} будет добавлена
к глобальному значению @var{place}. Но если @var{place} имеет вид
@code{(local @var{symbol})}, где @var{symbol} выражение возвращающее
имя переменной, тогда @var{function} будет добавлена только для текущего
буфера. Если же нужно изменить лексическую переменную, нужно использовать
@code{(var @var{variable})}.

@c When modifying a variable (whose name will usually end with @code{-function}),
@c you can choose whether @var{function} is used globally or only in the current
@c buffer: if @var{place} is just a symbol, then @var{function} is added to the
@c global value of @var{place}.  Whereas if @var{place} is of the form
@c @code{(local @var{symbol})}, where @var{symbol} is an expression which returns
@c the variable name, then @var{function} will only be added in the
@c current buffer.  Finally, if you want to modify a lexical variable, you will
@c have to use @code{(var @var{variable})}.

Каждая функция добавленная с использованием @code{add-function} может
иметь заданным список свойств @var{props}. В текущей реализации, обрабатываются
только два свойства:

@c Every function added with @code{add-function} can be accompanied by an
@c association list of properties @var{props}.  Currently only two of those
@c properties have a special meaning:

@table @code
@item name
Данное свойство задает имя дополнению, которое может быть
использовано в @code{remove-function}. Как правило данное
свойство используется если @var{function} является
анонимной функцией.

@c This gives a name to the advice, which @code{remove-function} can use to
@c identify which function to remove.  Typically used when @var{function} is an
@c anonymous function.

@item depth
Данное свойство определяет, как порядок выполнения дополнения, если
их несколько. По умолчанию depth 0. depth 100 означает, что
дополнение должно быть поглубже (видимо выполняться попозже, но зависит от типа), в то время
как -100 означает что дополнение должно быть с краю (в начале). В случае
если два дополнения имеют одну depth более крайним будет идти то, что
было добавлено позднее (более новое).

@c This specifies how to order the advice, should several pieces of
@c advice be present.  By default, the depth is 0.  A depth of 100
@c indicates that this piece of advice should be kept as deep as
@c possible, whereas a depth of -100 indicates that it should stay as the
@c outermost piece.  When two pieces of advice specify the same depth,
@c the most recently added one will be outermost.

Для @code{:before} дополнения, быть с краю, означает, что дополнение
будет выполняться первым, в то время как быть в глубине, означает, что
после менее глубоких дополнений. Наоборот, для @code{:after} дополнения
быть в глубине означает, что оно будет выполняться раньше
менее глубоких дополнений (почти сразу за основной функцией). Для
@code{:overrides} быть с краю означает, что будет заменена только
основная функция, в то время как быть глубже означает, что будет
заменена основная функция и @code{:override} дополнения, которые
имеют меньшую глубину. (Прим. видимо выполняется только один override).

@c For @code{:before} advice, being outermost means that this advice will
@c be run first, before any other advice, whereas being innermost means
@c that it will run right before the original function, with no other
@c advice run between itself and the original function.  Similarly, for
@c @code{:after} advice innermost means that it will run right after the
@c original function, with no other advice run in between, whereas
@c outermost means that it will be run right at the end after all other
@c advice.  An innermost @code{:override} piece of advice will only
@c override the original function and other pieces of advice will apply
@c to it, whereas an outermost @code{:override} piece of advice will
@c override not only the original function but all other advice applied
@c to it as well.
@end table

Если @var{function} не интерактивна, тогда комбинация будет наследовать
спецификацию интерактивности, от основной функции. Иначе, комбинированная
функция будет интерактивна и будет использовать спецификацию из @var{function}.
Однако есть исключение, если спецификация интерактивности @var{function}
является функцией (а не выражением или строкой), тогда спецификация интерактивности
комбинированной функцией будет вызвана с параметром спецификации оригинальной
функции в качестве единственного аргумента. Чтобы выполнить интерпретацию
спецификации полученного аргумента нужно использовать @code{advice-eval-interactive-spec}.

@c If @var{function} is not interactive, then the combined function will inherit
@c the interactive spec, if any, of the original function.  Else, the combined
@c function will be interactive and will use the interactive spec of
@c @var{function}.  One exception: if the interactive spec of @var{function}
@c is a function (rather than an expression or a string), then the interactive
@c spec of the combined function will be a call to that function with as sole
@c argument the interactive spec of the original function.  To interpret the spec
@c received as argument, use @code{advice-eval-interactive-spec}.

Стоит отметить: Спецификация интерактивности @var{function} будет вызвана
для комбинированной функции и должна удовлетворять сигнатуре комбинированной
функции, а не @var{function}. В большинстве случаев, это не важно, так как
сигнатуры совпадают, но для @code{:around} и @code{:filter-args}, @code{filter-return}.

@c Note: The interactive spec of @var{function} will apply to the combined
@c function and should hence obey the calling convention of the combined function
@c rather than that of @var{function}.  In many cases, it makes no difference
@c since they are identical, but it does matter for @code{:around},
@c @code{:filter-args}, and @code{filter-return}, where @var{function}.
@end defmac

@defmac remove-function place function
Макрос удаляет @var{function} из функции сохраненной в @var{place}.
Макрос работает, только если @var{function} была добавлена
в @var{place} с использованием @code{add-function}.

@c This macro removes @var{function} from the function stored in
@c @var{place}.  This only works if @var{function} was added to @var{place}
@c using @code{add-function}.

@var{function} сравнивается с функциями добавленными в @var{place}
с помощью @code{equal}, чтобы макрос работал с lambda выражениями.
Дополнительно выполняется сравнение свойства @code{name} функции
в @var{place}, что может быть более надежно чем сравнивать lambda
выражения используя @code{equal}.

@c @var{function} is compared with functions added to @var{place} using
@c @code{equal}, to try and make it work also with lambda expressions.  It is
@c additionally compared also with the @code{name} property of the functions added
@c to @var{place}, which can be more reliable than comparing lambda expressions
@c using @code{equal}.
@end defmac

@defun advice-function-member-p advice function-def
Возвращает не-@code{nil} если @var{advice} уже в @var{function-def}.
Как и в @code{remove-function}, @var{advice} может быть @code{name}
части дополнения.

@c Return non-@code{nil} if @var{advice} is already in @var{function-def}.
@c Like for @code{remove-function} above, instead of @var{advice} being the actual
@c function, it can also be the @code{name} of the piece of advice. 
@end defun

@defun advice-function-mapc f function-def
Вызывает функцию @var{f} с каждой частью дополнения @var{function-def}.
@var{f} вызывается с двумя аргументами функцией дополнения и ее свойствами.

@c Call the function @var{f} for every piece of advice that was added to
@c @var{function-def}.  @var{f} is called with two arguments: the advice function
@c and its properties.
@end defun

@defun advice-eval-interactive-spec spec
Вычисляет спецификацию интерактивности @var{spec}, как если бы это был вызов
функции с такой спецификацией интерактивности, и возвращает полученный список аргументов.
Например @code{(advice-eval-interactive-spec "r\nP")} вернет список из трех элементов, содержащий
границы региона и значение аргумента префикса.

@c Evaluate the interactive @var{spec} just like an interactive call to a function
@c with such a spec would, and then return the corresponding list of arguments
@c that was built.  E.g., @code{(advice-eval-interactive-spec "r\nP")} will
@c return a list of three elements, containing the boundaries of the region and
@c the current prefix argument.
@end defun

@node Advising Named Functions
@subsection Дополнения для Именованных Функций
@c @subsection Advising Named Functions
@cindex advising named functions

Обычно дополнения используются с именованными функциями и макросами.
Можно просто использовать @code{add-function}, например:

@c A common use of advice is for named functions and macros.
@c You could just use @code{add-function} as in:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  Но стоит использовать @code{advice-add} и @code{advice-remove} вместо них.
Это другое множество функций для работы с частями дополнения именованных функций,
и эти функции предлагают дополнительные возможности по сравнению с @code{add-function}:
они умеют работать с макросами и автоматически загружаемыми (autoloaded) функциями,
позволяют @code{describe-function} сохранить оригинальную строку документации и
добавить документацию для дополнения, а так же позволяют создавать и удалять дополнения
до того как функция будет определена.

@c   But you should use @code{advice-add} and @code{advice-remove} for that
@c instead.  This separate set of functions to manipulate pieces of advice applied
@c to named functions, offers the following extra features compared to
@c @code{add-function}: they know how to deal with macros and autoloaded
@c functions, they let @code{describe-function} preserve the original docstring as
@c well as document the added advice, and they let you add and remove advice
@c before a function is even defined.

  @code{advice-add} может быть полезна для изменения поведения вызовов существующих
функций без переопределения всей функции. Но, так же может быть источником ошибок,
так как существующие вызовы для функции могут ожидать изначального поведения функции, и
работать не правильно в случае изменения поведения с помощью дополнения.
Дополнения так же могут приводить к трудностям при отладки, если выполняющий
отладку не в курсе, что функция была изменена с помощью дополнения.

@c   @code{advice-add} can be useful for altering the behavior of existing calls
@c to an existing function without having to redefine the whole function.
@c However, it can be a source of bugs, since existing callers to the function may
@c assume the old behavior, and work incorrectly when the behavior is changed by
@c advice.  Advice can also cause confusion in debugging, if the person doing the
@c debugging does not notice or remember that the function has been modified
@c by advice.

  По этой причине, дополнения должны использоваться в тех случаях
когда поведение функции не может быть изменено другим способом. Если
возможно лучше воспользоваться перехватчиками (hook) (@pxref{Hooks}).
Если нужно изменить поведение какого-то ключа, то возможно более
правильно будет написать новую команду и в ней сделать переопределение (remap)
ключей (@pxref{Remapping Commands}). В частности, исходные файлы Emacs
не должны делать дополнения для функций Emacs. (Есть несколько исключению,
но делаются попытки к их исправлению.)

@c   For these reasons, advice should be reserved for the cases where you
@c cannot modify a function's behavior in any other way.  If it is
@c possible to do the same thing via a hook, that is preferable
@c (@pxref{Hooks}).  If you simply want to change what a particular key
@c does, it may be better to write a new command, and remap the old
@c command's key bindings to the new one (@pxref{Remapping Commands}).
@c In particular, Emacs's own source files should not put advice on
@c functions in Emacs.  (There are currently a few exceptions to this
@c convention, but we aim to correct them.)

  Дополнения не могут быть добавлены к специальным формам (@pxref{Special Forms}), но
дополнения для макросов возможны. Конечно такие дополнения не подействуют
на макросы расширения для которых уже были выполнены, поэтому дополнения
для макросов должны быть установлены до того, как будут построены расширения.

@c   Special forms (@pxref{Special Forms}) cannot be advised, however macros can
@c be advised, in much the same way as functions.  Of course, this will not affect
@c code that has already been macro-expanded, so you need to make sure the advice
@c is installed before the macro is expanded.

  Возможно построение дополнения для встроенных (primitive) (@pxref{What Is a Function}),
но как правило так @emph{не} делают. Во первых некоторые встроенные
функции используются механизмом дополнений, и построение для них
дополнений может привести к бесконечной рекурсии. Во вторых, встроенные
функции могут быть вызваны напрямую из C, и такие вызовы будут игнорировать
дополнения; поэтому, возможно возникновение путаницы, что одни
вызовы (из Lisp кода) будут вызываться с дополнением, а другие (из C)
без.

@c   It is possible to advise a primitive (@pxref{What Is a Function}),
@c but one should typically @emph{not} do so, for two reasons.  Firstly,
@c some primitives are used by the advice mechanism, and advising them
@c could cause an infinite recursion.  Secondly, many primitives are
@c called directly from C, and such calls ignore advice; hence, one ends
@c up in a confusing situation where some calls (occurring from Lisp
@c code) obey the advice and other calls (from C code) do not.

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
Макрос определяет часть дополнения и добавляет его к функции с именем
@var{symbol}. Дополнение является анонимной функцией если @var{name}
nil или функцией с именем @code{symbol@@name}. Другие аргументы
соответствуют аргументам описанным в @code{advice-add}.

@c This macro defines a piece of advice and adds it to the function named
@c @var{symbol}.  The advice is an anonymous function if @var{name} is
@c nil or a function named @code{symbol@@name}.  See @code{advice-add}
@c for explanation of other arguments.
@end defmac

@defun advice-add symbol where function &optional props
Добавить дополнение @var{function} к именованной функции @var{symbol}.
@var{where} и @var{props} имеют тоже значение, что и для @code{add-function}
(@pxref{Core Advising Primitives}).

@c Add the advice @var{function} to the named function @var{symbol}.
@c @var{where} and @var{props} have the same meaning as for @code{add-function}
@c (@pxref{Core Advising Primitives}).
@end defun

@defun advice-remove symbol function
Удалить дополнение @var{function} для именованной функции @var{symbol}.
@var{function} может быть @code{name} части дополнения.

@c Remove the advice @var{function} from the named function @var{symbol}.
@c @var{function} can also be the @code{name} of a piece of advice.
@end defun

@defun advice-member-p function symbol
Возвращает не-@code{nil} если функция @var{function} уже является частью
дополнения именованной функции @var{symbol}. @var{function} может быть
@code{name} части дополнения.

@c Return non-@code{nil} if the advice @var{function} is already in the named
@c function @var{symbol}.  @var{function} can also be the @code{name} of
@c a piece of advice.
@end defun

@defun advice-mapc function symbol
Вызывает @var{function} для каждой части дополнения именованной функции
@var{symbol}. @var{function} вызывается с двумя аргументами: функцией
дополнения и ее свойствами.

@c Call @var{function} for every piece of advice that was added to the
@c named function @var{symbol}.  @var{function} is called with two
@c arguments: the advice function and its properties.
@end defun

@node Advice combinators
@subsection Способы составления дополнения
@c @subsection Ways to compose advice

Есть несколько разных значений @var{where} аргумента для функций
@code{add-function} и @code{advice-add}, определяющих как дополнение
@var{function} и исходная функция должны сочетаться.

@c Here are the different possible values for the @var{where} argument of
@c @code{add-function} and @code{advice-add}, specifying how the advice
@c @var{function} and the original function should be composed.

@table @code
@item :before
Вызов @var{function} выполняется до основной функции. Обе функции получают
одинаковые параметры, и возвращаемое значение композиции является определяется
возвращаемым значением основной функции. Более точно композиция двух
функций выполняется следующим образом:

@c Call @var{function} before the old function.  Both functions receive the
@c same arguments, and the return value of the composition is the return value of
@c the old function.  More specifically, the composition of the two functions
@c behaves like:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar} @var{function})} сравнима с перехватчиком
для отдельной функции @code{(add-hook '@var{hookvar} @var{function})}.

@c @code{(add-function :before @var{funvar} @var{function})} is comparable for
@c single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} for
@c normal hooks.

@item :after
@var{functin} вызывается после основной функции. Обе функции получают одинаковые
аргументы, композиция возвращает значение основной функции. Более точно
композиция двух функций работает как:

@c Call @var{function} after the old function.  Both functions receive the
@c same arguments, and the return value of the composition is the return value of
@c the old function.  More specifically, the composition of the two functions
@c behaves like:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar} @var{function})} сравнима с перехватчиком
для одной функции @code{(add-hook '@var{hookkvar} @var{function 'append})}.

@c @code{(add-function :after @var{funvar} @var{function})} is comparable for
@c single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
@c 'append)} for normal hooks.

@item :override
Данный способ полностью заменяет основную функцию на новую. Основная функция
может быть восстановлена если позднее будет сделан вызов @code{remove-function}.

@c This completely replaces the old function with the new one.  The old function
@c can of course be recovered if you later call @code{remove-function}.

@item :around
Выполняется вызов @var{function} вместо основной функции, но основная функция передается
как дополнительный аргумент в @var{function}. Данная композиция является наиболее
гибкой. Например, она позволяет вызвать основную функцию с другими аргументами, или
несколько раз, или внутри let связывания, или можно в некоторых случаях вызывать
основную функцию, а в некоторых нет. Более точно, композиция
двух функций будет работать так:

@c Call @var{function} instead of the old function, but provide the old function
@c as an extra argument to @var{function}.  This is the most flexible composition.
@c For example, it lets you call the old function with different arguments, or
@c many times, or within a let-binding, or you can sometimes delegate the work to
@c the old function and sometimes override it completely.  More specifically, the
@c composition of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
В этом случае @var{function} вызывается до основной функции, при этом вызов
основной функции не выполняется если @var{function} возвращает @code{nil}.
Обе функции получают одинаковые аргументы, возвращаемым значением
композиции является результат выполнения основной функции либо дополнительной,
если основная не вызывается. Более точно композиция двух функций представляется так:

@c Call @var{function} before the old function and don't call the old
@c function if @var{function} returns @code{nil}.  Both functions receive the
@c same arguments, and the return value of the composition is the return value of
@c the old function.  More specifically, the composition of the two functions
@c behaves like:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar} @var{function})} сравнима с
использованием перехватчика @code{(add-hook '@var{hookvar} @var{function})}
когда @var{hookvar} вызывается через @code{run-hook-with-args-until-failure}.

@c @code{(add-function :before-while @var{funvar} @var{function})} is comparable
@c for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
@c when @var{hookvar} is run via @code{run-hook-with-args-until-failure}.

@item :before-until
В этом случае @var{function} вызывается до основной функции и основная функция
вызывается только, если @var{function} возвращает @code{nil}. Более точно,
композиция представляется так:
@c Call @var{function} before the old function and only call the old function if
@c @var{function} returns @code{nil}.  More specifically, the composition of the
@c two functions behaves like:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-util @var{funvar} @var{function})} сравнимо с использованием
перехватчика @code{(add-hook '@var{hookvar @var{function}})} когда
@var{hookvar} вызывается через @code{run-hook-with-args-until-failure}.

@c @code{(add-function :before-until @var{funvar} @var{function})} is comparable
@c for single-function hooks to @code{(add-hook '@var{hookvar} @var{function})}
@c when @var{hookvar} is run via @code{run-hook-with-args-until-success}.

@item :after-while
В этом случае @var{function} вызывается после основной функции, и только если
основная функция возвращает не-@code{nil}. Обе функции получают одни и те
же аргументы. Значением композиции является значение @var{function}, если она
вызывается и основной если нет.
Более точно, композиция представляется так:

@c Call @var{function} after the old function and only if the old function
@c returned non-@code{nil}.  Both functions receive the same arguments, and the
@c return value of the composition is the return value of @var{function}.
@c More specifically, the composition of the two functions behaves like:

@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar} @var{function})} сравнимо
с использованием перехватчика @code{(add-hook '@var{hookvar} @var{function} 'append)}
если @var{hookvar} вызывается через @code{run-hook-with-args-until-failure}.

@c @code{(add-function :after-while @var{funvar} @var{function})} is comparable
@c for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
@c 'append)} when @var{hookvar} is run via
@c @code{run-hook-with-args-until-failure}.

@item :after-until
В этом случает @var{function} вызывается после основной функции и только если
основная функция возвращает @code{nil}. Более точно, композиция представляется так:

@c Call @var{function} after the old function and only if the old function
@c returned @code{nil}.  More specifically, the composition of the two functions
@c behaves like:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar} @var{function})} аналогична
использованию перехватчика @code{(add-hook '@var{hookvar} @var{function} 'append)}
если @var{hookvar} вызывается через @code{run-hook-with-args-util-success}.

@c @code{(add-function :after-until @var{funvar} @var{function})} is comparable
@c for single-function hooks to @code{(add-hook '@var{hookvar} @var{function}
@c 'append)} when @var{hookvar} is run via
@c @code{run-hook-with-args-until-success}.

@item :filter-args
В этом случае @var{function} вызывается первой и результат вызова (который должен быть
списком) используется как аргументы передающиеся основной функции. Более
точно, композиция выглядит так:

@c Call @var{function} first and use the result (which should be a list) as the
@c new arguments to pass to the old function.  More specifically, the composition
@c of the two functions behaves like:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
В этом случае сначала вызывается основная функция и ее результат
передается в @var{function}. Более точно, композиция выглядит так:

@c Call the old function first and pass the result to @var{function}.
@c More specifically, the composition of the two functions behaves like:

@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting old advice
@subsection Миграция кода, использующего устаревший вызов defadvice
@c @subsection Adapting code using the old defadvice
@cindex old advices, porting

Написано много кода, который использует @code{defadvice} механизм, который
устарел при появлении нового @code{advice-add}, реализация и семантика которого
значительно проще.
@c A lot of code uses the old @code{defadvice} mechanism, which is largely made
@c obsolete by the new @code{advice-add}, whose implementation and semantics is
@c significantly simpler.

Устаревшие части дополнений такие как:
@c An old piece of advice such as:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

могут быть преобразованы с использованием нового механизма просто во функцию:
@c could be translated in the new advice mechanism into a plain function:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

Очевидно, что такая функция не изменяет @code{previous-line}, поэтому чтобы
сделать дополнение нужно:
@c Obviously, this does not actually modify @code{previous-line}.  For that the
@c old advice needed:
@example
(ad-activate 'previous-line)
@end example
в то время как в новом механизме дополнений нужно:
@c whereas the new advice mechanism needs:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

Стоит отметить, что @code{ad-activate} имеет глобальный эффект: вызов активирует
все части дополнения включенных для заданной функции. Если нужно выполнить активацию
или деактивацию определенной части дополнения, нужно выполнить @emph{включение} или
@emph{disable} выключение с использованием @code{ad-enable-advice} и @code{ad-disable-advice}.
Новый механизм этого не требует.

@c Note that @code{ad-activate} had a global effect: it activated all pieces of
@c advice enabled for that specified function.  If you wanted to only activate or
@c deactivate a particular piece, you needed to @emph{enable} or @emph{disable}
@c it with @code{ad-enable-advice} and @code{ad-disable-advice}.
@c The new mechanism does away with this distinction.

Дополнение around такое как:
@c Around advice such as:

@example
(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

может быть переведено в:
@c could translate into:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

Стоит заметить, что новый @code{:before} не полностью соответствует старому @code{before},
потому что в старом дополнении можно было изменить аргумент функции
(например с помощью @code{ad-set-args}), и это влияло на аргументы получаемые основной функцией,
в новом @code{:before}, изменение аргументов через @code{setq} не повлияет на аргументы
которые получит основная функция. При портировании кода использующего
такое поведение, нужно использовать @code{:around} или @code{:filter-args} дополнения,
вместо @code{:before}.

@c Regarding the advice's @emph{class}, note that the new @code{:before} is not
@c quite equivalent to the old @code{before}, because in the old advice you could
@c modify the function's arguments (e.g., with @code{ad-set-arg}), and that would
@c affect the argument values seen by the original function, whereas in the new
@c @code{:before}, modifying an argument via @code{setq} in the advice has no
@c effect on the arguments seen by the original function.
@c When porting @code{before} advice which relied on this behavior, you'll need
@c to turn it into new @code{:around} or @code{:filter-args} advice instead.


Аналогично старое @code{after} дополнение могло изменять возвращаемое значение
с помощью @code{ad-return-value}, в то время как @code{:after}  не может, поэтому
в случае портирования кода использующего данную возможность, нужно использовать
@code{:around} или @code{:filter-return} дополнения.

@c Similarly old @code{after} advice could modify the returned value by
@c changing @code{ad-return-value}, whereas new @code{:after} advice cannot, so
@c when porting such old @code{after} advice, you'll need to turn it into new
@c @code{:around} or @code{:filter-return} advice instead.

@node Obsolete Functions
@section Объявление Функций Устаревшими
@c @section Declaring Functions Obsolete
@cindex obsolete functions

  именованную функцию можно пометить как @dfn{устаревшую} (@dfn{obsolete}),
подразумевая, то, что в будущем она может быть удалена. В этом случае Emacs
будет давать предупреждение об устаревшей функции при байт-компиляции кода
содержащего такую функцию, и при показе документации для такой функции. В остальных
случаях, устаревшая функция будет работать так же как обычная функция.

@c   You can mark a named function as @dfn{obsolete}, meaning that it may
@c be removed at some point in the future.  This causes Emacs to warn
@c that the function is obsolete whenever it byte-compiles code
@c containing that function, and whenever it displays the documentation
@c for that function.  In all other respects, an obsolete function
@c behaves like any other function.

  Простейший способ пометить функцию как устаревшую поместить
форму @code{(declare (obsolete @dots))} в @code{defun} определение
функции. @xref{Declare Form}. Либо можно использовать
функцию @code{make-obsolete}, описанную ниже.

@c   The easiest way to mark a function as obsolete is to put a
@c @code{(declare (obsolete @dots{}))} form in the function's
@c @code{defun} definition.  @xref{Declare Form}.  Alternatively, you can
@c use the @code{make-obsolete} function, described below.

  Макрос (@pxref{Macros}) так же может быть помечен устаревшим с
помощью функции @code{make-obsolete}, эффект будет такой же как для функции.
Псевдоним (alias) для функции или макроса тоже может быть помечен
устаревшим, что пометит псевдоним (но не оригинальную функцию или макрос)
устаревшим.

@c   A macro (@pxref{Macros}) can also be marked obsolete with
@c @code{make-obsolete}; this has the same effects as for a function.  An
@c alias for a function or macro can also be marked as obsolete; this
@c makes the alias itself obsolete, not the function or macro which it
@c resolves to.

@defun make-obsolete obsolete-name current-name &optional when
Функция помечает @var{obsolete-name} как устаревшую.
@var{obsolete-name} должно быть именем функции или макроса, или
псевдонима для функции или макроса.

@c This function marks @var{obsolete-name} as obsolete.
@c @var{obsolete-name} should be a symbol naming a function or macro, or
@c an alias for a function or macro.

Если @var{current-name} символ, предупреждение будет указывать, что
стоит использовать @var{current-name} вместо @var{obsolete-name}.
@var{current-name} не обязано быть псевдонимом для @var{obsolete-name},
оно может быть другой функцией с похожей функциональностью. @var{current-name}
может быть строкой, которая будет служить сообщением предупреждением. Сообщение
должно начинаться с маленькой буквы, и заканчиваться периодом (with a period).
@var{current-name} может быть @code{nil}, в этом случае предупреждение
не показывает дополнительной информации.

@c If @var{current-name} is a symbol, the warning message says to use
@c @var{current-name} instead of @var{obsolete-name}.  @var{current-name}
@c does not need to be an alias for @var{obsolete-name}; it can be a
@c different function with similar functionality.  @var{current-name} can
@c also be a string, which serves as the warning message.  The message
@c should begin in lower case, and end with a period.  It can also be
@c @code{nil}, in which case the warning message provides no additional
@c details.

Если задано, @var{when}, то оно должно быть строкой, указывающей когда
функция стала устаревшей---например датой или номером релиза.

@c If provided, @var{when} should be a string indicating when the function
@c was first made obsolete---for example, a date or a release number.
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name &optional when doc
Данный макрос предоставляет удобный способ пометить @var{obsolete-name} устаревшей
и определить ее как псевдоним для @var{current-name}.
Данный макрос является эквивалентом:

@c This convenience macro marks the function @var{obsolete-name} obsolete
@c and also defines it as an alias for the function @var{current-name}.
@c It is equivalent to the following:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

Кроме того, можно пометить соглашение вызова для функции как устаревшее:

@c In addition, you can mark a certain a particular calling convention
@c for a function as obsolete:

@defun set-advertised-calling-convention function signature when
Функция определяет список аргументов с сигнатурой @var{signature}
как правильный способ вызова @var{function}. При этом байт компилятор Emacs
будет давать предупреждение когда @var{function} вызывается другим образом
(но, компиляция все равно будет проходить). @var{when} должно быть строкой
указывающей на то, когда переменная стала устаревшей, как правило
строка с номером версии.

@c This function specifies the argument list @var{signature} as the
@c correct way to call @var{function}.  This causes the Emacs byte
@c compiler to issue a warning whenever it comes across an Emacs Lisp
@c program that calls @var{function} any other way (however, it will
@c still allow the code to be byte compiled).  @var{when} should be a
@c string indicating when the variable was first made obsolete (usually a
@c version number string).

Например, старая версия функции @code{sit-for}  принимала три аргумента

@c For instance, in old versions of Emacs the @code{sit-for} function
@c accepted three arguments, like this

@example
  (sit-for seconds milliseconds nodisp)
@end example

Но, вызов @code{sit-for} считается устаревшим (@pxref{Waiting}).
Старое соглашение о вызове устарело, и было помечено таким образом:

@c However, calling @code{sit-for} this way is considered obsolete
@c (@pxref{Waiting}).  The old calling convention is deprecated like
@c this:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example
@end defun

@node Inline Functions
@section Встраиваемые Функции
@c @section Inline Functions
@cindex inline functions

  @dfn{Встраиваемая функция} (@dfn{inline function}) функция, которая
работает как обычная функция, за исключением одного момента: когда выполняется
байт компиляция вызова функции (@pxref{Byte Compilation}), определение функции
встраивается в вызываемый код. Чтобы определить встраиваемую функцию,
используйте @code{defsubst} вместо @code{defun}.

@c   An @dfn{inline function} is a function that works just like an
@c ordinary function, except for one thing: when you byte-compile a call
@c to the function (@pxref{Byte Compilation}), the function's definition
@c is expanded into the caller.  To define an inline function, use
@c @code{defsubst} instead of @code{defun}.

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
Макрос определяет встраиваемую функцию. Синтаксис точно такой же, как
@code{defun} (@pxref{Defining Functions}).

@c This macro defines an inline function.  Its syntax is exactly the same
@c as @code{defun} (@pxref{Defining Functions}).
@end defmac

  Объявляя функцию как встраиваемую, часто приводит к тому, что ее вызовы
выполняются быстрее. Но есть и минус, так как снижается гибкость; при
изменении функции, встроенные вызовы останутся неизменными до того
как код их содержащий будет перекомпилирован.

@c   Making a function inline often makes its function calls run faster.
@c But it also has disadvantages.  For one thing, it reduces flexibility;
@c if you change the definition of the function, calls already inlined
@c still use the old definition until you recompile them.

  Другим минусом является, то что если встраиваемая функция большая, то
ее вызовы будут увеличивать размер скомпилированного кода в файлах и памяти.
Поэтому смысл в увеличении скорости для встраиваемых функций больше для
маленьких функций, а большие функции лучше не делать встраиваемыми.

@c   Another disadvantage is that making a large function inline can
@c increase the size of compiled code both in files and in memory.  Since
@c the speed advantage of inline functions is greatest for small
@c functions, you generally should not make large functions inline.

  Так же, встраиваемые функции не особо удобны при отладки, трасировке
и механизма дополнений (@pxref{Advising Functions}). Так как простая отладка
и гибкость в переопределении важные возможности Emacs, не стоит делать функцию
встраиваемой, даже если она маленькая, если только ее скорость действительно
не является критичной, и была проведена профилировка, которая показала, что
использование @code{defun} не достаточно быстра в сравнении со встраиваемым
вариантом.

@c   Also, inline functions do not behave well with respect to debugging,
@c tracing, and advising (@pxref{Advising Functions}).  Since ease of
@c debugging and the flexibility of redefining functions are important
@c features of Emacs, you should not make a function inline, even if it's
@c small, unless its speed is really crucial, and you've timed the code
@c to verify that using @code{defun} actually has performance problems.

  После того как встраиваемая функция была определена, встраиваемое расширение
может быть создано позднее в том же файле, как для макроса.

@c   After an inline function is defined, its inline expansion can be
@c performed later on in the same file, just like macros.

  Возможно использовать @code{defsubst} для определения макроса,
расширяющегося в тот же код, который будет выполнять встраиваемая
функция (@pxref{Macros}). Но макрос будет ограничен при использовании в
выражениях---так как он не может быть вызван с использованием
@code{apply}, @code{mapcar} и т.д. Кроме того, потребуется работа по
конвертации функции в макрос. Конвертирование функции во встраиваемую
просто, нужно заменить @code{defun} на @code{defsubst}. Так как каждый аргумент
встраиваемой функции вычисляется только один раз, не нужно беспокоится о том, как
много раз в теле используется аргумент, как при использовании макроса.

@c   It's possible to use @code{defsubst} to define a macro to expand
@c into the same code that an inline function would execute
@c (@pxref{Macros}).  But the macro would be limited to direct use in
@c expressions---a macro cannot be called with @code{apply},
@c @code{mapcar} and so on.  Also, it takes some work to convert an
@c ordinary function into a macro.  To convert it into an inline function
@c is easy; just replace @code{defun} with @code{defsubst}.  Since each
@c argument of an inline function is evaluated exactly once, you needn't
@c worry about how many times the body uses the arguments, as you do for
@c macros.

  Вместо @code{defsubst} можно использовать @code{define-inline} для
определения функции через макрос компиляции. @xref{Defining Functions, define-inline}.

@c   As an alternative to @code{defsubst}, you can use
@c @code{define-inline} to define functions via their exhaustive compiler
@c macro.  @xref{Defining Functions, define-inline}.

@node Declare Form
@section Форма @code{declare}
@c @section The @code{declare} Form
@findex declare

  @code{declare} является специальным макросом который может
использоваться для добавления служебных свойств функциям или макросам:
например, помечая их как устаревшие, или задавая их формам специальную
обработку отступов по @key{TAB} в режиме Emacs Lisp.

@c   @code{declare} is a special macro which can be used to add meta
@c properties to a function or macro: for example, marking it as
@c obsolete, or giving its forms a special @key{TAB} indentation
@c convention in Emacs Lisp mode.

@anchor{Definition of declare}
@defmac declare specs@dots{}
Макрос игнорирует аргументы и вычисляется в @code{nil} без эффекта.
Но, когда форма @code{declare} встречается в аргументе @code{declare}
формы @code{defun} или @code{defsubst} определения функции (@pxref{Definition Functions})
или @code{defmacro} определения макроса (@pxref{Definition Macros}), свойства
заданные @var{specs} добавляются к функции или макросу.

@c This macro ignores its arguments and evaluates to @code{nil}; it has
@c no run-time effect.  However, when a @code{declare} form occurs in the
@c @var{declare} argument of a @code{defun} or @code{defsubst} function
@c definition (@pxref{Defining Functions}) or a @code{defmacro} macro
@c definition (@pxref{Defining Macros}), it appends the properties
@c specified by @var{specs} to the function or macro.  This work is
@c specially performed by @code{defun}, @code{defsubst}, and
@c @code{defmacro}.

Каждый элемент в @var{specs} должен иметь форму @code{(@var{property} @var{args}@dots{})},
которые не должны быть квотированы (quoted). Возможны следующие
свойства:

@c Each element in @var{specs} should have the form @code{(@var{property}
@c @var{args}@dots{})}, which should not be quoted.  These have the
@c following effects:

@table @code
@item (advertised-calling-convention @var{signature} @var{when})
Работает как вызов @code{set-advertised-calling-convention}
(@pxref{Obsolete Function});  @var{signature} определяет
корректный список аргументов вызова, @var{when} должно быть
строкой указывающей на то, когда старый список аргументов стал
устаревшим.

@c This acts like a call to @code{set-advertised-calling-convention}
@c (@pxref{Obsolete Functions}); @var{signature} specifies the correct
@c argument list for calling the function or macro, and @var{when} should
@c be a string indicating when the old argument list was first made obsolete.

@item (debug @var{edebug-form-spec})
Применимо только для макросов. При отладки макроса в Edebug,
будет использоваться @var{edebug-form-spec}. @xref{Instrumenting Macro Calls}.

@c This is valid for macros only.  When stepping through the macro with
@c Edebug, use @var{edebug-form-spec}.  @xref{Instrumenting Macro Calls}.

@item (doc-string @var{n})
Используется когда определяется макрос или функция, который будет исплоьзоваться
для определения сущностей таких как функции, макросы или переменные. Данное свойство
указывает, что @var{n} аргумент, если задан, должен рассматриваться
как строка документации.

@c This is used when defining a function or macro which itself will be used to
@c define entities like functions, macros, or variables.  It indicates that
@c the @var{n}th argument, if any, should be considered
@c as a documentation string.

@item (indent @var{indent-spec})
Выполнять отступы в вызовах функции или макроса в
соответствии с @var{indent-spec}. Как правило используется
для макросов, хотя работает и с функциями.
@xref{Indenting Macros}.

@c Indent calls to this function or macro according to @var{indent-spec}.
@c This is typically used for macros, though it works for functions too.
@c @xref{Indenting Macros}.

@item (interactive-only @var{value})
Установить свойство @code{interactive-only} функции в @var{value}.
@xref{The interactive-only property}.
@c Set the function's @code{interactive-only} property to @var{value}.
@c @xref{The interactive-only property}.

@item (obsolete @var{current-name} @var{when})
Помечает функцию или макрос как устаревшую, аналогично вызову
@code{make-obsolete} (@pxref{Obsolete Functions}). @var{current-name}
должно быть символом (в этом случае предупреждение будет говорить использовать
ее вместо текущей функции) или строкой (будет использоваться как сообщение
предупреждения), или @code{nil} (предупреждение будет без дополнительных подробностей).
@var{when} должно быть строкой указывающей на то, когда функция или макрос
стали устаревшими.

@c Mark the function or macro as obsolete, similar to a call to
@c @code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name}
@c should be a symbol (in which case the warning message says to use that
@c instead), a string (specifying the warning message), or @code{nil} (in
@c which case the warning message gives no extra details).  @var{when}
@c should be a string indicating when the function or macro was first
@c made obsolete.

@item (compiler-macro @var{expander})
Применимо только для функцией, и указывает компилятору использовать
@var{expander} как функцию оптимизации. При встрече вызова функции
в форме @code{(@var{function} @var{args}@dots{})}, раскрыватель макросов
вызовет @var{expander} с этой формой, и с @var{args}@dots{}, и @var{expander}
может вернуть другое выражение, которое нужно использовать вместо
вызова функции, или может вернуть форму неизменной. @var{expander} может
быть символом, или формой @code{(lambda (@var{arg}) @var{body})}, во втором
случае @var{arg} будет содержать исходное выражение вызова функции,
и (не вычисленные) аргументы функции могут быть получены используя
формальные аргументы функции.

@c This can only be used for functions, and tells the compiler to use
@c @var{expander} as an optimization function.  When encountering a call to the
@c function, of the form @code{(@var{function} @var{args}@dots{})}, the macro
@c expander will call @var{expander} with that form as well as with
@c @var{args}@dots{}, and @var{expander} can either return a new expression to use
@c instead of the function call, or it can return just the form unchanged,
@c to indicate that the function call should be left alone.  @var{expander} can
@c be a symbol, or it can be a form @code{(lambda (@var{arg}) @var{body})} in
@c which case @var{arg} will hold the original function call expression, and the
@c (unevaluated) arguments to the function can be accessed using the function's
@c formal arguments.

@item (gv-expander @var{expander})
Задает @var{expander} в качестве функции для обработки вызовом макроса
(или функции) как обобщенной переменной, аналогично @code{gv-define-expander}.
@var{expander} может символом или формой @code{(lambda (@var{arg} @var{body}))}.
Во втором случае функция дополнительно получит доступ к аргументам макроса (или функции).

@c Declare @var{expander} to be the function to handle calls to the macro (or
@c function) as a generalized variable, similarly to @code{gv-define-expander}.
@c @var{expander} can be a symbol or it can be of the form @code{(lambda
@c (@var{arg}) @var{body})} in which case that function will additionally have
@c access to the macro (or function)'s arguments.

@item (gv-setter @var{setter})
Определяет @var{setter} в качестве функции обрабатывающий вызова к макросу
(или функции) как обобщенная переменная. @var{setter} может быть символом
и тогда, он будет передан в @code{gv-define-expander}, или формой
@code{(lambda @var{arg} @var{body})} и в этом случае функция будет
иметь доступ к аргументам макроса (или функции) и будет
передана @code{gv-define-setter}.

@c Declare @var{setter} to be the function to handle calls to the macro (or
@c function) as a generalized variable.  @var{setter} can be a symbol in which
@c case it will be passed to @code{gv-define-simple-setter}, or it can be of the
@c form @code{(lambda (@var{arg}) @var{body})} in which case that function will
@c additionally have access to the macro (or function)'s arguments and it will
@c passed to @code{gv-define-setter}.

@end table

@end defmac

@node Declaring Functions
@section Указание Компилятору, что Функция Определена 
@c @section Telling the Compiler that a Function is Defined
@cindex function declaration
@cindex declaring functions
@findex declare-function

Байт-компиляция файла часто выдает предупреждения о неизвестных
функциях (@pxref{Compiler Errors}). В ряде случаев это указывает
на реальную проблему, но часто функции в сообщениях определены в
других файлах, которые будут загружены когда код будет выполняться.
Например, байт-компиляция @file{fortran.el} будет выдавать предупреждение:

@c Byte-compiling a file often produces warnings about functions that the
@c compiler doesn't know about (@pxref{Compiler Errors}).  Sometimes this
@c indicates a real problem, but usually the functions in question are
@c defined in other files which would be loaded if that code is run.  For
@c example, byte-compiling @file{fortran.el} used to warn:

@example
In end of data:
fortran.el:2152:1:Warning: the function ‘gud-find-c-expr’ is not
    known to be defined.
@end example

Фактически, @code{gud-find-c-expr} используется только в функции
которую режим Fortran использует для вычисления
локального значения @var{gud-find-expr-function}, являющуюся
функцией обратного вызова (callback) из GUD; если она вызывается
GUD функции будут загружены. Если известно, что такое предупреждение
не соответствует проблеме, 
In fact, @code{gud-find-c-expr} is only used in the function that
Fortran mode uses for the local value of стоит скрыть такие предупреждения.
В этом случае другие предупреждения, которые показывают реальные проблемы
будут более значимы. Скрыть предупреждение можно с помощью @code{declare-function}.

@c @code{gud-find-expr-function}, which is a callback from GUD; if it is
@c called, the GUD functions will be loaded.  When you know that such a
@c warning does not indicate a real problem, it is good to suppress the
@c warning.  That makes new warnings which might mean real problems more
@c visible.  You do that with @code{declare-function}.

Чтобы предупреждения не было, нужно выполнить @code{declare-function}
до первого использования функции:

@c All you need to do is add a @code{declare-function} statement before the
@c first use of the function in question:

@example
(declare-function gud-find-c-expr "gud.el" nil)
@end example

Данное выражение указывает, что @code{gud-find-c-expr} определено в
@file{gud.el} (@samp{.el} можно опустить). Компилятор не проверяет,
что такая функция в файле есть.

@c This says that @code{gud-find-c-expr} is defined in @file{gud.el} (the
@c @samp{.el} can be omitted).  The compiler takes for granted that that file
@c really defines the function, and does not check.

  Не обязательный третий аргумент, определяет список аргументов
@code{gud-find-c-expr}. В этом случае, функция не принимает
аргументов (@code{nil} не тоже самое, что пропустить аргумент). В других
случаях, значение может быть чем-то вроде @code{(file &optional overwrite)}.
Задавать список аргументов не обязательно, но если его задать
компилятор выполнит проверку, что вызов соответствует сигнатуре.

@c   The optional third argument specifies the argument list of
@c @code{gud-find-c-expr}.  In this case, it takes no arguments
@c (@code{nil} is different from not specifying a value).  In other
@c cases, this might be something like @code{(file &optional overwrite)}.
@c You don't have to specify the argument list, but if you do the
@c byte compiler can check that the calls match the declaration.

@defmac declare-function function file &optional arglist fileonly
Макрос указывает компилятору, на то что функция @var{function} определена,
с аргументами @var{arglist}, и что определение задано в файле @var{file}.
Если @var{fileonly} не-@code{nil} будет выполняться проверка только
наличие файла, и не будет проверяться, что функция @var{function} действительно
там определяется.

@c Tell the byte compiler to assume that @var{function} is defined, with
@c arguments @var{arglist}, and that the definition should come from the
@c file @var{file}.  @var{fileonly} non-@code{nil} means only check that
@c @var{file} exists, not that it actually defines @var{function}.
@end defmac

  Чтобы проверить, что функция действительно определена там
где указано в @code{declare-function}, можно использовать
@code{check-declare-file}, чтобы проверить все
вызовы @code{declare-function} в одном файле исходного кода, или использовать
@code{check-declare-directory} для проверки всех файлов в некотором
каталоге.

@c   To verify that these functions really are declared where
@c @code{declare-function} says they are, use @code{check-declare-file}
@c to check all @code{declare-function} calls in one source file, or use
@c @code{check-declare-directory} check all the files in and under a
@c certain directory.

  Указанные команды находят файл указанный в качестве источника определения
функции с помощью @code{locate-library}; если файл не находится,
строится полное имя файла относительно каталога с файлом содержащим вызов
@code{declare-function}.

@c   These commands find the file that ought to contain a function's
@c definition using @code{locate-library}; if that finds no file, they
@c expand the definition file name relative to the directory of the file
@c that contains the @code{declare-function} call.

  Можно указать, что функция является примитивной (primitive) путем
указания имени оканчивающегося на @samp{.c} или @samp{.m}. Такая возможность
полезна если вызывается примитив который определен только
для некоторых систем. Большинство примитивов всегда определены,
поэтому они никогда не приводят к появлению предупреждений.

@c   You can also say that a function is a primitive by specifying a file
@c name ending in @samp{.c} or @samp{.m}.  This is useful only when you
@c call a primitive that is defined only on certain systems.  Most
@c primitives are always defined, so they will never give you a warning.

  В ряде случаев использование функции из некоторого пакета не постоянно.
В этом случае в @code{declare-function} имя файла можно задать с
префиксом @samp{ext:}, тогда если файл будет найден будет выполнена
проверка, иначе проверка будет пропущена без сообщения об ошибке.

@c   Sometimes a file will optionally use functions from an external package.
@c If you prefix the filename in the @code{declare-function} statement with
@c @samp{ext:}, then it will be checked if it is found, otherwise skipped
@c without error.

  Некоторые определения функций @samp{check-declare} не понимает
(например @code{destruct} и некоторые другие макросы). В этих
случаях, стоит задать не-@code{nil} для параметра @var{fileonly} @code{declare-function},
подразумевая, что нужно проверить только наличие файла, и не проверять
определение функции. Если нужно задать данный аргумент
и не задавать список аргументов, стоит в качестве @var{arglist} задать
@code{t} (так как @code{nil} означает пустой список аргументов).

@c   There are some function definitions that @samp{check-declare} does not
@c understand (e.g., @code{defstruct} and some other macros).  In such cases,
@c you can pass a non-@code{nil} @var{fileonly} argument to
@c @code{declare-function}, meaning to only check that the file exists, not
@c that it actually defines the function.  Note that to do this without
@c having to specify an argument list, you should set the @var{arglist}
@c argument to @code{t} (because @code{nil} means an empty argument list, as
@c opposed to an unspecified one).

@node Function Safety
@section Определение является ли Функция Безопасной 
@c @section Determining whether a Function is Safe to Call
@cindex function safety
@cindex safety of functions

Некоторые основные режимы, такие как SES, вызывают функций
которые хранятся в пользовательских файлах. (@inforef{Top, ses}, для получения
информации по SES@). Пользовательские файлы временами имеют сомнительное
происхождение --- некоторые получены по email от тех кого пользователь
не знает. Поэтому вызывать функции хранящиеся в таких файлах может
быть не безопасно, до того как они будут проверены и установлено,
что они безопасны.

@c Some major modes, such as SES, call functions that are stored in user
@c files.  (@inforef{Top, ,ses}, for more information on SES@.)  User
@c files sometimes have poor pedigrees---you can get a spreadsheet from
@c someone you've just met, or you can get one through email from someone
@c you've never met.  So it is risky to call a function whose source code
@c is stored in a user file until you have determined that it is safe.

@defun unsafep form &optional unsafep-vars
Вызов возвращает @code{nil} если @var{form} является @dfn{safe} (@dfn{безопасным})
Lisp выражением, или возвращает список описывающий почему выражение
может быть опасным. Аргумент @var{unsafe-vars} задает список символов про
которые известно, что они имеют временное связывание в данной точке;
что как правило используется в рекурсивных вызовах. Текущий буфер является
неявным аргументом, который предоставляет список локальных для буфера
связываний.

@c Returns @code{nil} if @var{form} is a @dfn{safe} Lisp expression, or
@c returns a list that describes why it might be unsafe.  The argument
@c @var{unsafep-vars} is a list of symbols known to have temporary
@c bindings at this point; it is mainly used for internal recursive
@c calls.  The current buffer is an implicit argument, which provides a
@c list of buffer-local bindings.
@end defun

@code{unsafep} является быстрой и простой и предоставляет очень поверхностный
анализ и забраковывает многие Lisp выражения которые на самом деле являются
безопасными. Не известно ситуаций в которых @code{unsafep} возвращает @code{nil} для
не безопасных выражений. Но, безопасные Lisp выражения могут вернуть
строку со свойством @code{display}, содержащей связанное Lisp выражение
которое будет выполнено после того, как строка будет вставлена
в буфер. Такое связанное выражение может быть вирусом. Чтобы обезопасить
себя, нужно удалять свойства из всех строк, которые вычисляются
пользовательским кодом перед вставкой их в буфер.

@c Being quick and simple, @code{unsafep} does a very light analysis and
@c rejects many Lisp expressions that are actually safe.  There are no
@c known cases where @code{unsafep} returns @code{nil} for an unsafe
@c expression.  However, a safe Lisp expression can return a string
@c with a @code{display} property, containing an associated Lisp
@c expression to be executed after the string is inserted into a buffer.
@c This associated expression can be a virus.  In order to be safe, you
@c must delete properties from all strings calculated by user code before
@c inserting them into buffers.

@ignore
What is a safe Lisp expression?  Basically, it's an expression that
calls only built-in functions with no side effects (or only innocuous
ones).  Innocuous side effects include displaying messages and
altering non-risky buffer-local variables (but not global variables).

@table @dfn
@item Safe expression
@itemize
@item
An atom or quoted thing.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
One of the special forms @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, and @code{unwind-protect}], if all its arguments are
safe.
@item
A form that creates temporary bindings (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
@code{let*}), if all args are safe and the symbols to be bound are not
explicitly risky (see @pxref{File Local Variables}).
@item
An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
@code{pop}, if all args are safe and the symbols to be assigned are
not explicitly risky and they already have temporary or buffer-local
bindings.
@item
One of [apply, mapc, mapcar, mapconcat] if the first argument is a
safe explicit lambda and the other args are safe expressions.
@end itemize

@item Safe function
@itemize
@item
A lambda containing safe expressions.
@item
A symbol on the list @code{safe-functions}, so the user says it's safe.
@item
A symbol with a non-@code{nil} @code{side-effect-free} property.
@item
A symbol with a non-@code{nil} @code{safe-function} property.  The
value @code{t} indicates a function that is safe but has innocuous
side effects.  Other values will someday indicate functions with
classes of side effects that are not always safe.
@end itemize

The @code{side-effect-free} and @code{safe-function} properties are
provided for built-in functions and for low-level functions and macros
defined in @file{subr.el}.  You can assign these properties for the
functions you write.
@end table
@end ignore

@node Related Topics
@section Другие Темы Связанные с Функциями
@c @section Other Topics Related to Functions

  В таблице приводится список функций которые выполняют вещи
связанные с вызовом и определением функций. Документация
на них содержится в других разделах, а тут предоставляются только
ссылки на них.

@c   Here is a table of several functions that do things related to
@c function calling and function definitions.  They are documented
@c elsewhere, but we provide cross references here.

@table @code
@item apply
См. @ref{Calling Functions}.
@c See @ref{Calling Functions}.

@item autoload
См. @ref{Autoload}.
@c See @ref{Autoload}.

@item call-interactively
См. @ref{Interactive Call}.
@c See @ref{Interactive Call}.

@item called-interactively-p
См. @ref{Distinguish Interactive}.
@c See @ref{Distinguish Interactive}.

@item commandp
См. @ref{Interactive Call}.
@c See @ref{Interactive Call}.

@item documentation
См. @ref{Accessing Documentation}.
@c See @ref{Accessing Documentation}.

@item eval
См. @ref{Eval}.
@c See @ref{Eval}.

@item funcall
См. @ref{Calling Functions}.
@c See @ref{Calling Functions}.

@item function
См. @ref{Anonymous Functions}.
@c See @ref{Anonymous Functions}.

@item ignore
См. @ref{Calling Functions}.
@c See @ref{Calling Functions}.

@item indirect-function
См. @ref{Function Indirection}.
@c See @ref{Function Indirection}.

@item interactive
См. @ref{Using Interactive}.
@c See @ref{Using Interactive}.

@item interactive-p
См. @ref{Distinguish Interactive}.
@c See @ref{Distinguish Interactive}.

@item mapatoms
См. @ref{Creating Symbols}.
@c See @ref{Creating Symbols}.

@item mapcar
См. @ref{Mapping Functions}.
@c See @ref{Mapping Functions}.

@item map-char-table
См. @ref{Char-Tables}.
@c See @ref{Char-Tables}.

@item mapconcat
См. @ref{Mapping Functions}.
@c See @ref{Mapping Functions}.

@item undefined
См. @ref{Functions for Key Lookup}.
@c See @ref{Functions for Key Lookup}.
@end table
