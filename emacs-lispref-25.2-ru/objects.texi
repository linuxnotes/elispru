@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2017 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Lisp Data Types
@chapter Типы данных в Lisp
@cindex object
@cindex Lisp object
@cindex type
@cindex data type

  Lisp @dfn{объект} (@dfn{object}) это данные которые
используются и изменяются Lisp программами. Мы будем
рассматривать @dfn{type} или @dfn{data type} как
множество возможных объектов. (То есть тип определят
набор значение которые может принимать объект данного типа).

  Каждый объект принадлежит хотя бы к 1 типу. Объекты одного
типа похожи по структуре и как правило могут использоваться в схожих
контекстах. Типы могут пересекаться, и объекты могут
относится к двум и более типам. В результате чего можно
проверить относится ли объект к определенному типу, но
не узнать (какой именно) тип объекта. (Прим. имеется
ввиду, что нельзя узнать один тип объекта).

@cindex primitive type

  Ряд фундаментальных (базовых) типов уже встроены в Emacs. Такие типа,
на основе которых строятся все другие типы, называются @dfn{примитивными типами}
(@dfn{primitive types}). Каждый объект относится только к 1 примитивному типу.
Это типы: @dfn{integer}, @dfn{float}, @dfn{cons}, @dfn{symbol},
@dfn{string}, @dfn{vector}, @dfn{hash-table}, @dfn{subr}, и
@dfn{byte-code function}, и еще несколько специальных типа,
таких как @dfn{buffer}, которые используются при редактировании.
(целые, числа с плавающей точкой, cons-ячейки, ...., буфер)
(@xref{Editing Types}.)

  Для каждого из примитивных типов есть Lisp функция, которая проверяет
относится ли заданный объект к этому типу.

  Lisp в отличие от многих других языков в которых объекты
являются само-определяющимися @dfn{self-typing}: примитивный тип
каждого объекта неявно является частью объекта. Например, если
объект вектор, то он нигде не может трактоваться как число;
Lisp всегда знает, что это вектор, а не число.

  Как правило программист должен определить тип данных для каждой переменной,
таким образом компилятор будет знать тип переменной, но в данных
тип представлен не будет. В Emacs Lisp нет такого задания типов. Lisp
переменная может содержать значение любого тип, и в ней хранится
информация о ток, какого типа переменная в ней хранится. (На практике,
некоторые Emacs Lisp переменные могут хранить значение только определенных
типов (прим. видимо которые соответствуют переменным из C)).
@xref{Variables with Restricted Values}.)

  В данной главе описывается назначение, печатная форма, и синтаксис
чтения для каждого из стандартных типов в GNU Emacs Lisp. Детали
использования будут рассмотрены в следующих главах.

(Прим. Read syntax в оригинале будем переводить как синтаксис чтения,
 подразумевая, что это запись которая может быть считана
 Lisp и выполнена или преобразована в объекты данных
 Может быть лучше использовать форма чтения).

@menu
* Printed Representation::      Как Lisp объекты представлены в текстовом виде.
* Comments::                    Комментарии и соглашения по их форматированию.
* Programming Types::           Типы присутствующие во всех Lisp.
* Editing Types::               Типы являющиеся уникальными в Emacs.
* Circular Objects::            Запись циклических структур.
* Type Predicates::             Проверки типов.
* Equality Predicates::         Сравнение произвольных объектов.
@end menu

@node Printed Representation
@section Печатная форма и синтаксис чтения.
@cindex printed representation
@cindex read syntax

  Печатная форма.

  @dfn{Печатная форма} (@dfn{printed representation}) объект
это формат вывода которые генерируется печатающей Lisp машиной (функция @code{prin1})
для заданного объекта. Каждый тип данных имеет уникальную печатную
форму. @dfn{Синтаксис чтения} (@dfn{read syntax}) объекта это формат
ввода, которые может быть принят Lisp считывателем (парсером) (функция
@code{read}) для объекта. Синтаксис чтения не уникальный, объекты
могут иметь несколько синтаксисов чтения (форм чтения).

@cindex hash notation
хешированая нотация

  Часто печатная форма, является так же формой для чтения этого
объекта. Но, некоторые типы не имеют формы чтения, поэтому было
бы не разумно выводить такие объекты на печать как константы
в Lisp программе. Такие объекты печатаются в @dfn{хеш нотации}
@dfn{hash notation}, которая состоит из @samp{#<}, строки описания
объекта (как правило имя объекта и имя типа), и закрывающей @samp{>}.
Например:

@example
(current-buffer)
     @result{} #<buffer objects.texi>
@end example

@noindent
Хеш нотация не может быть считана, поэтому Lisp парсер сообщает
об ошибке @code{invalid-read-syntax}, когда встречает @samp{#<}.
@kindex invalid-read-syntax

  В других языках, выражение это текст, у него нет другой формы.
В Lisp, выражение в первую очередь Lisp объект и во вторую очередь
это текст, который является записью для считывания (синтаксис чтения).
Как правило, можно не делать различие между объектом и его синтаксисом (для парсера),
но все же стоит об этом знать, так как изредка встречаются
случаи, которые иначе покажутся не понятными.

  Когда выражение вычисляется интерактивно, Lisp интерпретатор,
сначала считывает текстовое представление, строит Lisp объекта,
и после чего вычисляет этот объект (@pxref{Evaluation}). Но,
вычисление и чтение это разные действия. Чтение возвращает Lisp объект,
представленный считанным текстом, этот объект может быть позднее вычислен,
а может и нет. @xref{Input Functions}, для описания @code{read},
является базовой функцией чтения объектов.
(? @code{read}, является базовой функцией для чтения объектов)

@node Comments
@section Комментарии
@cindex comments
@cindex @samp{;} in comment

  Комментарии.
  @dfn{комментарий} (@dfn{comment}) это текст программы, написанный
для людей, которые будут читать программу не влияющий на саму программу.
В Lisp, комментарии начинаются с (@samp{;}), если @samp{;} не находится
внутри строковой константы. Комментарий занимает всю строку после @samp{;}.
Считыватель Lisp, удаляет комментарии, они не становятся частью Lisp объекта,
представляющего программу.

  @samp{#@@@var{count}} конструкт, который пропускает следующие
@var{count} символов, используется для программно сгенерированных
комментариев содержащих бинарные данные. Байт компилятор Emacs Lisp
использует его в файлах результата (@pxref{Byte Compilation}).
Но, данная конструкция не применима для исходников.

  @xref{Comment Tips}, соглашения по форматированию комментариев.

@node Programming Types
@section Типы
@cindex programming types

  В Emacs Lisp есть 2 основных категории типов: имеющие отношение
к программированию на Lisp и имеющие отношение к редактированию.
Первые присутствуют во многих реализациях Lisp в той или иной форме.
Вторые являются уникальными для Emacs Lisp.

@menu
* Integer Type::        Числа без дробной части.
* Floating-Point Type:: Числа с дробной частью и большим диапазоном.
* Character Type::      Представление символов, цифр и управляющих символов.
* Symbol Type::         Многофункциональный объект, который ссылается на функцию,
                        переменную, список свойств и имеет уникальный идентификатор.
* Sequence Type::       Списки и массивы рассматриваются как последовательности.
* Cons Cell Type::      Cons ячейки, и списки (которые составлены из cons ячеек).
* Array Type::          Массивы включая строки и векторы.
* String Type::         Строки как эффективные массивы символов.
* Vector Type::         Одномерные векторы.
* Char-Table Type::     Одномерные разреженные массивы проиндексированные символами.
* Bool-Vector Type::    Одномерные массивы из @code{t} или @code{nil}.
* Hash Table Type::     Сверхбыстрые таблицы поиска.
* Function Type::       Кусочек кода, которые можно вызвать откуда угодно.
* Macro Type::          Метод расширения выражения в другое выражение, более
                        фундаментальное, но менее красивое (удобное).
* Primitive Function Type::  C функции вызываемые из Lisp.
* Byte-Code Type::      Функции написанные на Lisp, и скомпилированные.
* Autoload Type::       Тип используемый для автозагрузки редко используемых функций.
* Finalizer Type::      Запуск кода для объектов которые больше недоступны.
                        (При выполнении очистки).

@end menu

@node Integer Type
@subsection Целочисленный тип

  Интервал значений для целочисленного типа зависит от машины.
Минимальный диапазон @minus{}536,870,912 до 536,870,911 (30 битов; т.е,
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
to
@ifnottex
2**29 @minus{} 1)
@end ifnottex
@tex
@math{2^{29}-1})
@end tex
но многие машины предоставляют более большой диапазон.
Арифметические функции в Emacs Lisp  не проверяют целочисленное
переполнение. Поэтому @code{(1+ 536870911)} равно
@minus{}536,870,912 если целые числа в Emacs 30 битные.

  Синтаксис чтения для целых чисел это последовательность (по умолчанию десятичных)
цифр с необязательным знаком в начале и необязательным периодом в конце.
При печати чисел Lisp интерпретатором начальный @samp{+} и конечная @samp{.}
не печатаются.

@example
@group
-1               ; @r{Число @minus{}1.}
1                ; @r{Число 1.}
1.               ; @r{Так же 1.}
+1               ; @r{Так же 1.}
@end group
@end example

@noindent
Особое исключение, если последовательность цифр задает число
слишком большое или слишком маленькое для целочисленного
объекта, считыватель Lisp (Lisp reader) считывает его как
число с плавающей точкой (@pxref{Floating-Point Type}).
Например, если в Emacs целочисленный тип 30 битный, @code{536870912}
считывается как число с плавающей точкой @code{536870912.0}.

  См. @xref{Numbers}, для более детальной информации.

@node Floating-Point Type
@c @subsection Floating-Point Type
@subsection Числа с плавающей точкой

  Числа с плавающей точкой являются аналогом научной записи
чисел доступной компьютеру, можно рассматривать такие числа
как дробь вместе с десятичной экспонентой. Точность числа и
диапазон экспонент машинно-зависимы; Emacs использует C тип
@code{double} для хранения значения, и во внутреннем представлении
используется степень 2, а не 10.

  Печатная форма чисел с плавающей точкой записывается
с десятичной точкой требует хотя бы 1 цифру после запятой, так же
возможно запись с экспонентой. Например  @samp{1500.0}, @samp{+15e2},
@samp{15.0e+2}, @samp{+1500000e-3}, и @samp{.15e4}, 5 способов
записи 1500 (число целое, но используется как с плавающей точкой).
Все записи эквивалентны.

  См. @xref{Numbers}, для более детальной информации.

@node Character Type
@c @subsection Character Type
@subsection Символьный тип
@cindex @acronym{ASCII} character codes

  @dfn{Символ} (@dfn{character}) в Emacs Lisp это целое число.
Другими словами символы представлены своими кодами. Например,
символ @kbd{A}, представляется как @w{integer 65}.

  Отдельные символы редко используются в программах, т.к. как
правило в программе выполняются действия со @emph{строками}(@emph{strings}),
которые являются последовательностями символов. @xref{String Type}.

  В строках и буферах могут использоваться символы из диапазона
0 .. 4194303  (32 бита) (@pxref{Character Codes}). Коды от 0 до 127
являются @acronym{ASCII} кодами, остальные не-@acronym{ASCII} (@pxref{Non-ASCII Characters}).
Символы ввода с клавиатуры имеют более широкий
диапазон, для кодирования кодов клавиш модификаторов таких
как Control, Meta и Shift.

  Существует специальные функции для получения читаемого (human-readable)
представления символа нужная в сообщениях. @xref{Describing
Characters}.

@menu
* Basic Char Syntax::      Синтаксис обычных символов.
* General Escape Syntax::  Как задать символ по коду.
* Ctl-Char Syntax::        Синтаксис управляющих символов.
* Meta-Char Syntax::       Синтаксис мета-символов(meta-characters).
* Other Char Bits::        Синтаксис hyper-, super-, и alt-characters.
@end menu

@node Basic Char Syntax
@subsubsection Basic Char Syntax
@cindex read syntax for characters
@cindex printed representation for characters
@cindex syntax for characters
@cindex @samp{?} in character constant
@cindex question mark in character constant

  Так как символы это числа, печатная форма символа это число.
Так же это является синтаксисом для чтения, но записывать символы в
таком виде при программировании на Lisp не удобно. Стоит использовать
специальный синтаксис записи для символов предоставляемый Emacs Lisp.
Такой синтаксис начинается с вопроса.

  Обычный синтаксис чтения для буквенно-числовых символов состоит
из знака вопроса и самого символа,  @samp{?A} соответствует @kbd{A},
@samp{?B} соответствует @kbd{B}, @samp{?a} соответствует @kbd{a}.

  Например:

@example
?Q @result{} 81     ?q @result{} 113
@end example

  Можно использовать этот же синтаксис и для знаков пунктуации
(не буквы и ну цифры), но как правило стоит добавлять @samp{\},
чтобы команды Emacs для редактирования Lisp кода могли
их однозначно обработать (избежать неоднозначности).
Например, так @samp{?\(} можно записать открывающую скобку.
Чтобы ввести символ @samp{\}, @emph{нужно} использовать
вторую @samp{\} для экранирования, получится так: @samp{?\\}.

@cindex whitespace
@cindex bell character
@cindex @samp{\a}
@cindex backspace
@cindex @samp{\b}
@cindex tab (ASCII character)
@cindex @samp{\t}
@cindex vertical tab
@cindex @samp{\v}
@cindex formfeed
@cindex @samp{\f}
@cindex newline
@cindex @samp{\n}
@cindex return (ASCII character)
@cindex @samp{\r}
@cindex escape (ASCII character)
@cindex @samp{\e}
@cindex space (ASCII character)
@cindex @samp{\s}
  Так можно записать Ctrl-g, backspace, tab, newline,
vertical tab, formfeed, space, return, del, и escape:
@samp{?\a},
@samp{?\b}, @samp{?\t}, @samp{?\n}, @samp{?\v}, @samp{?\f},
@samp{?\s}, @samp{?\r}, @samp{?\d}, and @samp{?\e}.
(@samp{?\s} со следующим символом тире (dash) меняет значение --- он
становится Super модификатором для следующего символа.)  Таким образом,

@example
?\a @result{} 7                 ; @r{control-g, @kbd{C-g}}
?\b @result{} 8                 ; @r{backspace, @key{BS}, @kbd{C-h}}
?\t @result{} 9                 ; @r{tab, @key{TAB}, @kbd{C-i}}
?\n @result{} 10                ; @r{newline, @kbd{C-j}}
?\v @result{} 11                ; @r{vertical tab, @kbd{C-k}}
?\f @result{} 12                ; @r{formfeed character, @kbd{C-l}}
?\r @result{} 13                ; @r{carriage return, @key{RET}, @kbd{C-m}}
?\e @result{} 27                ; @r{escape character, @key{ESC}, @kbd{C-[}}
?\s @result{} 32                ; @r{space character, @key{SPC}}
?\\ @result{} 92                ; @r{backslash character, @kbd{\}}
?\d @result{} 127               ; @r{delete character, @key{DEL}}
@end example

@cindex escape sequence
  Последовательность которая начинается с обратного слеша (backslash)
называется @dfn{escape sequences}, так как обратный слеш
играет роль символа экранирования (это никак не связано с символом @key{ESC}).
@samp{\s} означает использовать строковую константу
because backslash plays the role of an
escape character; this has nothing to do with the
character @key{ESC}.  @samp{\s} предназначен
для использования в константах; в строковой константе (в строке) это просто
пробел.

  Обратный слеш разрешено и безопасно использовать перед
символами без специального значения, таким образом @samp{?\+}
эквивалентно @samp{?+}. Перед большинством символов добавлять
обратный слеш нет необходимости. Но его нужно добавлять перед
символами @samp{()\|;'`"#.,}, чтобы избежать неоднозначности
Emacs команд по редактированию Lisp кода. Так стоит добавлять
обратный слеш перед символами пустоты (пробельными), такими как
пробел, tab, символ новой строки (newline) и formfeed. Но еще
лучше использовать читаемые записи для этих символов такие как
@samp{\t} и @samp{\s}, вместо реального использования пробелов.
(Если вы ввели обратный слеш и пробел, нужно написать еще 1 пробел
после константы, чтобы отделить ее от остального текста.)

@node General Escape Syntax
@subsubsection General Escape Syntax

  Escape последовательности могут использоваться не только для
важных управляющих символов, но так же для задания не-@acronym{ASCII}
символов.

@cindex @samp{\} in character constant
@cindex backslash in character constants
@cindex unicode character escape
  Например, можно задать символ по его Unicode коду.

@code{?\u@var{nnnn}} представит символ Unicode c кодом
@samp{U+@var{nnnn}}, где @var{nnnn}  (по соглашению) шестнадцатеричное
число с 4 цифрами. Обратный слеш указывает на то, что
последующие символы являются escape последовательностью, а @samp{u}
задает, что это Unicode escape последовательность.

  Немного другой синтаксис для определения Unicode
символов с кодом больше чем @code{U+@var{ffff}}:
@code{?\U00@var{nnnnnn}} представляет символ с кодом
@samp{U+@var{nnnnnn}}, где @var{nnnnnn} шесть шестнадцатеричных
цифр. Стандарт Unicode определяет коды только до @samp{U+@var{10ffff}},
поэтому если указать код больше этого Emacs сообщит об ошибке.

  Кроме того можно задать символ по его шестнадцатеричному коду.
Шестнадцатеричная escape последовательность состоит
из обратного слеша, @samp{x} и шестнадцатеричного кода символа.
Таким образом, @samp{?\x41} соответствует символу
@kbd{A}, @samp{?\x1} символу @kbd{C-a}, а @code{?\xe0} символу @kbd{à}
(а с ударением). Можно использовать любое количество шестнадцатеричных
цифр, что позволяет задать любой символ таким образом.

@cindex octal character code
  Так же можно задать символ по его коду в восьмеричной системе.
Восьмеричная escape последовательность состоит из обратного слеша,
после чего должны быть 3 восьмеричных цифры, т.е. @samp{?\101}
для @kbd{A}, @samp{?\001} для  @kbd{C-a}, и @code{?\002}
для @kbd{C-b}. Таким образом могут быть заданы символы только до
777 в восьмеричной системе счисления.

  Escape последовательность может быть использована в строках. @xref{Non-ASCII
in Strings}.

@node Ctl-Char Syntax
@subsubsection Control-Character Syntax

@cindex control characters
  Управляющие символы могут быть представлены используя другой синтаксис чтения.
Он состоит из знака вопроса, обратного слеша, знака каретки, и
соответствующего не управляющего символа, в верхнем или нижнем
регистре. Например: @samp{?\^I} и @samp{?\^i} корректный синтаксис
чтения для @kbd{C-i}, символа со значением 9.

  Вместо @samp{^}, можно использовать @samp{C-}; т.е. @samp{?\C-i}
эквивалентно @samp{?\^I} и @samp{?\^i}.

@example
?\^I @result{} 9     ?\C-I @result{} 9
@end example

  В строках и буферах, разрешены только управляемые символы @acronym{ASCII},
но в качестве клавиатурных сочетаний, можно превратить любой
символ в управляющий с помощью @samp{C-}. Коды для не-@acronym{ASCII}
управляющих символов включат
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
бит, так же как код для соответствующих не управляющих символов.
Обычно текстовые терминалы не имеют возможности генерации
не-@acronym{ASCII} управляющих символов, но их можно
сгенерировать явно с использованием X или другой оконной системы.

  Так исторически сложилось, что Emacs рассматривает символ
@key{DEL}, как управляющий эквивалент для @kbd{?}:

@example
?\^? @result{} 127     ?\C-? @result{} 127
@end example

@noindent
В результате не возможно представить символ @kbd{Control-?},
который является значимым в X, с использованием @samp{\C-}.
И простого решения для этого нет, так как многие Lisp файлы
используют @key{DEL} в таком виде.

  Для представления управляющих символов в файлах и строках,
рекомендуется использовать @samp{^} синтаксис, для управляющих
символов клавиатурного ввода, более предпочтительным является
@samp{C-} синтаксис. Использование того или другого не влияет
на работу программы, но может облегчить понимание людям
читающим программу.

@node Meta-Char Syntax
@subsubsection Meta-Character Syntax

@cindex meta characters
  @dfn{meta символ} (@dfn{meta character}) символ введенный с использованием  мета
  @key{META} клавиши модификации (как правило зажатая ALt, или нажать и отпустить Esc).
Числа представляющие такой символ являются
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
битным множеством. Большое количество bit
используется для этого и других модификаторов
чтобы иметь возможность хранения большого
количества базовых кодов.

  В строке
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит, относятся с @acronym{ASCII} символом означающего
мета символв, то есть мета символы которые могут  подходить
содержат коды от 128 до 255, и являются мета версиями обычных
@acronym{ASCII} символов. См. @xref{Strings of Events} для
более подробного понимания обработки @key{META} в строках.

  Синтаксис чтения для мата символов использует @samp{\M-}.
Например,  @samp{?\M-A}, соответствует @kbd{M-A}. Можно использовать
@samp{\M-}  вместе с восьмеричными кодами (см. ниже), с @samp{\C-},
или любой другой записью для символов. Таким образом, можно
записать @kbd{M-A} как @samp{?\M-A}, или как @samp{?\M-\101}.
Так же можно написать: @kbd{C-M-b} как
@samp{?\M-\C-b}, @samp{?\C-\M-b}, или @samp{?\M-\002}

@node Other Char Bits
@subsubsection Другие биты модификации символов


  Регистра символов определяется его кодом, например в @acronym{ASCII}
символы @samp{a} и @samp{A} различные. Но в @acronym{ASCII} нет
способа отличить регистр управляющих символов. Emacs использует
  The case of a graphic character is indicated by its character code;
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит для индикации того, была ли нажата клавиша shift при
вводе управляющего символа. Распознавание возможно
только для X терминалов и других специализированных терминалов;
обычно текстовые терминалы не показывают разницу.
Lisp синтаксис для shift бита @samp{\S-}, то есть
@samp{?\C-\S-o} или @samp{?\C-\S-O} представляют
shifted-control-o символ.

@cindex hyper characters
@cindex super characters
@cindex alt characters
  Оконная система X определяет три другие
@anchor{modifier bits} бита модификации которые могут быть
установлены в символе @dfn{hyper}, @dfn{super} и @dfn{alt}.
Синтаксис для этих битов @samp{\H-}, @samp{\s-} и @samp{\A-}.
(Регистр в этих префиксах важен.) То есть, @samp{?\H-\M-\A-x}
представляет @kbd{Alt-Hyper-Meta-x}. (Отметим, что @samp{\s}
без @samp{-} это пробел).
@tex
В числовых значениях, биты соответствуют @math{2^{22}} для alt, @math{2^{23}}
для super и @math{2^{24}} для hyper.
@end tex
@ifnottex
В числовом виде,
значения битов 2**22 для alt, 2**23 для super и 2**24 для hyper.
@end ifnottex

@node Symbol Type
@subsection Symbol Type

  @dfn{Символ} (@dfn{symbol}) в GNU Emacs Lisp это объект с именем.
(К сожалению получается что для символов строк (буквы и т.д) и для
объектов символов, хранят значение, функцию и список свойств
используется одно слово символ. Различать их придется по контексту, в
оригинале им соответствуют: character - символ как знак, symbol -
именованный объект данных).  Имя symbol служит его печатным
представлением. Как правило в Lisp (с одним obarray (массив объектов))
(@pxref{Creating Symbols}) имя символа уникально, никакие два символа
не имеют одного имени.

 Символ может быть переменной, функцией, или хранить список свойств.
Как правило символ используется в качестве одной из этих
возможностей, но так же их можно использоваться всеми тремя способами.
То есть в одном символе может хранится и переменная и функция и список
значений, но это может запутать.

  Символ чье имя начинается с (@samp{:}), называется @dfn{ключевым
словом} @dfn{keyword symbol}. Такие символы работают как константы, и
используются для сравнения какого-то другого символа с собой.
@xref{Constant Variables}.

@cindex @samp{\} in symbols
@cindex backslash in symbols
  Имя символа может содержать любые символы. Большинство
имен символов записываются буквами, цифрами и знаками @samp{-+=*/}.
Такие имена не требуют особой пунктуации; главное чтобы они не
выглядели как числа. (Иначе стоит использовать @samp{\} в начале
имени, чтобы считыватель понял что это символ). Символы (знаки) @samp{_~!@@$%^&:<>@{@}?}
реже используются, но так же не требуют особой пунктуации. Любые
другие символы могут быть включены в имя с использование экранирования
символом обратного слеша. Например в строке @samp{\t} соответствует
символу tab; но в имени символа @samp{\t} просто экранированная
буква @samp{t}. Чтобы определить символ  с tab в имени, нужно
использовать tab с обратным слешем перед
(Видимо как-то так @samp{asdf-\  -otherpart-of-name}).
Но так обычно делать не стоит.

@cindex CL note---case of letters
@quotation
@b{Common Lisp note:} В Common Lisp, буквы в нижнем регистре всегда
приводятся к верхнему регистру, если они не явно экранированы. В Emacs
Lisp, буквы в верхнем и нижнем регистре различаются.
@end quotation

  Ниже есть несколько примеров имен символов. Отметим, что @samp{+}
в четвертом примере экранировано, чтобы не быть считанным как число.
В шестом примере это не требуется, так как оставшаяся часть имени
не соответствует числу.

@example
@group
foo                 ; @r{A symbol named @samp{foo}.}
FOO                 ; @r{A symbol named @samp{FOO}, different from @samp{foo}.}
@end group
@group
1+                  ; @r{A symbol named @samp{1+}}
                    ;   @r{(not @samp{+1}, which is an integer).}
@end group
@group
\+1                 ; @r{A symbol named @samp{+1}}
                    ;   @r{(not a very readable name).}
@end group
@group
\(*\ 1\ 2\)         ; @r{A symbol named @samp{(* 1 2)} (a worse name).}
@c the @'s in this next line use up three characters, hence the
@c apparent misalignment of the comment.
+-*/_~!@@$%^&=:<>@{@}  ; @r{A symbol named @samp{+-*/_~!@@$%^&=:<>@{@}}.}
                    ;   @r{These characters need not be escaped.}
@end group
@end example

@cindex @samp{##} read syntax
@ifinfo
@c This uses "colon" instead of a literal ':' because Info cannot
@c cope with a ':' in a menu.
@cindex @samp{#@var{colon}} read syntax
@end ifinfo
@ifnotinfo
@cindex @samp{#:} read syntax
@end ifnotinfo

  Для правила что имя символа выступает в качестве печатного представления
есть исключение, @samp{##} является печатной формой для интернированных
символов (interned symbol), имя которых пустая строка. Кроме того,
@samp{#:@var{foo}} печатное представление (uninterned symbol) неинтернированного
символа имя которого @var{foo}. (Обычно, Lisp считыватель
интернирует все символы; @pxref{Creating Symbols}.)
(Что такое интернированный символ будет описано далее).

@node Sequence Type
@subsection Sequence Types

  Последовательность является Lisp объектом который представляет упорядоченное
множество элементов. В Emacs Lisp есть 2 вида последовательностей
@dfn{списки} и @dfn{массивы}  (@dfn{lists} и @dfn{arrays}).

  Списки наиболее часто используемые последовательности. Списки
могут хранить элементы любого типа, и их длина может быть легко
изменена путем добавления и удаления элементов. См. следующую
подсекцию для более подробной информации о списках.

  Массивы последовательности фиксированной длины. Массивы дополнительно
подразделяются на строки, векторы, таблицы-символов(знаков, char-tables) и
двоичные вектора (bool-vector). Вектора могут хранить элементы любого типа, тогда
как элементы строк должны быть символами(знаками), и элементы двоичных
векторов должны быть @code{t} или @code{nil}. Таблицы символов аналогичны
векторам, но индексами в них являются корректные коды символов.
Символы в строке могут иметь текстовые свойства как символы(знаки)
в буфере (@pxref{Text Properties}), но вектора не поддерживают
текстовых свойств, даже когда их элементы символы(знаки).

  Списки, строки и другие типы массивов имеют много общего.
Например, все имеют длину @var{l}, и все имеют элементы,
которые могут быть доступны по индексу от 0 до @var{l} - 1.
Некоторые функции, называемые функциями последовательностей, принимают
любые виды последовательностей. Например, функция @code{length}
сообщает длину последовательности любого типа.
@xref{Sequences Arrays Vectors}.

  В общем не возможно считать одну и туже последовательность дважды,
так как последовательности создаются заново при чтении. Если считать
синтаксис чтения для последовательности дважды, будет получено
две последовательности с одинаковым содержимым.
Единственное исключение: пустой список @code{()} это всегда один и тот
же объект, @code{nil}.

@node Cons Cell Type
@subsection Cons Cell and List Types
@cindex address field of register
@cindex decrement field of register
@cindex pointers

  @dfn{cons ячейка} (@dfn{cons cell}) это объект состоящий из 2-x слотов,
называемых @sc{car} слот и @sc{cdr} слот. Каждый слот может хранить
любой Lisp объект. В дальнейшем будем говорить, что @sc{car}
cons ячейки то, что хранится в  @sc{car} слота, и аналогично @sc{cdr}.

@cindex list structure
  структура списка.
  @dfn{Список} (@dfn{list}) это ряд cons ячеек, связанных вместе,
так что @sc{cdr} слот каждой ячейки хранит следующую cons ячейку или
пустой список. Пустой список и символ @code{nil} это одно и тоже.
См. @xref{Lists}, для более детальной информации. Так как большинство
cons ячеек используется для создания списков, любая структура
состоящая из cons ячеек будет называться @dfn{list структурой}
(@dfn{list structure}).

@cindex linked list
@quotation
Примечание для C программистов: Lisp список который работает
@dfn{связанный list} состоит из cons ячеек. Так как указатели
в Lisp не явные, нет возможности отличить ячейку со значением
от ячейки хранящей ссылку на значение.
@end quotation

@cindex atoms
  Так как cons ячейки являются центральным понятием в Lisp, есть
специальный термин для объектов не являющихся cons ячейками. Такие
объекты называются @dfn{атомы} (@dfn{atoms}).

@cindex parenthesis
@cindex @samp{(@dots{})} in lists
  Синтаксис чтения и печатная форма для списков идентичны, и состоят
из левой круглой скобки, произвольного количества элементов, и
правой круглой скобки. Ниже примеры списков:

@example
(A 2 "A")            ; @r{A список из 3-х элементов.}
()                   ; @r{A список без элементов (пустой)).}
nil                  ; @r{A список без элементов (пустой)). }
("A ()")             ; @r{A список с одним элементом: строкой @code{"A ()"}.}
(A ())               ; @r{A список из 2-х элементов: @code{A} пустой список.}
(A nil)              ; @r{Эквивалентно предыдущему.}
((A B C))            ; @r{A Список из одного элемента}
                     ;   @r{(который является списком из 3-х элементов).}
@end example

   Вместо чтения, каждый объект в скобках становится элементом
списка. То есть, cons ячейка создается для каждого элемента. @sc{car}
ячейка слота cons ячейки хранит элемент, и @sc{cdr} хранит ссылку
на следующую cons ячейку списка, которая хранит следующий
элемент списка. @sc{cdr} слот крайней ячейки списка устанавливается
в @code{nil}.

  Имена @sc{car} и @sc{cdr} определены исторически (происходят из истории Lisp).
Оригинальная Lisp реализация работала на @w{IBM 704} компьютере
который разделял слово на 2 части, адреса и декремент,
@sc{car} был инструкцией для получения адреса и @sc{cdr} был
инструкцией для получения декремента. А @code{cons} функция создающая
их.

@menu
* Box Diagrams::                Изображения показывающие устройство списков.
* Dotted Pair Notation::        Синтаксис cons ячеек.
* Association List Type::       Специальный ассоциативный список.
@end menu

@node Box Diagrams
@subsubsection Drawing Lists as Box Diagrams
@cindex box diagrams, for lists
@cindex diagrams, boxed, for lists

  Список может быть представлен на схеме где cons ячейки
показываются как пара соединенных ящиков, как костяшки домино.
(Lisp не может считывать такие представления, это должно быть очевидно.
Хотя можно написать программу и научить его.)
Изображение ниже представляет список состоящий из 3-х элементов
@code{(rose violet buttercup)}:

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example

  На этой диаграмме, каждый ящик представляет слот, который хранит значение
или ссылку на любой Lisp объект. Каждая пара ящиков представляет cons ячейку.
Каждая стрелочка представляет ссылку на Lisp объект, либо атом или
другую cons ячейку.

  В данном примере, первый ящик @sc{car} первой cons ячейки
ссылается или хранит @code{rose} (символ). Второй ящик, хранит @sc{cdr}
первой cons ячейки ссылается на следующую пару ящиков, которая
представляет вторую cons ячейку. @sc{car} второй cons ячейки
@code{violet}, и @sc{cdr} второй cons ячейки это третья cons ячейка.
@sc{cdr} третьей cons ячейки (крайняя) @code{nil}.

 Ниже другое представление того же списка, @code{(rose violet
buttercup)}, нарисованная по другому:

@smallexample
@group
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
@end group
@end smallexample

@cindex @code{nil} as a list
@cindex empty list
  Список без элементов @dfn{пустой список}  (@dfn{empty list}) идентичен
символ @code{nil}. Другими словами, @code{nil} является и символом и списком.

  Ниже список @code{(A ())}, или эквивалентная запись @code{(A nil)},
изображен в виде коробок:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil
@end group
@end example

  А тут более сложный пример, показывающий трех-элементный список,
@code{((pine needles) oak maple)}, первый элемент которого является
двух-элементным списком.

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> oak      --> maple
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> pine     --> needles
@end group
@end example

  Тот же список представленный другим способом коробочной нотации:

@example
@group
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| oak   |   o------->| maple |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| pine  |   o------->| needles |  nil |
            |       |      |     |         |      |
             --------------       ----------------
@end group
@end example

@node Dotted Pair Notation
@subsubsection Dotted Pair Notation
@cindex dotted pair notation
@cindex @samp{.} in lists

  @dfn{Точечная пара}(@dfn{Dotted pair notation}) это стандартная
запись cons ячейки которая в явном виде указывает @sc{car} и @sc{cdr}
ячейки.  В этой записи, @code{(@var{a} .@: @var{b})}, @sc{car} это
@var{a}, а @sc{cdr} это @var{b}. Точеная пара является более общим
способом записи чем список, потому что @sc{cdr} в паре не обязано быть
списком. Но, такая запись является более громоздкой (и менее удобной),
для случаев где работает списочная запись. В записи с точечными парами
список @samp{(1 2 3)} будет выглядеть как @samp{(1 .  (2 . (3
. nil)))}.  Для списков заканчивающихся @code{nil}, можно использовать
обе записи, но списочная запись более удобная.  При печати списка,
запись в виде точечной пары используется только, если @sc{cdr} cons
ячейки не список.

  Ниже пример иллюстрирующий точечную запись @code{(rose . violet)}:

@example
@group
    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose
@end group
@end example

  Можно объединить точечную запись и списочную запись и сделать
у крайней ячейки списка не-@code{nil} @sc{cdr} слот. Для этого
нужно написать через точку Крайний элемент списка. Например:
@code{(rose violet . buttercup)}, что эквивалентно
@code{(rose . (violet . buttercup))}.

Такая последовательность может быть представлена
следующим образом:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

  Запись @code{(rose .@: violet .@: buttercup)} не верная, потому
что в не говорится поместить @code{buttercup} в @sc{cdr} cons ячейки
чей @sc{cdr} уже используется для хранения @code{violet}.

  Список @code{(rose violet)} эквивалентный @code{(rose . (violet))},
может быть представлен:

@example
@group
    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet
@end group
@end example

  Аналогично трех-элементный список, эквивалентный
@code{(rose . (violet . (buttercup)))}, может быть изображен
так:
@ifnottex

@example
@group
    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example
@end ifnottex

@node Association List Type
@subsubsection Association List Type

  @dfn{Ассоциативный список} (@dfn{association list}) или @dfn{alist}
специальный список элементами которого являются cons ячейки. В каждом
элемента @sc{car} рассматривается как  @dfn{ключ} (@dfn{key}), а
@sc{cdr} как @dfn{ассоциированное значение} (@dfn{associated value}).
(В некоторых случаях, ассоциированное значение записывается в
@sc{car} слота @sc{cdr}.) Ассоциативный список часто используется
как стек, так как добавление и удаление ассоциации в начале
списка просто выполнить.

  Например,

@example
(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
@end example

@noindent
устанавливает значением переменной @code{alist-of-colors} ассоциативный
список из трех элементов. В первом элементе @code{rose} это ключ, я
@code{red} значение.

  См. @xref{Association Lists}, для более детальной информации по alists
и функциям для работы с ними.  См. @xref{Hash Tables}, для получения
информации по другому виду таблиц поиска, которые более быстры для
случаев с большим количеством ключей.

@node Array Type
@subsection Array Type

  @dfn{Массив} (@dfn{array}) состоит из произвольного количества слотов
для хранения или хранения ссылок на другие Lisp объекты, расположенных
в памяти непрерывно. Доступ к любому элементу массива требует примерно
одного и того же времени. В отличие, от списков, где
требуемое время пропорционально позиции элемента в списке.
(Для доступа к элементам в конце списка нужно больше времени,
чем к элементам в начале.)

  Emacs определяет четыре типа массивов: strings, vectors, bool-vectors, и
char-tables.

  Строка это массив символов(знаков) и вектор это массив
произвольных объектов. bool-vector (двоичный-вектор) может хранить только
@code{t} или @code{nil}. Такие массивы могут быть любой размер
до значения максимального целого. Char-tables (символьные таблицы)
это разряженные массивы, с доступом по любому корректному коду
символа; они так же могут хранить произвольные объекты.

  Первый элемент массива имеет индекс 0, второй 1, и т.д.
Такая нумерация называется (индексация начинающаяся с 0)@dfn{zero-origin} индексация.
Например, массив из 4 элементов имеет индексы 0, 1, 2, @w{и 3}.
Максимальный индекс на 1 меньше длины массива. После того как массив
создан его размен не меняется.

  Все Emacs Lisp массивы одна-размерные. (Большинство других
языков программирования поддерживают много-мерные массивы, но они
не являются необходимыми; их можно эмулировать используя
в качестве элементов массивов другие массивы.) Каждый тип массивов
имеет свой синтаксис считывания; они будут описаны в следующей
секции.

  Тип массивов является подтипом типа последовательной, и содержат
строковый тип(string type), векторный тип(the vector type), тип двоичных
векторов (the bool-vector type), и тип символьных таблиц (the char-table
type).

@node String Type
@subsection String Type

  @dfn{Строка} (@dfn{string}) это массив символов(знаков). Строки
много где используются, что ожидаемо для текстового редактора; например,
как имена символов Lisp, сообщения пользователю, и представления
текста буфера. Строки в Lisp являются константами: вычислению
строки возвращает саму строку.

  См. @xref{Strings and Characters}, для более
детальной информации по функциям работы со строками.

@menu
* Syntax for Strings::      Задание строк в Lisp.
* Non-ASCII in Strings::    Международные символы в строках.
* Nonprinting Characters::  Непечатаемые символы в строках.
* Text Props and Strings::  Строки с текстовыми свойствами.
@end menu

@node Syntax for Strings
@subsubsection Syntax for Strings
Синтаксис строк.

@cindex @samp{"} in strings
@cindex double-quote in strings
@cindex @samp{\} in strings
@cindex backslash in strings
  Строки записываются как двойная кавычка, произвольное
количество символов(знаков), и другая двойная кавычка,
@code{"вот так"}(@code{"like this"}). Для
включения двойной кавычки в строку, нужно перед ней поставить
обратный слеш; т.е. @code{"\""} это строка состоящая из 1
двойной кавычки. Аналогично обратный слеш
можно включить поставив перед ним обратный слеш,
например @code{"это \\ один обратный слеш в строке"}.

@cindex newline in strings
  Перевод строки в строках. Символ перевода строки не является
специальным; если ввести перевод строки между двойными
кавычками, он будет являться частью строки. Но экранированный
перевод строки с обратным слешем, не будет частью строки,
т.е. считыватель Lisp игнорирует экранированные
переводы строк при считывании. Экранированный пробел @w{@samp{\ }} так же
игнорируется.

@example
"Это пример полезного включения перевода
строки в документации, но
перевод строки \
игнорируется если экранировано."
     @result{} "Это пример полезного включения перевода
строки в документации, но
перевод строки игнорируется если экранировано."
@end example

@node Non-ASCII in Strings
@subsubsection Non-@acronym{ASCII} Characters in Strings
  Не-@acronym{ASCII} символы(знаки) в строках.

  Есть два текстовых представления не-@acronym{ASCII}
символов в строках Emacs: много байтное и однобайтное
(@pxref{Text Representations}). Грубо говоря, однобайтовые строки
хранят просто байты, в то время как мультибайтовые строки
хранят человеко-читаемый текст. Каждый знак в однобайтовой строки
это байт, т.е., это значение между 0 и 255. В то время как,
каждый знак в многобайтовой строке может быть
значением от 0 до 4194303 (@pxref{Character Type}).
В обоих случаях символы больше 127 не-@acronym{ASCII}.

  Можно включить не-@acronym{ASCII} символ в строковую
константу прямо включив его в строку. Если строковая константа
считывается из много-байтового исходника, такого как
много-байтовый буфер или строка, или файл
который открывается как много-байтовый, тогда Emacs
считывает каждый не-@acronym{ASCII} символ(знак), как
много-байтовый символ(знак) и автоматически превращает
строку в много-байтовую. Если строковая константа
считывается из одно-байтового исходника, то Emacs считывает
не-@acronym{ASCII} символы(знаки) как одно-байтовые, и
считанная строка будет одно-байтовой.

  Вместо непосредственной записи символа(знака) в строку,
можно писать код символ используя escape(экранированные)
последовательности. См. @xref{General Escape Syntax} для
более детальной информации по escape(экранированным) последовательностям.

  Если использовать Unicode escape последовательности
@samp{\uNNNN} или @samp{\U00NNNNNN} в строковых константах
(даже для @acronym{ASCII} символов(знаков)), Emacs будет
рассматривать строку как много-байтовую.

  Так же можно использовать шестнадцатеричные(@samp{\x@var{n}}) и
восьмеричные (@samp{\@var{n}}) escape последовательности в строковых
константах. @strong{Но стоит учитывать:} если
в строке есть шестнадцатеричные и восьмеричные escape последовательности,
определяющие одно-байтовые знаки (код до 256), и нет Unicode
и не-@acronym{ASCII} символов(знаков), тогда Emacs будет рассматривать
строку как одно-байтовую. То есть, все не-@acronym{ASCII} символы
в строки будут рассматриваться как 8-битные чистые (raw, сырые) байты.

  В шестнадцатеричных или восьмеричных escape последовательностях,
escape символ(знак) может содержать произвольное количество
цифр, при этом первый символ который не является корректной
восьмеричной или шестнадцатеричной цифрой завершает escape последовательность.
Если символ после escape последовательности может быть интерпретирован
как шестнадцатеричная или восьмеричная цифра, стоит написать
@w{@samp{\ }} (обратный слеш и пробел), для завершения escape последовательности.
Например, @w{@samp{\xe0\ }} это один символ @samp{a}, с ударением.
@w{@samp{\ }} в строке игнорируется как и если бы это был экранированный
перевод строки, он нужен только для завершения шестнадцатеричной
escape последовательности.

@node Nonprinting Characters
@subsubsection Nonprinting Characters in Strings

  Не печатные символы в строках.

  Можно использовать те же последовательности начинающиеся с обратного
слеша в строковых константах, что и использовались для определения
символов(знаков) (но без знака вопроса в начале). Например,
можно создать строку содержащую не печатаемые символы tab и @kbd{C-a}
с запятой и пробелом между ними, таким образом: @code{"\t, \C-a"}.
Информация по синтаксису чтения символов(знаков) @xref{Character Type}.

  Но, не все символы(знаки) которые могут быть записаны с использованием
обратного слеша корректно использовать в строках. Строки могут
хранить только управляющие символы для @acronym{ASCII}. Строки
не различают регистр в @acronym{ASCII} управляющих символах.

  Строго говоря, строки не могут хранить мета символы, но когда строка
используется как последовательность клавиш, есть соглашение
по представлению meta версий символов @acronym{ASCII} в строке.
Если использовать @samp{\M-} синтаксис для указания, что это
мета символ(знак) в строковой константе, будет установлен
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит символа(знака) в строке. Если строка используется
в @code{define-key} или @code{lookup-key}, такой код будет
преобразован в эквивалентный meta символ. @xref{Character Type}.

  Строки не могут хранить символы, которые имеют hyper, super, или alt
модификаторы.

@node Text Props and Strings
@subsubsection Text Properties in Strings
Тестовые свойства в строках.

@cindex @samp{#(} read syntax
@cindex text properties, read syntax
  Строки могут хранить свойства для символов из которых они состоят,
кроме непосредственно самих символов. Это позволяет программам, которые
копируют текст между строками и буферами копировать тестовые свойства
без дополнительных действий. @xref{Text Properties} содержит информацию
по тому, что представляют собой свойства текста. Строки с текстовыми
свойствами используют специальный синтаксис чтения и печати:

@example
#("@var{characters}" @var{property-data}...)
@end example

@noindent
где @var{property-data} состоит из 0 или более элементов, сгруппированным
по трое:

@example
@var{beg} @var{end} @var{plist}
@end example

@noindent
Элементы @var{beg} и @var{end} целые числа, и вместе определяют
диапазон индексов строки, @var{plist} список свойств для заданного
диапазона. Например,

@example
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
@end example

@noindent
представляет строку, содержащую @samp{foo bar}, в которой первые
3 символа имеют шрифт(@code{face}) свойство со значением @code{bold},
и три крайних символа шрифт @code{italic}. (Четвертый символ не имеет свойств.
Устанавливать свойство для интервала 3,4 не обязательно, так как если
символы не входят ни в какой интервал со свойствами, они по умолчанию
не будут иметь свойств, т.е. можно было бы написать так:

@example
#("foo bar" 0 3 (face bold) 4 7 (face italic))
@end example

)

@node Vector Type
@subsection Vector Type

  @dfn{Вектор} (@dfn{vector}) это одномерный массив элементов произвольного
типа. Доступ к любому элементу вектора выполняется за константное время.
(В списке, время доступа к элементу пропорционально положению элемента
от начала списка.)

    Печатная форма вектора состоит из левой квадратной скобки, элементов
и правой квадратной скобки. Такая форма так же является синтаксисом чтения.
Как числа и строки, вектора рассматриваются как константы при вычислении.
(не до конца понятно что подразумевается под константами).

@example
[1 "two" (three)]      ; @r{A vector of three elements.}
     @result{} [1 "two" (three)]
@end example

  См. @xref{Vectors}, по функциям работы с векторами.

@node Char-Table Type
@subsection Char-Table Type

  @dfn{Символьная-таблица} (@dfn{char-table}) представляет собой
одномерный массив элементов произвольного типа, с доступом по коду
символа. Символьные-таблицы имеют ряд возможностей, делающих
их удобными для многих задач которые включают присваивание информации
кодам символов(знаков) -- например, символьные таблицы могут иметь
родителя и наследовать его свойства, значение по умолчанию, небольшое
количество дополнительных слотов для использования специальным образом.
Символьные таблицы могут определять одного значение для целого множества
символов(знаков).

@cindex @samp{#^} read syntax
  Печатная форма символьной-таблицы, как и вектор ожидает
@samp{#^} в начале.@footnote{Можно встретить  @samp{#^^},
используемые для вложенных символьных таблиц (sub-char-tables).}

  См. @xref{Char-Tables}, по функциям работы с символьными таблицами.
Использование символьных таблиц включает:

@itemize @bullet
@item
Case tables (@pxref{Case Tables}).

@item
Таблицы категорий (Character category tables) (@pxref{Categories}).

@item
Display tables (@pxref{Display Tables}).

@item
Таблицы синтаксиса (синтаксические таблицы) (@pxref{Syntax Tables}).
@end itemize

@node Bool-Vector Type
@subsection Bool-Vector Type

  @dfn{Двоичный-вектор} (@dfn{bool-vector}) это одномерный массив, элементы
которого @code{t} или @code{nil}. Печатное представление двоичного вектора
выглядит как строка, за исключением того, что начинается с @samp{#&},
за которым следует длина. Строковые константы, которые

  The printed representation of a bool-vector is like a string, except
that it begins with @samp{#&} followed by the length. Строковая константа
следующая за длиной определяет содержимое двоичного вектора как битовая маска---
каждый символ в строке состоит из 8 бит, который определяет следующие
8 элементов двоичного вектора (1 соответствует @code{t} и 0 @code{nil}).
Самый меньший бит символа, соответствует самому маленькому индексу двоичного
вектора.

@example
(make-bool-vector 3 t)
     @result{} #&3"^G"
(make-bool-vector 3 nil)
     @result{} #&3"^@@"
@end example

@noindent
Такой результат, получается, потому что двоичный код @samp{C-g} равен 111
и @samp{C-@@} это символ с кодом 0.

  Если длина не степень 8, печатается представление, как если бы недостающие
значение были nil. Например, в следующем примере, двоичные вектора
эквивалентны, так как значимы только первые 3 бита:

@example
(equal #&3"\377" #&3"\007")
     @result{} t
@end example

@node Hash Table Type
@subsection Hash Table Type

    Хеш таблица это вид быстрых таблиц поиска, они похожи на alist
в том что ставят в соответствие ключей и значений, но более быстрые.
Печатное представление хеш таблицы определяет свойства и значения,
как на примере:

@example
(make-hash-table)
     @result{} #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8 data ())
@end example

@noindent
См. @xref{Hash Tables}, для более подробной информации по хеш таблицам.

@node Function Type
@subsection Function Type

  Lisp функции это выполняемый код, как функции в других языках
программирования. В Lisp, в отличие от большинства языков, функции
тоже являются Lisp объектами. Не-скомпилированные функции в
Lisp это lambda выражения, которые являются списками, в которых
первый элемент символ @code{lambda} (@pxref{Lambda Expressions}).

  В большинстве языков программирования, не может быть
безымянных функций (прим. на данный момент в большинстве языков
есть безымянные функции). В Lisp, функция имеет внутренне имя. Lambda
выражение может быть вызвано как функция даже если у него нет имени.
Чтобы это отметить, такие функции будем называть @dfn{анонимные функции}
(@dfn{anonymous function}) (@pxref{Anonymous Functions}). Именованные
функции в Lisp это символы(объекты) у которых в ячейке функции
хранится корректная функция (@pxref{Defining Functions}).

  Как правило, функции вызываются по имени в выражениях Lisp
программ. Но, можно создать функции во время работы программы и вызвать
ее с помощью функций @code{funcall} или @code{apply}. @xref{Calling Functions}.

@node Macro Type
@subsection Macro Type

  @dfn{Lisp макрос} (@dfn{Lisp macro}) это определенный пользователем
конструкт, который расширяет язык Lisp. Макрос представляется объектом
похожим на функцию, но имеют другую семантику передачи и обработки
аргументов. Lisp макрос представляется как список первый элемент
которого символ @code{macro} и чей @sc{cdr} функция Lisp,
включающий @code{lambda} символ.

  Lisp макрос как правило определяется с использованием
встроенного макроса @code{defmacro}, но в целом любой
список начинающийся с @code{macro}, если он имеет отношение к Emacs.
См. @xref{Macros} чтобы научится писать макросы.

  @strong{Предупреждение}: Lisp макросы и клавиатурные макросы
(@pxref{Keyboard Macros}) совершенно разные вещи. Далее если говорится
``macro''(``макрос) без уточнений, будет подразумеваться
Lisp макрос, а не клавиатурный макрос.

@node Primitive Function Type
@subsection Primitive Function Type
@cindex primitive function

  @dfn{Базовая функция} (@dfn{primitive function}) это функция,
которая может вызываться из Lisp, но написанная на C. Базовые функции
так же называются @dfn{subrs} или @dfn{встроенные функции} (@dfn{built-in functions}).
(``subr'' сокращение от ``subrouting''). Большинство базовых функций
которые не вычисляются все свои аргументы называются @dfn{специальными формами}
(@dfn{special form}) (@pxref{Special Forms}).

  Для вызывающего кода нет разницы вызывает он функцию или базовую
функцию. Но, при попытке переопределить базовую функцию, функцией
написанной на Lisp они будут вести себя по разному. Так как базовая
функция может быть вызвана напрямую из C кода. Вызов переопределенной
функции из Lip будет использовать новое определение, но вызовы из
C кода будут использовать базовое определение. Поэтому,
@strong{не рекомендуется переопределять базовые функции}.


   Термин @dfn{function} относится ко всем функциям, написанным на Lisp
или C@. См. @xref{Function Type}, для получения информации по функциям,
написанным на Lisp.

  Базовые функции не имеют синтаксиса считывания и печатаются в
хеш нотации с именем подпрограммы.

@example
@group
(symbol-function 'car)          ; @r{Доступ к ячейки функции}
                                ;   @r{символа.}
     @result{} #<subr car>
(subrp (symbol-function 'car))  ; @r{Является ли это примитивной функций?}
     @result{} t                       ; @r{Да.}
@end group
@end example

@node Byte-Code Type
@subsection Byte-Code Function Type

@dfn{Функции объекты в байт-коде} (@dfn{Byte-code function objects})
получаются при байт-компиляции Lisp кода (@pxref{Byte Compilation}).
Внутренне, функции в байт-коде похожи на вектор, но, вычислитель (evaluator)
обрабатывает этот тип данных особым образом когда
он появляется в вызове функции. @xref{Byte-Code Objects}.

Печатная форма и синтаксис считывания для функций в байт-коде
как у вектора, но с добавлением @samp{#} перед @samp{[}.

@node Autoload Type
@subsection Autoload Type

  @dfn{Автоматически загружаемый объект} (@dfn{autoload object}) это
список первый элемент в котором символ @code{autoload}. Такой объект
хранится как определение функции в символе, но при этом является
указателем на настоящее определение. Автоматически загружаемый объект
указывает, что настоящее определение можно найти в файле
Lisp кода который должен быть загружен при необходимости. Объект
хранит имя файла и некоторую другую информацию о настоящем определении.

  После того, как файл будет загружен, функция в символе будет
переопределена, и больше не должна быть авто-загружаемым объектом.
Настоящее определение будет вызвано как будто оно и хранилось
вместо авто-загружаемого объекта. С точки зрения пользователя, будет
вызвана ожидаемая функция, из загруженного файла. (Прим. По большей
части такие объекты нужны для того, чтобы не загружать
часть кода сразу, а выполнять загрузку по мере необходимости.)

  Авто-загружаемый объект как правило создается функцией
@code{autoload}, которая загружает объект в ячейку функции
символа (объекта). Более подробно см. @xref{Autoload}.

@node Finalizer Type
@subsection Finalizer Type

  @dfn{Объект для сборки мусора(метод завершения, финализатор)}
@dfn{finalizer object} помогает Lisp выполнить
очистку больше не нужных объектов. Финализатор хранит объект функцию.
Когда финализатор становится недоступен после выполнения
сборки мусора, Emacs вызывает функцию связанную с финализатором.
Когда Emacs определяет доступность финализатора, он не учитывает
ссылки из объекта финализатора на себя, позволяя использовать
финализатор не беспокоясь о захвате ссылок на очищаемые объекты.

Ошибки в финализаторах печатаются в буфер @code{*Messages*}. Еmacs
запускает функцию финализатора только один раз, даже если
произошла ошибка.

@defun make-finalizer function
Создает финализатор, который запустит функцию @var{function}.
Функция будет вызвана после уборки мусора при которой полученный
в результате вызова финализатор(объект для сборки мусора) будет
недоступен. Если финализатор доступен только через объекта
финализатора, он не считается доступным. @var{function}
будет запущена один раз для каждого финализатора.

(В оригинале написано, что в этом случае финализатор
не доступен для решения нужно ли запускать функцию
If the finalizer object is reachable only
through references from finalizer objects, it does not count as
reachable for the purpose of deciding whether to run @var{function}.
@var{function} will be run once per finalizer object.)
@end defun

@node Editing Types
@section Editing Types
@cindex editing types

  Типы в предыдущих секциях в основном используются при программировании,
и большинство из них присутствуют в большинстве диалектов Lisp. Emacs
Lisp предоставляет дополнительные типы данных связанные с задачами
редактирования.

@menu
* Buffer Type::         Базовый объект редактирования.
* Marker Type::         Позиция в буфере.
* Window Type::         Буферы отображаются в окнах.
* Frame Type::          Типы фреймов.
* Terminal Type::       Терминал на котором отображаются фреймы.
* Window Configuration Type::   Сохранение разделения фрейма на окна.
* Frame Configuration Type::    Сохранение информации по всем фреймам.
* Process Type::        Под-процесс Emacs запущенный в основной ОС.
* Stream Type::         Получение и отправка символов(знаков).
* Keymap Type::         Привязка функций к комбинациям клавиш.
* Overlay Type::        Отображение оверлея.
* Font Type::           Шрифты отображаемого текста.
@end menu

@node Buffer Type
@subsection Buffer Type

  @dnf{Буфер} (@dfn{buffer}) это объект, который хранит текст
для редактирования (@pxref{Buffers}). Большинство хранят содержимое
файлов на диске (@pxref{Files}) и могут редактироваться, но
некоторые используется для других целей. Большинство буферов предназначены
для просмотра пользователем, и могут быть отображены в окне (@pxref{Windows}).
Но буфер не обязан отображаться в каком-то окне (то есть может быть не видим).
Каждый буфер имеет определенную(заданную) позицию называемую
@dfn{точка}(курсор, @dfn{point}) (@pxref{Positions}), и большинство
команд выполняемых с содержимым текущего буфера выполняется
над текстом около точки. Всегда, один из буферов является @dfn{текущим}
(@dfn{current buffer}).

@c   A @dfn{buffer} is an object that holds text that can be edited
@c (@pxref{Buffers}).  Most buffers hold the contents of a disk file
@c (@pxref{Files}) so they can be edited, but some are used for other
@c purposes.  Most buffers are also meant to be seen by the user, and
@c therefore displayed, at some time, in a window (@pxref{Windows}).  But
@c a buffer need not be displayed in any window.  Each buffer has a
@c designated position called @dfn{point} (@pxref{Positions}); most
@c editing commands act on the contents of the current buffer in the
@c neighborhood of point.  At any time, one buffer is the @dfn{current
@c buffer}.

  Содержимое буфера очень похоже на строку, но буферы не используются
как строки в Emacs, с ними выполняются другие действия. Например, можно
быстро вставить текст в существующих буфер, изменить содержимое
буфера, в то время как вставка текст в строку требует объединения
строк, и в результате получается другая строка.

@c   The contents of a buffer are much like a string, but buffers are not
@c used like strings in Emacs Lisp, and the available operations are
@c different.  For example, you can insert text efficiently into an
@c existing buffer, altering the buffer's contents, whereas inserting
@c text into a string requires concatenating substrings, and the result
@c is an entirely new string object.

  Многие стандартные функции Emacs управляют или выполняют проверки
с символами(знаками) в текущем буфере; в данном руководстве им
посвящена отдельная глава. (@pxref{Text})

@c   Many of the standard Emacs functions manipulate or test the
@c characters in the current buffer; a whole chapter in this manual is
@c devoted to describing these functions (@pxref{Text}).

  Ряд других структур данных связаны с каждым буфером:

  @c Several other data structures are associated with each buffer:

@itemize @bullet
@item
локальная синтаксическая таблица (@pxref{Syntax Tables});

@item
локальная таблица привязки клавиатурным комбинаций (@pxref{Keymaps}); и,

@item
список с локальными для буфера переменными (@pxref{Buffer-Local Variables}).

@item
оверлей (@pxref{Overlays}).

@item
текстовые свойства для буфера (@pxref{Text Properties}).
@end itemize

@noindent
Локальная раскладка (конфигурация сочетаний клавиш) и список
локальных переменных содержат записи, которые независимо
переопределяют глобальные сочетания или значения переменных.
Такая возможность используется для настройки поведения программ
в разных буферах, без изменения самих программ.

@c The local keymap and variable list contain entries that individually
@c override global bindings or values.  These are used to customize the
@c behavior of programs in different buffers, without actually changing the
@c programs.

  Буфер может быть @dfn{дополнительным} (@dfn{indirect}), что означает,
что он разделяет текст с другим буфером, но отображает его по другому.
@xref{Indirect Buffers}.

@c   A buffer may be @dfn{indirect}, which means it shares the text
@c of another buffer, but presents it differently.  @xref{Indirect Buffers}.

  Буферы не имеют синтаксиса чтения, печатная форма буфера показывает
имя буфера и записывается в хеш нотации.

@c   Buffers have no read syntax.  They print in hash notation, showing the
@c buffer name.

@example
@group
(current-buffer)
     @result{} #<buffer objects.texi>
@end group
@end example

@node Marker Type
@subsection Marker Type

  @dfn{Маркер} (@dfn{marker}) помечает позицию в буфере. Маркеры
состоят из двух компонентов, один для хранения буфера и один для
хранения позиции. Изменения в тексте буфера автоматически изменяют
позицию маркера, чтобы обеспечить указывание маркера на позицию
между одними и тебе же символами.

@c   A @dfn{marker} denotes a position in a specific buffer.  Markers
@c therefore have two components: one for the buffer, and one for the
@c position.  Changes in the buffer's text automatically relocate the
@c position value as necessary to ensure that the marker always points
@c between the same two characters in the buffer.

  Маркеры не имеют синтаксиса чтения. Они печатаются в хеш нотации,
показывающей позицию и имя буфера.

@c   Markers have no read syntax.  They print in hash notation, giving the
@c current character position and the name of the buffer.

@example
@group
(point-marker)
     @result{} #<marker at 10779 in objects.texi>
@end group
@end example

См. @xref{Markers}, для получения дополнительной информации, по тому
как проверять, создавать, копировать и перемещать маркеры.

@c @xref{Markers}, for information on how to test, create, copy, and move
@c markers.

@node Window Type
@subsection Window Type

  @dfn{Окно}(@dfn{window}) область экрана которую Emacs использует
для отображения буфера. Каждое окно имеет один связанный буфер, содержимое
которого отображается в окне. Для сравнения, буфер может отображаться
в одном окне, ни в одном окне, или нескольких окнах.

@c   A @dfn{window} describes the portion of the terminal screen that Emacs
@c uses to display a buffer.  Every window has one associated buffer, whose
@c contents appear in the window.  By contrast, a given buffer may appear
@c in one window, no window, or several windows.

  Хотя множество окон может существовать одновременно, всегда
только одно окно обозначается @dfn{активным окном} (@dfn{selected window}).
Обычно это окно в котором отображается курсор, если Emacs готов
выполнять команды (прим. видимо, а не находится в ожидании).
Активное окно обычно отображает текущий буфера (@pxref{Current
Buffer}), но это не обязательно так.

@c   Though many windows may exist simultaneously, at any time one window
@c is designated the @dfn{selected window}.  This is the window where the
@c cursor is (usually) displayed when Emacs is ready for a command.  The
@c selected window usually displays the current buffer (@pxref{Current
@c Buffer}), but this is not necessarily the case.

  Окна сгруппированы на экране во фреймы (фрейм как правило соответствует
окну X-window, а окно, соответствует прямоугольной области с текстом внутри
X-window, которых в одном X-window окне может бтыь несколько). Каждое
окно относится только к 1 фрейму. @xref{Frame Type}.

@c   Windows are grouped on the screen into frames; each window belongs to
@c one and only one frame.  @xref{Frame Type}.

  Окна не имеют синтаксиса чтения. Они печатаются в хеш нотации,
в которой отображается номер окна, и имя отображаемого буфера.
Номер окна позволяет уникально идентифицировать окно, так как
буферы отображаемые к заданном окне могут часто меняться.

@c   Windows have no read syntax.  They print in hash notation, giving the
@c window number and the name of the buffer being displayed.  The window
@c numbers exist to identify windows uniquely, since the buffer displayed
@c in any given window can change frequently.

@example
@group
(selected-window)
     @result{} #<window 1 on objects.texi>
@end group
@end example

  См. @xref{Windows}, для получения более подробной информации по
функция работы с окнами.

@node Frame Type
@subsection Frame Type

  @dfn{Фрейм}(@dfn{frame}) это область экрана, которая хранит
одно или более окон Emacs.  Термин ``фрейм''(``frame'') так же используется
для обозначения Lisp объекта, который Emacs использует
чтобы ссылаться на эту область экрана.
(Прим. по сути frame это окно X-window или рабочая зона в
терминале, в этом случае как правило возможен
только один фрейм.)

@c   A @dfn{frame} is a screen area that contains one or more Emacs
@c windows; we also use the term ``frame'' to refer to the Lisp object
@c that Emacs uses to refer to the screen area.

  Фреймы не имеют синтаксиса чтение. Они печатаются в хеш нотации,
в которой выводится заголовок (title) фрейма, его адрес в ядре
(что полезно для уникальной идентификации фрейма).

@c   Frames have no read syntax.  They print in hash notation, giving the
@c frame's title, plus its address in core (useful to identify the frame
@c uniquely).

@example
@group
(selected-frame)
     @result{} #<frame emacs@@psilocin.gnu.org 0xdac80>
@end group
@end example

  См. @xref{Frames}, для получения информации по функциям работы с фреймами.

@c @xref{Frames}, for a description of the functions that work on frames.

@node Terminal Type
@subsection Terminal Type
@cindex terminal type

  @dfn{Terminal} (@dfn{terminal}) это устройство способное
отображать один или несколько фреймов Emacs (@pxref{Frame Type}).

@c   A @dfn{terminal} is a device capable of displaying one or more
@c Emacs frames (@pxref{Frame Type}).

  Терминалы не имеют синтаксиса чтения. Они печатаются в хеш
нотации в которой выводится номер терминала и имя TTY файла.

@c   Terminals have no read syntax.  They print in hash notation giving
@c the terminal's ordinal number and its TTY device file name.

@example
@group
(get-device-terminal nil)
     @result{} #<terminal 1 on /dev/tty>
@end group
@end example

@c FIXME: add an xref to where terminal-related primitives are described.

@node Window Configuration Type
@subsection Window Configuration Type
@cindex window layout in a frame

  @dfn{Конфигурация окна} (@dfn{window configuration}) хранит
информацию о позиции, размерах, и содержимом окон во фрейме, что
позволяет сохранять и восстанавливать раскладку окон.

@c   A @dfn{window configuration} stores information about the positions,
@c sizes, and contents of the windows in a frame, so you can recreate the
@c same arrangement of windows later.

  Конфигурации окон не имеют синтаксиса чтения, печатаются они
в хеш нотации в виде @samp{#<window-configuration>}. См.
@xref{Window Configurations} для получения информации по функциям
связанным с типом конфигурации окна.

@c   Window configurations do not have a read syntax; their print syntax
@c looks like @samp{#<window-configuration>}.  @xref{Window
@c Configurations}, for a description of several functions related to
@c window configurations.

@node Frame Configuration Type
@subsection Frame Configuration Type
@cindex screen layout
@cindex window layout, all frames

  @dfn{Конфигурация фрейма} (@dfn{frame configuration}) хранит
информацию о позициях, размерах, и содержимом окон во всех фреймах.
Конфигурация не примитивный тип --- это список @sc{car} в котором
@code{frame-configuration} и @sc{cdr} это alist. Каждый
элемент в alist описывает один фрейм, который определяется в
@sc{car} этого элемента alist.

@c   A @dfn{frame configuration} stores information about the positions,
@c sizes, and contents of the windows in all frames.  It is not a
@c primitive type---it is actually a list whose @sc{car} is
@c @code{frame-configuration} and whose @sc{cdr} is an alist.  Each alist
@c element describes one frame, which appears as the @sc{car} of that
@c element.

  См. @xref{Frame Configurations}, для получения информации по
функциям работы с конфигурацией фрейма.

@c   @xref{Frame Configurations}, for a description of several functions
@c related to frame configurations.

@node Process Type
@subsection Process Type

  Под @dfn{процессом} (@dfn{process}) обычно понимают работающую программу.
Emacs тоже запускается как процесс. Но, в Emacs Lisp, под процессом
понимается Lisp объект, который указывает на под процесс созданный
процессом Emacs. Такие программы  как shell, GDB, ftp и компиляторы,
запускаются в под процессах Emacs, для расширения его возможностей.

@c   The word @dfn{process} usually means a running program.  Emacs itself
@c runs in a process of this sort.  However, in Emacs Lisp, a process is a
@c Lisp object that designates a subprocess created by the Emacs process.
@c Programs such as shells, GDB, ftp, and compilers, running in
@c subprocesses of Emacs, extend the capabilities of Emacs.

  Под процесс Emacs получает текстовые данные от Emacs (input) и
возвращает текстовые данные (output) Emacs(у) для дальнейших
действий. Кроме того Emacs может посылать сигналы под процессам.

@c   An Emacs subprocess takes textual input from Emacs and returns textual
@c output to Emacs for further manipulation.  Emacs can also send signals
@c to the subprocess.

  Объекты процессов не имеют синтаксиса чтения. Процессы печатаются
в хеш нотации в которой выводится имя процесса:

@c   Process objects have no read syntax.  They print in hash notation,
@c giving the name of the process:

@example
@group
(process-list)
     @result{} (#<process shell>)
@end group
@end example

См. @xref{Processes} для изучения функций создания, удаления, получения
информации о, отправки ввода или сигналов, и получения вывода
от процессов.

@c @xref{Processes}, for information about functions that create, delete,
@c return information about, send input or signals to, and receive output
@c from processes.

@node Stream Type
@subsection Stream Type

  @dfn{Поток} (@dfn{stream}) это объект который может быть использован
как источник или получатель символов(знаков) --- либо предоставлять
данные на ввод, либо принимать их как вывод.  Многие типы данных могут
использоваться таким образом: маркеры, буферы, строки и функции.
Наиболее часто, потоки ввода (источники символов(знаков)) считывают
данных с клавиатуры, буфера, файла и выводят символы (приемники символов)
отправляют символы в буфер, такой как @file{*Help*} буфер или в
эхо (echo) область.

@c   A @dfn{stream} is an object that can be used as a source or sink for
@c characters---either to supply characters for input or to accept them as
@c output.  Many different types can be used this way: markers, buffers,
@c strings, and functions.  Most often, input streams (character sources)
@c obtain characters from the keyboard, a buffer, or a file, and output
@c streams (character sinks) send characters to a buffer, such as a
@c @file{*Help*} buffer, or to the echo area.

  Объект @code{nil}, может быть использован как поток.
Он соответствует @code{standard-input} и @code{standard-output}.
Объект @code{t} в качестве входного потока соответствует
мини-буферу ((@pxref{Minibuffers})) или эхо области в качестве
выходного (@pxref{The Echo Area}).

@c   The object @code{nil}, in addition to its other meanings, may be used
@c as a stream.  It stands for the value of the variable
@c @code{standard-input} or @code{standard-output}.  Also, the object
@c @code{t} as a stream specifies input using the minibuffer
@c (@pxref{Minibuffers}) or output in the echo area (@pxref{The Echo
@c Area}).

  Потоки не имеют формы чтения или печати, и печатаются
как примитивный тип.
  
@c   Streams have no special printed representation or read syntax, and
@c print as whatever primitive type they are.

  См. @xref{Read and Print}  для изучения функций связанных с чтением,
включающих парсинг и печать.

@c   @xref{Read and Print}, for a description of functions
@c related to streams, including parsing and printing functions.

@node Keymap Type
@subsection Keymap Type

  @dfn{раскладка} (@dfn{keymap}) отображает нажатие клавиш на пользовательские команды.
(Прим. То есть какую комбинацию нужно нажать, чтобы выполнилась та или иная команда.)
Раскладка представляется в виде списка у которого @sc{car} это символ
@code{keymap}.

@c   A @dfn{keymap} maps keys typed by the user to commands.  This mapping
@c controls how the user's command input is executed.  A keymap is actually
@c a list whose @sc{car} is the symbol @code{keymap}.

  См. @xref{Keymaps}, для получения информации по созданию, управлению префиксами,
локальностью (областью действия), и изменению привязок клавиш.
  
@c   @xref{Keymaps}, for information about creating keymaps, handling prefix
@c keys, local as well as global keymaps, and changing key bindings.

@node Overlay Type
@subsection Overlay Type

  @dfn{Наложение} (@dfn{overlay}) определяет свойства, которые
применяются только к части буфера. Каждое наложение применяется к
области буфера, и содержит список свойств (список элементы которого
изменяют имена и значение.) Свойства overlay используются для
представления частей буфера в разном стиле отображения. Оverlays
не имеют синтаксиса чтения, печатаются в хеш нотации, в которой
выводится имя буфера и область относящаяся к наложению.

@c   An @dfn{overlay} specifies properties that apply to a part of a
@c buffer.  Each overlay applies to a specified range of the buffer, and
@c contains a property list (a list whose elements are alternating property
@c names and values).  Overlay properties are used to present parts of the
@c buffer temporarily in a different display style.  Overlays have no read
@c syntax, and print in hash notation, giving the buffer name and range of
@c positions.

  См. @xref{Overlays} для информации по созданию и использованию overlays.

  @c @xref{Overlays}, for information on how you can create and use overlays.

@node Font Type
@subsection Font Type

  @dfn{Шрифт} (@dfn{font}) определяет стиль отображения текста
на графическом терминале. Есть 3 типа шрифтов---@dfn{Объекты шрифтов}
(@dfn{font objects}), @dfn{font specs}, и @dfn{font entities}--- каждый
из которых имеет некоторые особенности. Никакой из них
не имеет синтаксиса чтения; их печатные формы выглядят как:
@samp{#<font-object>}, @samp{#<font-spec>}, и
@samp{#<font-entity>} соответственно.  См. @xref{Low-Level Font} для
описания этих Lisp объектов.

@c   A @dfn{font} specifies how to display text on a graphical terminal.
@c There are actually three separate font types---@dfn{font objects},
@c @dfn{font specs}, and @dfn{font entities}---each of which has slightly
@c different properties.  None of them have a read syntax; their print
@c syntax looks like @samp{#<font-object>}, @samp{#<font-spec>}, and
@c @samp{#<font-entity>} respectively.  @xref{Low-Level Font}, for a
@c description of these Lisp objects.

@node Circular Objects
@section Read Syntax for Circular Objects
@cindex circular structure, read syntax
@cindex shared structure, read syntax
@cindex @samp{#@var{n}=} read syntax
@cindex @samp{#@var{n}#} read syntax

  Для представления разделяемых или циклических объектов внутри сложных
Lisp объектов, можно использовать конструкцию чтения @samp{#@var{n}=}
и @samp{#@var{n}#}.

@c   To represent shared or circular structures within a complex of Lisp
@c objects, you can use the reader constructs @samp{#@var{n}=} and
@c @samp{#@var{n}#}.

  @code{#@var{n}=} используется перед объектом, чтобы пометить его,
для дальнейших ссылок, а @code{#@var{n}#} позволяет сослаться на помеченный
объект. @var{n} некоторое целое число. Ниже пример где
первый элемент так же является третьим элементом.

@c   Use @code{#@var{n}=} before an object to label it for later reference;
@c subsequently, you can use @code{#@var{n}#} to refer the same object in
@c another place.  Here, @var{n} is some integer.  For example, here is how
@c to make a list in which the first element recurs as the third element:

@example
(#1=(a) b #1#)
@end example

@noindent
в отличие от обычное записи:

@example
((a) b (a))
@end example

@noindent
В которой в результирующем списке первый и третий элемент выглядят
похоже но не являются одним и тем же Lisp объектом. Ниже показывается
различие:

@c which would result in a list whose first and third elements
@c look alike but are not the same Lisp object.  This shows the difference:

@example
(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))
     @result{} t
(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))
     @result{} nil
@end example

  Этот же список можно использовать для создания циклических структур,
которые сами являются элементом этой структуры. Ниже пример:

@c   You can also use the same syntax to make a circular structure, which
@c appears as an element within itself.  Here is an example:

@example
#1=(a #1#)
@end example

@noindent
Тут создается список вторым элементом которого является
сам этот список. Ниже показывается как проверить, что
это работает:

@c This makes a list whose second element is the list itself.
@c Here's how you can see that it really works:

@example
(prog1 nil
  (setq x '#1=(a #1#)))
(eq x (cadr x))
     @result{} t
@end example

  Lisp будет печатать такие структуры, если задать значение переменной
@code{print-circle} в не-@code{nil}. @xref{Output Variables}.

@c   The Lisp printer can produce this syntax to record circular and shared
@c structure in a Lisp object, if you bind the variable @code{print-circle}
@c to a non-@code{nil} value.  @xref{Output Variables}.

@node Type Predicates
@section Type Predicates
@cindex type checking
@kindex wrong-type-argument

  Предикаты типов.

  Интерпретатор Emacs Lisp не выполняет проверку типов аргументов
функций при их вызове. Интерпретатор не может выполнить эту проверку,
потому что аргументы функции в Lisp не имеют заданных типов данных, как
в многих других языках программирования. Но в Emacs Lisp есть
отдельные функции для проверки каждого аргумента на принадлежность к
поддерживаемым функцией типам данных (типам с которыми функция сможет
работать).

@c   The Emacs Lisp interpreter itself does not perform type checking on
@c the actual arguments passed to functions when they are called.  It could
@c not do so, since function arguments in Lisp do not have declared data
@c types, as they do in other programming languages.  It is therefore up to
@c the individual function to test whether each actual argument belongs to
@c a type that the function can use.

  Все встроенные функции выполняют проверку типов, аргументов,
и сигнализирует с помощью ошибки @code{wrong-type-argument} если
аргумент не правильного типа. Например, вот что случится если
передать в @code{+} аргумент который не может быть обработан:
 
@c   All built-in functions do check the types of their actual arguments
@c when appropriate, and signal a @code{wrong-type-argument} error if an
@c argument is of the wrong type.  For example, here is what happens if you
@c pass an argument to @code{+} that it cannot handle:

@example
@group
(+ 2 'a)
     @error{} Wrong type argument: number-or-marker-p, a
@end group
@end example

@cindex type predicates
@cindex testing types

  Если нужно, чтобы программа обрабатывала разные типы по разному,
нужно выполнять явную проверку типов. Чаще всего для этого вызывается
функция @dfn{проверки типа} (@dfn{type predicate}). Emacs
имеет функцию проверки тип для каждого типа, и набор предикатов
для сочетаний типов.

@c   If you want your program to handle different types differently, you
@c must do explicit type checking.  The most common way to check the type
@c of an object is to call a @dfn{type predicate} function.  Emacs has a
@c type predicate for each type, as well as some predicates for
@c combinations of types.

  Функция проверки типа(предикат типа), принимает один аргумент и
возвращает  @code{t} если аргумент относится к соответствующему типу,
иначе возвращается @code{nil}. В соответствии с соглашением Lisp
по именованию функций предикатов, большинство имен функций проверки
типов оканчиваются на @samp{p}.

@c   A type predicate function takes one argument; it returns @code{t} if
@c the argument belongs to the appropriate type, and @code{nil} otherwise.
@c Following a general Lisp convention for predicate functions, most type
@c predicates' names end with @samp{p}.

  Ниже пример, в котором используется предикат @code{listp}, для проверки
что элемент список и @code{symbolp} для проверки что элемент символ(объект).

@c   Here is an example which uses the predicates @code{listp} to check for
@c a list and @code{symbolp} to check for a symbol.

@example
(defun add-on (x)
  (cond ((symbolp x)
         ;; If X is a symbol, put it on LIST.
         (setq list (cons x list)))
        ((listp x)
         ;; If X is a list, add its elements to LIST.
         (setq list (append x list)))
        (t
         ;; We handle only symbols and lists.
         (error "Invalid argument %s in add-on" x))))
@end example

  Ниже приводится таблица встроенных функций определения
типов, в алфавитном порядке, со ссылками на более
подробную информацию.

@c   Here is a table of predefined type predicates, in alphabetical order,
@c with references to further information.

@table @code
@item atom
@xref{List-related Predicates, atom}.

@item arrayp
@xref{Array Functions, arrayp}.

@item bool-vector-p
@xref{Bool-Vectors, bool-vector-p}.

@item bufferp
@xref{Buffer Basics, bufferp}.

@item byte-code-function-p
@xref{Byte-Code Type, byte-code-function-p}.

@item case-table-p
@xref{Case Tables, case-table-p}.

@item char-or-string-p
@xref{Predicates for Strings, char-or-string-p}.

@item char-table-p
@xref{Char-Tables, char-table-p}.

@item commandp
@xref{Interactive Call, commandp}.

@item consp
@xref{List-related Predicates, consp}.

@item custom-variable-p
@xref{Variable Definitions, custom-variable-p}.

@item floatp
@xref{Predicates on Numbers, floatp}.

@item fontp
@xref{Low-Level Font}.

@item frame-configuration-p
@xref{Frame Configurations, frame-configuration-p}.

@item frame-live-p
@xref{Deleting Frames, frame-live-p}.

@item framep
@xref{Frames, framep}.

@item functionp
@xref{Functions, functionp}.

@item hash-table-p
@xref{Other Hash, hash-table-p}.

@item integer-or-marker-p
@xref{Predicates on Markers, integer-or-marker-p}.

@item integerp
@xref{Predicates on Numbers, integerp}.

@item keymapp
@xref{Creating Keymaps, keymapp}.

@item keywordp
@xref{Constant Variables}.

@item listp
@xref{List-related Predicates, listp}.

@item markerp
@xref{Predicates on Markers, markerp}.

@item wholenump
@xref{Predicates on Numbers, wholenump}.

@item nlistp
@xref{List-related Predicates, nlistp}.

@item numberp
@xref{Predicates on Numbers, numberp}.

@item number-or-marker-p
@xref{Predicates on Markers, number-or-marker-p}.

@item overlayp
@xref{Overlays, overlayp}.

@item processp
@xref{Processes, processp}.

@item sequencep
@xref{Sequence Functions, sequencep}.

@item stringp
@xref{Predicates for Strings, stringp}.

@item subrp
@xref{Function Cells, subrp}.

@item symbolp
@xref{Symbols, symbolp}.

@item syntax-table-p
@xref{Syntax Tables, syntax-table-p}.

@item vectorp
@xref{Vectors, vectorp}.

@item window-configuration-p
@xref{Window Configurations, window-configuration-p}.

@item window-live-p
@xref{Deleting Windows, window-live-p}.

@item windowp
@xref{Basic Windows, windowp}.

@item booleanp
@xref{nil and t, booleanp}.

@item string-or-null-p
@xref{Predicates for Strings, string-or-null-p}.
@end table

  Наиболее общий способ определения типа объекта это
вызов функции @code{type-of}. Вызов который возвращает один
и только один базовый (встроенный тип), к которому относится объект;
(@pxref{Lisp Data Types}). @code{type-of} ничего не знает о не базовых
типах. В большинстве случаев, более удобно использовать
функцию проверки типа чем @code{type-of}.

@c   The most general way to check the type of an object is to call the
@c function @code{type-of}.  Recall that each object belongs to one and
@c only one primitive type; @code{type-of} tells you which one (@pxref{Lisp
@c Data Types}).  But @code{type-of} knows nothing about non-primitive
@c types.  In most cases, it is more convenient to use type predicates than
@c @code{type-of}.

@defun type-of object
Функция возвращает символ(объект) с именем примитивного(базового)
типа параметра @var{object}. Значением является
один из символов: @code{bool-vector},
@code{buffer}, @code{char-table}, @code{compiled-function},
@code{cons}, @code{finalizer}, @code{float}, @code{font-entity},
@code{font-object}, @code{font-spec}, @code{frame}, @code{hash-table},
@code{integer}, @code{marker}, @code{overlay}, @code{process},
@code{string}, @code{subr}, @code{symbol}, @code{vector},
@code{window}, или @code{window-configuration}.

@c This function returns a symbol naming the primitive type of
@c @var{object}.  The value is one of the symbols @code{bool-vector},
@c @code{buffer}, @code{char-table}, @code{compiled-function},
@c @code{cons}, @code{finalizer}, @code{float}, @code{font-entity},
@c @code{font-object}, @code{font-spec}, @code{frame}, @code{hash-table},
@c @code{integer}, @code{marker}, @code{overlay}, @code{process},
@c @code{string}, @code{subr}, @code{symbol}, @code{vector},
@c @code{window}, or @code{window-configuration}.

@example
(type-of 1)
     @result{} integer
@group
(type-of 'nil)
     @result{} symbol
(type-of '())    ; @r{@code{()} is @code{nil}.}
     @result{} symbol
(type-of '(x))
     @result{} cons
@end group
@end example
@end defun

@node Equality Predicates
@section Equality Predicates
@cindex equality

  Функции сравнения. (Предикаты равенства).
  Опишем функции которые проверяют равенство двух объектов.
В Emacs Lisp есть функции которые проверяют равенство содержимого объектов
определенных типов, таких как строки. Описание таких функций будет дано
в соответствующих главах.
  
@c   Here we describe functions that test for equality between two
@c objects.  Other functions test equality of contents between objects of
@c specific types, e.g., strings.  For these predicates, see the
@c appropriate chapter describing the data type.

@defun eq object1 object2
  Функция возвращает @code{t} если @var{object1} и @var{object2} являются
одним и тем же объектом, и @code{nil} в другом случае.

@c This function returns @code{t} if @var{object1} and @var{object2} are
@c the same object, and @code{nil} otherwise.

Если @var{object1} и @var{object2} целые числа, с одним и тем же
значением, они рассматриваются как один и тот же объект (т.е..,
@code{eq} возвращает @code{t}). Если @var{object1} и @var{object2}
символы с одним и тем же именем, то обычно они один и тот же объект,
но бывают исключения (подробности описаны в @ref{Creating Symbols}).
Для других типов (таких как списки, вектора, строки), аргументы с одним
и тем же содержимым не обязательно будут @code{eq} друг другу. Они
будут @code{eq}, только если они один и тот же объект, понимая под
этим (по сути ``предполагаемая'' ссылка указывает на одно и тоже место
в памяти), что изменение содержимого одного из них будет
отражено этим же изменением в другом.

@c If @var{object1} and @var{object2} are integers with the same value,
@c they are considered to be the same object (i.e., @code{eq} returns
@c @code{t}).  If @var{object1} and @var{object2} are symbols with the
@c same name, they are normally the same object---but see @ref{Creating
@c Symbols} for exceptions.  For other types (e.g., lists, vectors,
@c strings), two arguments with the same contents or elements are not
@c necessarily @code{eq} to each other: they are @code{eq} only if they
@c are the same object, meaning that a change in the contents of one will
@c be reflected by the same change in the contents of the other.

@example
@group
(eq 'foo 'foo)
     @result{} t
@end group

@group
(eq 456 456)
     @result{} t
@end group

@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(eq "" "")
     @result{} t
;; @r{Исключение происходит из-за того, что Emacs Lisp}
;; @r{создает только одну много-байтовую пустую строку, для сохранения места.}
@end group

@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(setq foo '(1 (2 (3))))
     @result{} (1 (2 (3)))
(eq foo foo)
     @result{} t
(eq foo '(1 (2 (3))))
     @result{} nil
@end group

@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

@noindent
Функция @code{make-symbol} возвращает не интернированный символ, который отличается
от символа, который используется если написать имя в Lisp выражении.
Разные символы с одним и тем же именем не @code{eq}.  @xref{Creating Symbols}.

@c The @code{make-symbol} function returns an uninterned symbol, distinct
@c from the symbol that is used if you write the name in a Lisp expression.
@c Distinct symbols with the same name are not @code{eq}.  @xref{Creating
@c Symbols}.

@example
@group
(eq (make-symbol "foo") 'foo)
     @result{} nil
@end group
@end example
@end defun

@defun equal object1 object2
Данная функция возвращает @code{t} если @var{object1} и @var{object2}
состоят из одинаковых компонентов, и  @code{nil} в противном случае.
Тогда как @code{eq} проверяет, что его аргументы один и тот же объект,
@code{equal} смотрит внутрь различных объектов для проверки, что
их элементы или содержимое одинаково. Поэтому если два объекта
@code{eq}, они @code{equal}, но обратное не всегда верно.

@c This function returns @code{t} if @var{object1} and @var{object2} have
@c equal components, and @code{nil} otherwise.  Whereas @code{eq} tests
@c if its arguments are the same object, @code{equal} looks inside
@c nonidentical arguments to see if their elements or contents are the
@c same.  So, if two objects are @code{eq}, they are @code{equal}, but
@c the converse is not always true.

@example
@group
(equal 'foo 'foo)
     @result{} t
@end group

@group
(equal 456 456)
     @result{} t
@end group

@group
(equal "asdf" "asdf")
     @result{} t
@end group
@group
(eq "asdf" "asdf")
     @result{} nil
@end group

@group
(equal '(1 (2 (3))) '(1 (2 (3))))
     @result{} t
@end group
@group
(eq '(1 (2 (3))) '(1 (2 (3))))
     @result{} nil
@end group

@group
(equal [(1 2) 3] [(1 2) 3])
     @result{} t
@end group
@group
(eq [(1 2) 3] [(1 2) 3])
     @result{} nil
@end group

@group
(equal (point-marker) (point-marker))
     @result{} t
@end group

@group
(eq (point-marker) (point-marker))
     @result{} nil
@end group
@end example

Сравнение строк не учитывает регистр, но не учитывает текстовые свойства---
сравниваются только символы в строках. @xref{Text Properties}.
Можно использовать @code{equal-including-properties}, чтобы сравнивались
и текстовые свойства. По техническим причинам, одно-байтовые строки и
много-байтовые строки @code{equal}, только если они содержат
одни и те же последовательности символов и все эти кода в
диапазоне от 0 до 127 (@acronym{ASCII}) или от 160 до 255
(@code{eight-bit-graphic}).  (@pxref{Text Representations}).

@c Comparison of strings is case-sensitive, but does not take account of
@c text properties---it compares only the characters in the strings.
@c @xref{Text Properties}.  Use @code{equal-including-properties} to also
@c compare text properties.  For technical reasons, a unibyte string and
@c a multibyte string are @code{equal} if and only if they contain the
@c same sequence of character codes and all these codes are either in the
@c range 0 through 127 (@acronym{ASCII}) or 160 through 255
@c (@code{eight-bit-graphic}).  (@pxref{Text Representations}).

@example
@group
(equal "asdf" "ASDF")
     @result{} nil
@end group
@end example

Но, два различных буфера никогда не @code{equal}, даже если у них
одинаковое содержимое.

@c However, two distinct buffers are never considered @code{equal}, even if
@c their textual contents are the same.
@end defun

  Проверка на равенство выполняется рекурсивно, например, если
выполняется сравнение 2-х cons ячеек @var{x} и @var{y},
@code{(equal @var{x} @var{y})} вернет @code{t}, только если
оба выражения вернут @code{t}:

@c   The test for equality is implemented recursively; for example, given
@c two cons cells @var{x} and @var{y}, @code{(equal @var{x} @var{y})}
@c returns @code{t} if and only if both the expressions below return
@c @code{t}:

@example
(equal (car @var{x}) (car @var{y}))
(equal (cdr @var{x}) (cdr @var{y}))
@end example

Такой рекурсивный метод, может привести к зацикливанию на циклических
структурах, что приведет к ошибке.

@c Because of this recursive method, circular lists may therefore cause
@c infinite recursion (leading to an error).

@defun equal-including-properties object1 object2
Функция работает как @code{equal}, но дополнительно требует,
чтобы текстовые свойства строк были равны.
 
@c This function behaves like @code{equal} in all cases but also requires
@c that for two strings to be equal, they have the same text properties.

@example
@group
(equal "asdf" (propertize "asdf" 'asdf t))
     @result{} t
@end group
@group
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
     @result{} nil
@end group
@end example
@end defun
