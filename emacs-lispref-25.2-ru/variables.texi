@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2017 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Variables
@chapter Переменные
@cindex variable

 @dfn{Переменная} (@dfn{variable}) это имя используемое для обозначения
значения. В Lisp, каждая переменная представлена символом Lisp
(@pxref{Symbols}). Имя переменной это просто имя символа, а значение
переменной хранится в ячейки значения символа @footnote{Более точно,
если используется правило динамической области видимости @dfn{dynamic scoping},
ячейка значения всегда хранит текущее значение переменной, но в
случае если используется лексическая область видимости @dfn{lexical scoping}
это не так.} @xfre{Symbols Components}. В Emacs Lisp использование
символа в качестве переменной не зависимо от использования его в качестве
имени функции.

@c A @dfn{variable} is a name used in a program to stand for a value.
@c In Lisp, each variable is represented by a Lisp symbol
@c (@pxref{Symbols}).  The variable name is simply the symbol's name, and
@c the variable's value is stored in the symbol's value cell@footnote{To
@c be precise, under the default @dfn{dynamic scoping} rule, the value
@c cell always holds the variable's current value, but this is not the
@c case under the @dfn{lexical scoping} rule.  @xref{Variable Scoping},
@c for details.}.  @xref{Symbol Components}.  In Emacs Lisp, the use of a
@c symbol as a variable is independent of its use as a function name.

  Как было раньше замечено, Lisp программа представляет собой
в первую очередь Lisp объекты, и только потом как текст. Текстовая
форма Lisp программы представляется синтаксисом чтения Lisp объектов
из которых состоит программа. Поэтому текстовая форма переменной
в Lisp программы записывается используя синтаксис чтения символа
представляющего переменную.

@c   As previously noted in this manual, a Lisp program is represented
@c primarily by Lisp objects, and only secondarily as text.  The textual
@c form of a Lisp program is given by the read syntax of the Lisp objects
@c that constitute the program.  Hence, the textual form of a variable in
@c a Lisp program is written using the read syntax for the symbol
@c representing the variable.

@menu
* Global Variables::            Переменные значения которых существуют постоянно и доступны
                                отовсюду.
* Constant Variables::          Константы, неизменяемые переменные.
* Local Variables::             Переменные которые существуют ограниченное время. 
* Void Variables::              Символы без значений.
* Defining Variables::          Определение задает использование символа в качестве переменной.
* Tips for Defining::           Вещи, о которых нужно подумать при определении переменных.
* Accessing Variables::         Получение значений переменных имена которых, становятся 
                                известны в процессе выполнения.

* Setting Variables::           Установка значения.
* Variable Scoping::            Как Lisp определяет нужно ли использовать локальное или глобальное значение.
* Buffer-Local Variables::      Переменные значения которых относятся только к одному буферу.
* File Local Variables::        Работа с локальными переменными файлов.
* Directory Local Variables::   Локальные переменные общие для всех файлов в каталоге.
* Variable Aliases::            Переменные являющиеся псевдонимами других переменных.
* Variables with Restricted Values:: Переменные не константы, значения которых не @emph{могут}
                                     быть  произвольным Lisp объектом.
* Generalized Variables::       Расширение концепции переменных.
@end menu

@node Global Variables
@section Глобальные переменные
@cindex global variable

  Простейшим способом использования переменной это @dfn{глобально} (@dfn{globally}).
В этом случае в каждый момент времени переменная имеет одно значение, и это
значение доступно всюду в Lisp системе. Значение действует, пока не будет
изменено на другое. При установке нового значения в переменной не остается
следа от старого.

@c   The simplest way to use a variable is @dfn{globally}.  This means that
@c the variable has just one value at a time, and this value is in effect
@c (at least for the moment) throughout the Lisp system.  The value remains
@c in effect until you specify a new one.  When a new value replaces the
@c old one, no trace of the old value remains in the variable.

  Задать значения для символа можно с помощью @code{setq}. Например:

  @c You specify a value for a symbol with @code{setq}.  For example,

@example
(setq x '(a b))
@end example

@noindent
задает переменной @code{x} значение @code{(a b)}. @code{setq} является
особой формой (special form) (@pxref{Special Forms}); первый аргумент имя
переменной не вычисляется, но вычисляется второй аргумент, которые становится новым
значением.

@c gives the variable @code{x} the value @code{(a b)}.  Note that
@c @code{setq} is a special form (@pxref{Special Forms}); it does not
@c evaluate its first argument, the name of the variable, but it does
@c evaluate the second argument, the new value.

  Когда переменной задано значение, можно ссылаться на нее
по символу. Таким образом,

@c   Once the variable has a value, you can refer to it by using the
@c symbol itself as an expression.  Thus,

@example
@group
x @result{} (a b)
@end group
@end example

@noindent
предполагая что @code{setq} выше, была выполнена.

@c assuming the @code{setq} form shown above has already been executed.

  Если еще раз выполнить установку значения, новое значение заменит
старое:

@c   If you do set the same variable again, the new value replaces the old
@c one:

@example
@group
x
     @result{} (a b)
@end group
@group
(setq x 4)
     @result{} 4
@end group
@group
x
     @result{} 4
@end group
@end example

@node Constant Variables
@section Константы - неизменяемые переменные
@cindex @code{setting-constant} error
@cindex keyword symbol
@cindex variable with constant value
@cindex constant variables
@cindex symbol that evaluates to itself
@cindex symbol with constant value

  В Emacs Lisp, определенные символы вычисляются в себя. Такие как @code{nil},
@code{t}, как и символы имена которых начинаются с @samp{:} (называются @dfn{ключевыми
словами} @dfn{keywords}). Для таких символов не может быть изменена привязка(rebound) и
значение. Все попытки установки значения @code{nil} или @code{t} сигнализируют @code{setting-constant} ошибку. Аналогично для ключевых слов (символов начинающихся на @samp{:}),
если символы интернированы в стандартный obarray, за исключением установки
данных символов значением являющимся этим символом.

@c   In Emacs Lisp, certain symbols normally evaluate to themselves.  These
@c include @code{nil} and @code{t}, as well as any symbol whose name starts
@c with @samp{:} (these are called @dfn{keywords}).  These symbols cannot
@c be rebound, nor can their values be changed.  Any attempt to set or bind
@c @code{nil} or @code{t} signals a @code{setting-constant} error.  The
@c same is true for a keyword (a symbol whose name starts with @samp{:}),
@c if it is interned in the standard obarray, except that setting such a
@c symbol to itself is not an error.

@example
@group
nil @equiv{} 'nil
     @result{} nil
@end group
@group
(setq nil 500)
@error{} Attempt to set constant symbol: nil
@end group
@end example

@defun keywordp object
Функция возвращает @code{t} если @var{object} является символом имя
которого начинается с @samp{:}, интернированный в стандартный obarray, и
@code{nil} в другом случае.

@c function returns @code{t} if @var{object} is a symbol whose name
@c starts with @samp{:}, interned in the standard obarray, and returns
@c @code{nil} otherwise.
@end defun

Константы ключевые слова, отличаются от констант определенных
с использованием специальной формы @code{defconst} (@pxref{Defining Variables}).
Форма @code{defconst} используется для информирования пользователей
читающих текст, что переменная предполагается не изменяемой, но Emacs
не возбудит исключение в случае если такая переменная будет изменена.

@c These constants are fundamentally different from the constants
@c defined using the @code{defconst} special form (@pxref{Defining
@c Variables}).  A @code{defconst} form serves to inform human readers
@c that you do not intend to change the value of a variable, but Emacs
@c does not raise an error if you actually change it.

@node Local Variables
@section Локальные переменные
@cindex binding local variables
@cindex local variables
@cindex local binding
@cindex global binding

  Глобальные переменные имеют значение, которое было установлено
последним. В ряде случаев полезно задать переменной
@dfn{локальное значение} (@dfn{local value}) --- значение которое
доступно только в части Lisp программы. Когда переменная имеет локальное
значение, считается что она @dfn{локально связана} (@dfn{locally bound})
с этим значением, и она является @dfn{локальное переменной} (@dfn{local variable}).

@c   Global variables have values that last until explicitly superseded
@c with new values.  Sometimes it is useful to give a variable a
@c @dfn{local value}---a value that takes effect only within a certain
@c part of a Lisp program.  When a variable has a local value, we say
@c that it is @dfn{locally bound} to that value, and that it is a
@c @dfn{local variable}.

  Например, при вызове функции, переменные аргументов получают
локальные значения равные актуальным аргументам вызова функции,
переменные доступны внутри тела функции. Специальная форма @code{let}
явно задает локальное связывание заданных переменных, которое
действует внутри тела формы @code{let}.

@c   For example, when a function is called, its argument variables
@c receive local values, which are the actual arguments supplied to the
@c function call; these local bindings take effect within the body of the
@c function.  To take another example, the @code{let} special form
@c explicitly establishes local bindings for specific variables, which
@c take effect within the body of the @code{let} form.

  Соответственно @dfn{global bindings}, это связывание с использованием
глобальным значением.

@c   We also speak of the @dfn{global binding}, which is where
@c (conceptually) the global value is kept.

@cindex shadowing of variables
  Установка локального значения сохраняет предыдущее значение
переменной (или его отсутствие). Такое сохранение будем называть
@dfn{затенением} (@dfn{shadowed}). Как глобальное, так и локальное значения
могут быть затенены. Если локальная переменная активна в текущей области
видимости, то использование @code{setq} с этой локальной переменной, будет
сохранять заданное значение в эту переменную. Вне области действия локальной
переменной, возвращается затенное значение (или его отсутствие).
 
@c   Establishing a local binding saves away the variable's previous
@c value (or lack of one).  We say that the previous value is
@c @dfn{shadowed}.  Both global and local values may be shadowed.  If a
@c local binding is in effect, using @code{setq} on the local variable
@c stores the specified value in the local binding.  When that local
@c binding is no longer in effect, the previously shadowed value (or lack
@c of one) comes back.

@cindex current binding
  Переменная может иметь больше одного локального связывания в каждый
момент времени (например в случае вложенных @code{let}). @dfn{текущее связывание}
(@dfn{current binding}) это текущая действующая привязка. Она
определяет символ возвращаемый при вычислении символа, и задание
привязки с использованием @code{setq}.

@c   A variable can have more than one local binding at a time (e.g., if
@c there are nested @code{let} forms that bind the variable).  The
@c @dfn{current binding} is the local binding that is actually in effect.
@c It determines the value returned by evaluating the variable symbol,
@c and it is the binding acted on by @code{setq}.

  В большинстве случаев можно считать, что текущее связывание
это самая глубокая (по дереву кода) привязка или глобальная, если
локальной привязки нет. Более точно, правило называемое
@dfn{правило области видимости} (@dfn{scoping rule}) определяет
где будет действовать локальное связывание. Правило по умолчанию
называется @dfn{dynamic scoping} (@dfn{динамическая область видимости}),
которое просто определяет текущее связывание в любой точки программы
как самое новое связывание для переменной (последнее связывание является текущим).
Альтернативным способом связывания является @dfn{лексическая области видимости}
(@dfn{lexical scoping}).
Более подробно правило связывания рассматриваются в @xref{Variable Scoping}.

@c   For most purposes, you can think of the current binding as the
@c innermost local binding, or the global binding if there is no
@c local binding.  To be more precise, a rule called the @dfn{scoping
@c rule} determines where in a program a local binding takes effect.  The
@c default scoping rule in Emacs Lisp is called @dfn{dynamic scoping},
@c which simply states that the current binding at any given point in the
@c execution of a program is the most recently-created binding for that
@c variable that still exists.  For details about dynamic scoping, and an
@c alternative scoping rule called @dfn{lexical scoping}, @xref{Variable
@c Scoping}.

  Специальный формы @code{let} и @code{let*} служат для создания
локального связывания (локальных переменных).

@c   The special forms @code{let} and @code{let*} exist to create local
@c bindings:

@defspec let (bindings@dots{}) forms@dots{}
Специальная формы устанавливает локальное связывание для определенного
множества переменных, заданного @var{bindings}, после чего последовательно выполняет
все @var{forms}. Форма возвращает последнее вычисленное значение в @var{forms}.

@c This special form sets up local bindings for a certain set of
@c variables, as specified by @var{bindings}, and then evaluates all of
@c the @var{forms} in textual order.  Its return value is the value of
@c the last form in @var{forms}.

Каждый @var{bindings} является либо 1. @w{(i) a} символом, либо 2. @w{(ii) a}
списком. В первом случае символ локально связывается со значением @code{nil},
во втором случае список должен иметь форму @code{(@var{symbol} @var{value-form})},
и в этом случае @var{symbol} локально связывается с результатом вычисления
@var{value-form}. Если @var{value-form} опущена, использует @code{nil}.

@c Each of the @var{bindings} is either @w{(i) a} symbol, in which case
@c that symbol is locally bound to @code{nil}; or @w{(ii) a} list of the
@c form @code{(@var{symbol} @var{value-form})}, in which case
@c @var{symbol} is locally bound to the result of evaluating
@c @var{value-form}.  If @var{value-form} is omitted, @code{nil} is used.

Все @var{value-form} в @var{bindings} вычисляются в порядке следования
и @emph{до} выполнения привязок. В примере ниже: @code{z} связывается
со старым значением @code{y}, равным 2, а не новым значением 1.

@c All of the @var{value-form}s in @var{bindings} are evaluated in the
@c order they appear and @emph{before} binding any of the symbols to them.
@c Here is an example of this: @code{z} is bound to the old value of
@c @code{y}, which is 2, not the new value of @code{y}, which is 1.

@example
@group
(setq y 2)
     @result{} 2
@end group

@group
(let ((y 1)
      (z y))
  (list y z))
     @result{} (1 2)
@end group
@end example

С другой стороны, порядок @emph{bindings} не определен, и в следующем
пример может быть напечатано как 1 так и 2.

@c On the other hand, the order of @emph{bindings} is unspecified: in the
@c following example, either 1 or 2 might be printed.

@example
(let ((x 1)
      (x 2))
  (print x))
@end example

Поэтому стоит избегать, связывание одной переменной более одного
раза в одной форме @code{let}.

@c Therefore, avoid binding a variable more than once in a single
@c @code{let} form.
@end defspec

@defspec let* (bindings@dots{}) forms@dots{}
Данная специальная форма работает аналогично @code{let}, но в ней связывания
каждой переменной с вычисленным значением, выполняется до вычисления
локального значения следующей переменной. Таким образом, выражения в
@var{bindings} могут ссылаться на привязки для предыдущих символов в @code{let*}
форме. Ниже пример, показывающий отличие от @code{let}.

@c This special form is like @code{let}, but it binds each variable right
@c after computing its local value, before computing the local value for
@c the next variable.  Therefore, an expression in @var{bindings} can
@c refer to the preceding symbols bound in this @code{let*} form.
@c Compare the following example with the example above for @code{let}.

@example
@group
(setq y 2)
     @result{} 2
@end group

@group
(let* ((y 1)
       (z y))    ; @r{Use the just-established value of @code{y}.}
  (list y z))
     @result{} (1 1)
@end group
@end example
@end defspec

  Ниже приводится полный список других возможностей для создания
локального связывания (локальных переменных):

@c   Here is a complete list of the other facilities that create local
@c bindings:

@itemize @bullet
@item
Вызовы функций (@pxref{Functions}).
@c Function calls (@pxref{Functions}).

@item
Вызовы макросов (@pxref{Macros}).
@c Macro calls (@pxref{Macros}).

@item
@code{condition-case} (@pxref{Errors}).
@end itemize

  Переменные могут иметь локальные для буфера связывания(переменные)
(@pxref{Buffer-Local Variables}); некоторые переменные имеют локальные
для терминала связывания (@pxref{Multiple Terminals}). Эти виды связываний
работают аналогично локальному связыванию, но их область действия
зависит от текущего положения в Emacs.
  
@c   Variables can also have buffer-local bindings (@pxref{Buffer-Local
@c Variables}); a few variables have terminal-local bindings
@c (@pxref{Multiple Terminals}).  These kinds of bindings work somewhat
@c like ordinary local bindings, but they are localized depending on
@c where you are in Emacs.

@defopt max-specpdl-size
@anchor{Definition of max-specpdl-size}
@cindex variable limit error
@cindex evaluation error
@cindex infinite recursion
Переменная определяет ограничение на количество локальных переменных
и блоков @code{unwind-protect} очистки (см. @ref{Cleanups,, Cleaning Up from Nonlocal Exits})
которые выполняются до того как Emacs сигнализирует об ошибке (с данными @code{"Variable
bindings depth exceeds max-specpdl-size"}).

@c This variable defines the limit on the total number of local variable
@c bindings and @code{unwind-protect} cleanups (see @ref{Cleanups,,
@c Cleaning Up from Nonlocal Exits}) that are allowed before Emacs
@c signals an error (with data @code{"Variable binding depth exceeds
@c max-specpdl-size"}).

Данное ограничение и связанная ошибка, один из способов Lisp, избежать
бесконечных циклов для ошибочно определенных функций.
@code{max-lisp-eval-depth} предоставляет другое ограничение на
глубину вложений. @xref{Definition of max-lisp-eval-depth,, Eval}.

@c This limit, with the associated error when it is exceeded, is one way
@c that Lisp avoids infinite recursion on an ill-defined function.
@c @code{max-lisp-eval-depth} provides another limit on depth of nesting.
@c @xref{Definition of max-lisp-eval-depth,, Eval}.

Значение по умолчанию 1300. Вход в Lisp отладчик увеличивает значение,
если количество локальных переменных близко к ограничению, чтобы
отладчик сам мог выполняться.

@c The default value is 1300.  Entry to the Lisp debugger increases the
@c value, if there is little room left, to make sure the debugger itself
@c has room to execute.
@end defopt

@node Void Variables
@section Если переменная не определена
@cindex @code{void-variable} error
@cindex void variable

  Переменная не задана (пустая, void), если соответствующий символ имеет ячейку
значения, для которой не было присваивания (@pxref{Symbol Components}).

@c   We say that a variable is void if its symbol has an unassigned value
@c cell (@pxref{Symbol Components}).

  При использовании динамического правила видимости, которое является
дефорлтным в Emacs Lisp (@pxref{Variable Scoping}), ячейка значения хранит текущее
значение переменной (локальное или глобальное). При ячейка для которой
не было присваивания, это @emph{не} тоже, что ячейка со значением @code{nil}.
Символ @code{nil} это Lisp объект, который может быть значением переменной,
как и любой другой объект, но это значение. Если переменная не определена,
попытка вычислить переменную сигнализирует об ошибке @code{void-variable},
вместо возврата значения.

@c   Under Emacs Lisp's default dynamic scoping rule (@pxref{Variable
@c Scoping}), the value cell stores the variable's current (local or
@c global) value.  Note that an unassigned value cell is @emph{not} the
@c same as having @code{nil} in the value cell.  The symbol @code{nil} is
@c a Lisp object and can be the value of a variable, just as any other
@c object can be; but it is still a value.  If a variable is void, trying
@c to evaluate the variable signals a @code{void-variable} error, instead
@c of returning a value.

  Если используется лексическая область видимости, ячейка значения
хранит только глобальное значение---значение вне всех конструкций
лексического связывания. Когда переменная лексически связана, локальное
значение определяется лексическим окружением, отсюда, переменные
могут иметь локальные значения, даже если их для ячейки значения соответствующего
символа не было присваивания.
 
@c   Under the optional lexical scoping rule, the value cell only holds
@c the variable's global value---the value outside of any lexical binding
@c construct.  When a variable is lexically bound, the local value is
@c determined by the lexical environment; hence, variables can have local
@c values even if their symbols' value cells are unassigned.

@defun makunbound symbol
Функция очищает ячейку значения @var{symbol}, делая ее как если бы
для нее не было присваивания. Функция возвращает @var{symbol}.

@c This function empties out the value cell of @var{symbol}, making the
@c variable void.  It returns @var{symbol}.

Если @var{symbol} имеет динамическое локально связыванием, @code{makunbound}
очищает текущее связывание, и данная очистка действует, пока действует
локальное связывание. Как только, будет восстановлено затененное значение,
переменная перестанет быть пустой (void), если только затененное значение
тоже не было пустым.

@c If @var{symbol} has a dynamic local binding, @code{makunbound} voids
@c the current binding, and this voidness lasts only as long as the local
@c binding is in effect.  Afterwards, the previously shadowed local or
@c global binding is reexposed; then the variable will no longer be void,
@c unless the reexposed binding is void too.

Несколько примеров (предполагается динамическое правило связывания):

@c Here are some examples (assuming dynamic binding is in effect):

@smallexample
@group
(setq x 1)               ; @r{Put a value in the global binding.}
     @result{} 1
(let ((x 2))             ; @r{Locally bind it.}
  (makunbound 'x)        ; @r{Void the local binding.}
  x)
@error{} Symbol's value as variable is void: x
@end group
@group
x                        ; @r{The global binding is unchanged.}
     @result{} 1

(let ((x 2))             ; @r{Locally bind it.}
  (let ((x 3))           ; @r{And again.}
    (makunbound 'x)      ; @r{Void the innermost-local binding.}
    x))                  ; @r{And refer: it's void.}
@error{} Symbol's value as variable is void: x
@end group

@group
(let ((x 2))
  (let ((x 3))
    (makunbound 'x))     ; @r{Void inner binding, then remove it.}
  x)                     ; @r{Now outer @code{let} binding is visible.}
     @result{} 2
@end group
@end smallexample
@end defun

@defun boundp variable
Функция возвращает @code{t} если @var{variable} (символ) не
пуст (void), и @code{nil} если пуст (void).

@c This function returns @code{t} if @var{variable} (a symbol) is not
@c void, and @code{nil} if it is void.

Несколько примеров (предполагается динамическое правило связывания):

@c Here are some examples (assuming dynamic binding is in effect):

@smallexample
@group
(boundp 'abracadabra)          ; @r{Starts out void.}
     @result{} nil
@end group
@group
(let ((abracadabra 5))         ; @r{Locally bind it.}
  (boundp 'abracadabra))
     @result{} t
@end group
@group
(boundp 'abracadabra)          ; @r{Still globally void.}
     @result{} nil
@end group
@group
(setq abracadabra 5)           ; @r{Make it globally nonvoid.}
     @result{} 5
@end group
@group
(boundp 'abracadabra)
     @result{} t
@end group
@end smallexample
@end defun

@node Defining Variables
@section Определение Глобальных Переменных
@cindex variable definition

  @dfn{Определение переменной} конструкция анонсирующая намерение использовать
переменной в качестве глобальной. Используются конструкции @code{defvar} и
@code{defconst}, которые описаны ниже.

@c   A @dfn{variable definition} is a construct that announces your
@c intention to use a symbol as a global variable.  It uses the special
@c forms @code{defvar} or @code{defconst}, which are documented below.

  Определение переменной служит трем целям. Первая, информировать
людей читающих код, что символ @emph{предполагается} использовать
определенным образом (как переменную). Вторая, информировать Lisp
систему, с возможно предоставлением начального значения и документации.
Третья, предоставление информации вспомогательным утилитам, таким как
@command{etags}, позволяя им находить место определения переменной.

@c   A variable definition serves three purposes.  First, it informs
@c people who read the code that the symbol is @emph{intended} to be used
@c a certain way (as a variable).  Second, it informs the Lisp system of
@c this, optionally supplying an initial value and a documentation
@c string.  Third, it provides information to programming tools such as
@c @command{etags}, allowing them to find where the variable was defined.

  Различие между @code{defconst} и @code{defvar} в основном в декларируемом
намерении, указывающее читающему человеку предполагается ли изменение
определяемой переменной или нет. Emacs Lisp не помешает изменить переменную
объявленную с использованием @code{defconst}. Другим важным отличием
между этими формами является то, что @code{defconst} обязательно инициализирует
переменную, в то время как @code{defvar} выполняет инициализацию только,
если переменная пустая (void).

@c   The difference between @code{defconst} and @code{defvar} is mainly a
@c matter of intent, serving to inform human readers of whether the value
@c should ever change.  Emacs Lisp does not actually prevent you from
@c changing the value of a variable defined with @code{defconst}.  One
@c notable difference between the two forms is that @code{defconst}
@c unconditionally initializes the variable, whereas @code{defvar}
@c initializes it only if it is originally void.

  Для определения настраиваемой переменной, нужно использовать @code{defcustom}
(который вызывает @code{defvar} как подпрограмму). @xref{Variable Definitions}.

@c   To define a customizable variable, you should use @code{defcustom}
@c (which calls @code{defvar} as a subroutine).  @xref{Variable
@c Definitions}.

@defspec defvar symbol [value [doc-string]]
Специальная форма определяет @var{symbol} в качестве переменной.
@var{symbol} не вычисляется, поэтому symbol должен быть указан
явно в @code{defvar}. Переменная помечается как @dfn{special},
в том смысле что она должна всегда связываться динамически
(@pxref{Variable Scoping}).

@c This special form defines @var{symbol} as a variable.  Note that
@c @var{symbol} is not evaluated; the symbol to be defined should appear
@c explicitly in the @code{defvar} form.  The variable is marked as
@c @dfn{special}, meaning that it should always be dynamically bound
@c (@pxref{Variable Scoping}).

Если @var{value} задано, и @var{symbol} пуст (void) (т.е. ему
не было задано значение; @pxref{Void Variables}), тогда @var{value}
вычисляется и в @var{symbol} сохраняется результат. Но если @var{symbol}
не пуст (void), @var{value} не вычисляется, и значение @var{symbol}
остается не измененным. Если @var{value} пропущено, значение @var{symbol}
в изменяется в любом случае.

@c If @var{value} is specified, and @var{symbol} is void (i.e., it has no
@c dynamically bound value; @pxref{Void Variables}), then @var{value} is
@c evaluated and @var{symbol} is set to the result.  But if @var{symbol}
@c is not void, @var{value} is not evaluated, and @var{symbol}'s value is
@c left unchanged.  If @var{value} is omitted, the value of @var{symbol}
@c is not changed in any case.

Если @var{symbol} имеет локальное для буфера связывание в текущем
буфере, @code{defvar} взаимодействует с значением по умолчанию, которое
не зависит от буфера, а не с локальной привязкой буфера. Значение
по умолчанию устанавливается если оно пустое (void). @xref{Buffer-Local Variables}.

@c If @var{symbol} has a buffer-local binding in the current buffer,
@c @code{defvar} acts on the default value, which is buffer-independent,
@c rather than the buffer-local binding.  It sets the default value if
@c the default value is void.  @xref{Buffer-Local Variables}.

Если @var{symbol} уже лексически связан (например если @code{defvar}
выполняется в @code{let} с включенным лексическим связыванием), тогда
@code{defvar} устанавливает динамическое значение. Лексическое связывание
остается действующим пока существует соответствующая связыванию конструкция.
@xref{Variable Scoping}.

@c If @var{symbol} is already lexically bound (e.g., if the @code{defvar}
@c form occurs in a @code{let} form with lexical binding enabled), then
@c @code{defvar} sets the dynamic value.  The lexical binding remains in
@c effect until its binding construct exits.  @xref{Variable Scoping}.

При вычислении формы @code{defvar} на верхнем уровне с использованием @kbd{C-M-x}
в Emacs Lisp режиме (@code{eval-defun}), специальная возможность
@code{eval-defun} выполняет установку переменной безусловно, пропуская
проверку ну пустоту (void).

@c When you evaluate a top-level @code{defvar} form with @kbd{C-M-x} in
@c Emacs Lisp mode (@code{eval-defun}), a special feature of
@c @code{eval-defun} arranges to set the variable unconditionally, without
@c testing whether its value is void.

Если передан аргумент @var{doc-string}, то его значение становится
строкой документации для переменной (сохраняется в свойство
символа @code{variable-documentation}). @xref{Documentation}.

@c If the @var{doc-string} argument is supplied, it specifies the
@c documentation string for the variable (stored in the symbol's
@c @code{variable-documentation} property).  @xref{Documentation}.

Ниже несколько примеров. Форма определяет @code{foo}, но не инициализирует:

@c Here are some examples.  This form defines @code{foo} but does not
@c initialize it:

@example
@group
(defvar foo)
     @result{} foo
@end group
@end example

Пример инициализирует переменную @code{bar} значением @code{23}, и задает
строку документации:

@c This example initializes the value of @code{bar} to @code{23}, and gives
@c it a documentation string:

@example
@group
(defvar bar 23
  "The normal weight of a bar.")
     @result{} bar
@end group
@end example

Форма @code{defvar} возвращает @var{symbol}, но как правило используется
на верхнем уровне кода файла, и возвращаемое значение не используется.

@c The @code{defvar} form returns @var{symbol}, but it is normally used
@c at top level in a file where its value does not matter.
@end defspec

@cindex constant variables
@defspec defconst symbol value [doc-string]
Специальная форма определяет @var{symbol} в качестве переменной (константы)
и инициализирует его. Форма информирует пользователя, читающего
код, что @var{symbol} имеет общее глобальное значение, установленное
в точке определения, которое не должно меняться пользователем или
другими программами. @var{symbol} не вычисляется, поэтому его нужно
указывать явно в @code{defconst}.

@c This special form defines @var{symbol} as a value and initializes it.
@c It informs a person reading your code that @var{symbol} has a standard
@c global value, established here, that should not be changed by the user
@c or by other programs.  Note that @var{symbol} is not evaluated; the
@c symbol to be defined must appear explicitly in the @code{defconst}.

Форма @code{defconst}, как @code{defvar}, помечает переменную как
специальную, подразумевая, что она должна всегда связываться динамически
(@pxref{Variable Scoping}). В дополнение, она помечает переменную
как рискованная (risky) (@pxref{File Local Variables}).

@c The @code{defconst} form, like @code{defvar}, marks the variable as
@c @dfn{special}, meaning that it should always be dynamically bound
@c (@pxref{Variable Scoping}).  In addition, it marks the variable as
@c risky (@pxref{File Local Variables}).

@code{defconst} всегда вычисляет @var{value}, сохраняет результат
в ячейку значения @var{symbol}. Если @var{symbol} имеет локальное для
буфера значение в текущем буфере, @code{defconst} устанавливает
дефолтное значение, а не локальное для буфера. (Но не стоит
делать локальными для буфера переменные, которые определяется
с использованием @code{defconst}.)

@c @code{defconst} always evaluates @var{value}, and sets the value of
@c @var{symbol} to the result.  If @var{symbol} does have a buffer-local
@c binding in the current buffer, @code{defconst} sets the default value,
@c not the buffer-local value.  (But you should not be making
@c buffer-local bindings for a symbol that is defined with
@c @code{defconst}.)

Пример использования @code{defconst} в Emacs, определение @code{float-pi}---
математической константы @math{pi}, которая никогда не должна изменяться.
Как видно из второй формы, @code{defconst} носит рекомендательный характер,
и определенные таким образом константы могут быть изменены.

@c An example of the use of @code{defconst} is Emacs's definition of
@c @code{float-pi}---the mathematical constant @math{pi}, which ought not
@c to be changed by anyone (attempts by the Indiana State Legislature
@c notwithstanding).  As the second form illustrates, however,
@c @code{defconst} is only advisory.

@example
@group
(defconst float-pi 3.141592653589793 "The value of Pi.")
     @result{} float-pi
@end group
@group
(setq float-pi 3)
     @result{} float-pi
@end group
@group
float-pi
     @result{} 3
@end group
@end example
@end defspec

  @strong{Внимание:} Если использовать @code{defconst} или @code{defvar}
пока переменная имеет локальную привязку (выполненную с использованием
@code{let}, или аргументом функции), будет установлена локальная
привязка, а не глобальная. Как правило это не то, что нужно. Чтобы
этого избежать, стоит использовать эти формы на верхнем уровне файла,
где как правило нет локальных связок, и проверить, что загрузка файла выполняется, до
создания локальных связываний для этих переменных.

@c   @strong{Warning:} If you use a @code{defconst} or @code{defvar}
@c special form while the variable has a local binding (made with
@c @code{let}, or a function argument), it sets the local binding rather
@c than the global binding.  This is not what you usually want.  To
@c prevent this, use these special forms at top level in a file, where
@c normally no local binding is in effect, and make sure to load the file
@c before making a local binding for the variable.

@node Tips for Defining
@section Советы По Надежному Определению Переменных

  При определении переменных чьи имена функции или
списки функций стоит использовать имена оканчивающиеся на
@samp{-function} или @samp{-functions}, соответственно.

@c   When you define a variable whose value is a function, or a list of
@c functions, use a name that ends in @samp{-function} or
@c @samp{-functions}, respectively.

  Ниже приводится еще несколько соглашений:

@c   There are several other variable name conventions;
@c here is a complete list:

@table @samp
@item @dots{}-hook
Переменная обыкновенный (normal) перехватчик
(@pxref{Hooks}).
@c The variable is a normal hook (@pxref{Hooks}).

@item @dots{}-function
Значение является функцией.
@c The value is a function.

@item @dots{}-functions
Значение является списком функций.
@c The value is a list of functions.

@item @dots{}-form
Значение является формой (выражением).
@c The value is a form (an expression).

@item @dots{}-forms
Значение является списком форм (выражений).
@c The value is a list of forms (expressions).

@item @dots{}-predicate
Значение является предикатом---функцией с одним аргументом, которая
возвращает не-@code{nil} в случае успеха и @code{nil} в случае не успеха.
@c The value is a predicate---a function of one argument that returns
@c non-@code{nil} for success and @code{nil} for failure.

@item @dots{}-flag
От значения требуется только проверка на @code{nil}. Так как
для таких переменных в последствии важными становится больше
значение данное соглашение не сильно рекомендуется.
@c The value is significant only as to whether it is @code{nil} or not.
@c Since such variables often end up acquiring more values over time,
@c this convention is not strongly recommended.

@item @dots{}-program
Значение является именем программы.
@c The value is a program name.

@item @dots{}-command
Значение является полной командой оболочки (bash, ...).
@c The value is a whole shell command.

@item @dots{}-switches
Значение задает опции команды.
@c The value specifies options for a command.
@end table

  При определении переменной, всегда стоит рассмотреть возможность ее
пометить как безопасную или рискованную; см. @ref{File Local Variables}.

@c   When you define a variable, always consider whether you should mark
@c it as safe or risky; see @ref{File Local Variables}.

  Когда определяется и инициализируется переменная, которая хранить сложное
значение (такое как комбинация клавиш с привязкой к ним), стоит
поместить вычисление значения в @code{defvar}, таким образом:

@c   When defining and initializing a variable that holds a complicated
@c value (such as a keymap with bindings in it), it's best to put the
@c entire computation of the value into the @code{defvar}, like this:

@example
(defvar my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    @dots{}
    map)
  @var{docstring})
@end example

@noindent
Этот метод имеет несколько преимущества. Первое, если пользователь
выйдет в процессе загрузки файла, переменная будет не инициализирована
или полностью инициализирована, и не будет промежуточного состояния.
Если переменная не инициализирована, то при перезагрузки
файла она будет инициализирована. Второе, перезагрузка файла, при
инициализированной переменной не будет ее изменять, это важно
если пользователь запускает перехватчик для изменения части
содержимого, например изменения привязок клавиш. Третье, вычисление
формы @code{defvar} с использованием @kbd{C-M-x} приведет к переинициализации
map полностью.

@c This method has several benefits.  First, if the user quits while
@c loading the file, the variable is either still uninitialized or
@c initialized properly, never in-between.  If it is still uninitialized,
@c reloading the file will initialize it properly.  Second, reloading the
@c file once the variable is initialized will not alter it; that is
@c important if the user has run hooks to alter part of the contents
@c (such as, to rebind keys).  Third, evaluating the @code{defvar} form
@c with @kbd{C-M-x} will reinitialize the map completely.

  Помещения большого количества кода в @code{defvar} имеет и недостатки:
строка документации помещается далеко от имени переменной. Ниже безопасный
способ избежать этого:

@c   Putting so much code in the @code{defvar} form has one disadvantage:
@c it puts the documentation string far away from the line which names the
@c variable.  Here's a safe way to avoid that:

@example
(defvar my-mode-map nil
  @var{docstring})
(unless my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    @dots{}
    (setq my-mode-map map)))
@end example

@noindent
Данный метод имеет те же преимущества, что и инициализация внутри
@code{defvar}, за исключением того, что нужно вводить @kbd{C-M-x} дважды,
по одному разу для каждой формы, чтобы переинициализировать переменную.

@c This has all the same advantages as putting the initialization inside
@c the @code{defvar}, except that you must type @kbd{C-M-x} twice, once on
@c each form, if you do want to reinitialize the variable.

@node Accessing Variables
@section Доступ к Значению Переменной

  Обычный способ сослаться на переменную, просто написать символ
который хранит значение этой переменной. @xref{Symbol Forms}.

@c   The usual way to reference a variable is to write the symbol which
@c names it.  @xref{Symbol Forms}.

  Изредка, нужно ссылаться на переменные, который определяются во
время выполнения. В этом случае, нет возможности указать имя. Нужно
использовать функцию @code{symbol-value} для получения значения.

@c   Occasionally, you may want to reference a variable which is only
@c determined at run time.  In that case, you cannot specify the variable
@c name in the text of the program.  You can use the @code{symbol-value}
@c function to extract the value.

@defun symbol-value symbol
Функция возвращает значение хранящееся в ячейки значения символа @var{symbol}.
Это место где хранится текущее (динамическое) значение. Если переменная
не локальная, то это просто глобальная переменная. Если переменная
пустая (void), сигнализируется @code{void-variable} ошибка.

@c This function returns the value stored in @var{symbol}'s value cell.
@c This is where the variable's current (dynamic) value is stored.  If
@c the variable has no local binding, this is simply its global value.
@c If the variable is void, a @code{void-variable} error is signaled.

Если переменная имеет лексическое связывание, значение возращаемое
@code{symbol-value}  не обязательно то же, что лексическое значение,
которое определяется лексическим окружением, а не ячейкой значения
символа. @xref{Variable Scoping}.

@c If the variable is lexically bound, the value reported by
@c @code{symbol-value} is not necessarily the same as the variable's
@c lexical value, which is determined by the lexical environment rather
@c than the symbol's value cell.  @xref{Variable Scoping}.

@example
@group
(setq abracadabra 5)
     @result{} 5
@end group
@group
(setq foo 9)
     @result{} 9
@end group

@group
;; @r{Here the symbol @code{abracadabra}}
;;   @r{is the symbol whose value is examined.}
(let ((abracadabra 'foo))
  (symbol-value 'abracadabra))
     @result{} foo
@end group

@group
;; @r{Here, the value of @code{abracadabra},}
;;   @r{which is @code{foo},}
;;   @r{is the symbol whose value is examined.}
(let ((abracadabra 'foo))
  (symbol-value abracadabra))
     @result{} 9
@end group

@group
(symbol-value 'abracadabra)
     @result{} 5
@end group
@end example
@end defun

@node Setting Variables
@section Установка Значений Переменной

  Стандартный способ изменить значение переменной использовать
специальную форму @code{setq}. Когда нужно вычислить переменную
во время выполнения, стоит использовать функцию @code{set}.

@c   The usual way to change the value of a variable is with the special
@c form @code{setq}.  When you need to compute the choice of variable at
@c run time, use the function @code{set}.

@defspec setq [symbol form]@dots{}
Специальная формы, являющаяся стандартным способом изменения значения
переменной. Каждый @var{symbol} получает новое значение, являющееся
результатом вычисления соответствующей @var{form}. Изменяется текущее
значение (связывание) символа.

@c This special form is the most common method of changing a variable's
@c value.  Each @var{symbol} is given a new value, which is the result of
@c evaluating the corresponding @var{form}.  The current binding of the
@c symbol is changed.

@code{setq} не вычисляет @var{symbol}. Такой аргумент называется
автоматически квотированным(заковычиным) @dfn{automatically quoted}.
@samp{q} в @code{setq} указывает на ``quoted'' (заковыченный).

@c @code{setq} does not evaluate @var{symbol}; it sets the symbol that you
@c write.  We say that this argument is @dfn{automatically quoted}.  The
@c @samp{q} in @code{setq} stands for ``quoted''.

Значение формы @code{setq} значение последней @var{form}.

@c The value of the @code{setq} form is the value of the last @var{form}.

@example
@group
(setq x (1+ 2))
     @result{} 3
@end group
x                   ; @r{@code{x} now has a global value.}
     @result{} 3
@group
(let ((x 5))
  (setq x 6)        ; @r{The local binding of @code{x} is set.}
  x)
     @result{} 6
@end group
x                   ; @r{The global value is unchanged.}
     @result{} 3
@end example

При вычислении вычисляется первая @var{form}, затем устанавливается
значение первого @var{symbol}, затем второй @var{form} вычисляется,
после чего устанавливается второй @var{symbol} и так далее:

@c Note that the first @var{form} is evaluated, then the first
@c @var{symbol} is set, then the second @var{form} is evaluated, then the
@c second @var{symbol} is set, and so on:

@example
@group
(setq x 10          ; @r{Notice that @code{x} is set before}
      y (1+ x))     ;   @r{the value of @code{y} is computed.}
     @result{} 11
@end group
@end example
@end defspec

@defun set symbol value
Функция помещает @var{value} в ячейку значения @var{symbol}.
Так как это функция, а не специальная формы, выражение
записанное в @var{symbol} вычисляется, для получения символа.
Функция возвращает @var{value}.

@c This function puts @var{value} in the value cell of @var{symbol}.
@c Since it is a function rather than a special form, the expression
@c written for @var{symbol} is evaluated to obtain the symbol to set.
@c The return value is @var{value}.

Когда работает правило динамического связывания (по умолчанию),
@code{set} действует так же как @var{setq}, за исключением того, что
вычисляет @var{symbol}. Но если включено лексическое связывание @code{set},
изменяет @emph{динамическое} (@emph{dynamic}) значение, в то время как
@code{setq} изменяет текущее (лексическое) значение. @xref{Variable Scoping}.

@c When dynamic variable binding is in effect (the default), @code{set}
@c has the same effect as @code{setq}, apart from the fact that
@c @code{set} evaluates its @var{symbol} argument whereas @code{setq}
@c does not.  But when a variable is lexically bound, @code{set} affects
@c its @emph{dynamic} value, whereas @code{setq} affects its current
@c (lexical) value.  @xref{Variable Scoping}.

@example
@group
(set one 1)
@error{} Symbol's value as variable is void: one
@end group
@group
(set 'one 1)
     @result{} 1
@end group
@group
(set 'two 'one)
     @result{} one
@end group
@group
(set two 2)         ; @r{@code{two} evaluates to symbol @code{one}.}
     @result{} 2
@end group
@group
one                 ; @r{So it is @code{one} that was set.}
     @result{} 2
(let ((one 1))      ; @r{This binding of @code{one} is set,}
  (set 'one 3)      ;   @r{not the global value.}
  one)
     @result{} 3
@end group
@group
one
     @result{} 2
@end group
@end example

Если @var{symbol} не символ, сигнализируется ошибка @code{wrong-type-argument}.

@c If @var{symbol} is not actually a symbol, a @code{wrong-type-argument}
@c error is signaled.

@example
(set '(x y) 'z)
@error{} Wrong type argument: symbolp, (x y)
@end example
@end defun

@node Variable Scoping
@section Правила Видимости для Связывания Переменных
@cindex scoping rule

  При создании локального связывания для переменной, связывание
действует только внутри ограниченной области программы (@pxref{Local Variables}).
Данная секция описывает, что это значит.

@c   When you create a local binding for a variable, that binding takes
@c effect only within a limited portion of the program (@pxref{Local
@c Variables}).  This section describes exactly what this means.

@cindex scope
@cindex extent
  Каждое локальное связывание имеет @dfn{окружение} (@dfn{scope}) и
@dfn{область} (@dfn{extent}).
@dfn{Окружение} определяет @emph{где} в текстовом представлении
кода будет доступно связывание. @dfn{Область} определяет @empth{когда},
при выполнении программы, связывание существует.

@c   Each local binding has a certain @dfn{scope} and @dfn{extent}.
@c @dfn{Scope} refers to @emph{where} in the textual source code the
@c binding can be accessed.  @dfn{Extent} refers to @emph{when}, as the
@c program is executing, the binding exists.

@cindex dynamic binding
@cindex dynamic scope
@cindex dynamic extent
  По умолчанию, локальное связывание в Emaacs @dfn{динамическое связывание}
(@dfn{dynamic bindings}). Такое связывание имеет @dfn{динамическое окружение}
(@dfn{dynamic scope}), в том смысле что, любая часть программы потенциально
может получить доступ к связыванию. Такое связывание имеет @dfn{динамическую область} (@dfn{dynamic extent}),
подразумевая, что связывание исчезает как только определенная
конструкция (такая как тело @code{let}) будет выполнено.

@c   By default, the local bindings that Emacs creates are @dfn{dynamic
@c bindings}.  Such a binding has @dfn{dynamic scope}, meaning that any
@c part of the program can potentially access the variable binding.  It
@c also has @dfn{dynamic extent}, meaning that the binding lasts only
@c while the binding construct (such as the body of a @code{let} form) is
@c being executed.

@cindex lexical binding
@cindex lexical scope
@cindex indefinite extent
  Еmacs может создавать @dfn{лексическое связывание} (@dfn{lexical bindings}).
Лексическое связывание имеет @dfn{лексическое окружение} (@dfn{lexical scope}),
подразумевая, что все ссылки на переменную должны быть внутри
конструкции связывания @footnote{С некоторыми исключениями, например,
доступ к лексическому связыванию (лексической переменной) возможен
из отладчика}. Лексическое связывание имеет @dfn{бесконечную область} (@dfn{indefinite extent}), подразумевая, что с некоторыми условиями связывание может существовать
неограниченное время после того, как конструкция связывания будет выполнена,
с помощью специального объекта @dfn{замыкания} (@dfn{closures}).

@c   Emacs can optionally create @dfn{lexical bindings}.  A lexical
@c binding has @dfn{lexical scope}, meaning that any reference to the
@c variable must be located textually within the binding
@c construct@footnote{With some exceptions; for instance, a lexical
@c binding can also be accessed from the Lisp debugger.}.  It also has
@c @dfn{indefinite extent}, meaning that under some circumstances the
@c binding can live on even after the binding construct has finished
@c executing, by means of special objects called @dfn{closures}.

  Следующие подразделы описывают динамическое и лексическое связывание
более подробно, и способ включения лексического связывания в программах
Emacs Lisp.

@c   The following subsections describe dynamic binding and lexical
@c binding in greater detail, and how to enable lexical binding in Emacs
@c Lisp programs.

@menu
* Dynamic Binding::         Способ связывания локальных переменных в Emacs Lisp по умолчанию.
* Dynamic Binding Tips::    Как избежать проблем с динамическим связыванием.
* Lexical Binding::         Другой способ связывания локальных переменных.
* Using Lexical Binding::   Как включить лексическое связывание.
@end menu

@node Dynamic Binding
@subsection Динамическое Связывание

  По умолчанию, локальные переменные имеют динамическое связывание.
Когда переменная динамически связана, текущее связывание в любой точке
выполнения Lisp программы это просто последнее локальное связывание
для символа переменной, или глобальное связывание, если локального нет.

@c   By default, the local variable bindings made by Emacs are dynamic
@c bindings.  When a variable is dynamically bound, its current binding
@c at any point in the execution of the Lisp program is simply the most
@c recently-created dynamic local binding for that symbol, or the global
@c binding if there is no such local binding.

  Динамическое связывание имеет динамическое окружение и область (scope and extent),
как показывается в следующем примере:
@c   Dynamic bindings have dynamic scope and extent, as shown by the
@c following example:

@example
@group
(defvar x -99)  ; @r{@code{x} receives an initial value of @minus{}99.}

(defun getx ()
  x)            ; @r{@code{x} is used free in this function.}

(let ((x 1))    ; @r{@code{x} is dynamically bound.}
  (getx))
     @result{} 1

;; @r{After the @code{let} form finishes, @code{x} reverts to its}
;; @r{previous value, which is @minus{}99.}

(getx)
     @result{} -99
@end group
@end example

@noindent
Функция @code{getx} ссылается на @code{x}. Это @dfn{свободная} (@dfn{free})
ссылка, в том смысле, что нет связывания для @code{x} внутри конструкции
@code{defun}. При вызове @code{getx} внутри @code{let} в которой
@code{x} (динамически) связана, она получает локально значение (1). Но
при вызове @code{getx} вне формы @code{let}, она получает глобальное
значение (@minus{}99).

@c The function @code{getx} refers to @code{x}.  This is a @dfn{free}
@c reference, in the sense that there is no binding for @code{x} within
@c that @code{defun} construct itself.  When we call @code{getx} from
@c within a @code{let} form in which @code{x} is (dynamically) bound, it
@c retrieves the local value (i.e., 1).  But when we call @code{getx}
@c outside the @code{let} form, it retrieves the global value (i.e.,
@c @minus{}99).

  Ниже другой пример, показывающий установку динамически связанной
переменной с использованием @code{setq}:

@c   Here is another example, which illustrates setting a dynamically
@c bound variable using @code{setq}:

@example
@group
(defvar x -99)      ; @r{@code{x} receives an initial value of @minus{}99.}

(defun addx ()
  (setq x (1+ x)))  ; @r{Add 1 to @code{x} and return its new value.}

(let ((x 1))
  (addx)
  (addx))
     @result{} 3           ; @r{The two @code{addx} calls add to @code{x} twice.}

;; @r{After the @code{let} form finishes, @code{x} reverts to its}
;; @r{previous value, which is @minus{}99.}

(addx)
     @result{} -98
@end group
@end example

  Динамическое связывание в Emacs Lisp реализовано просто. Каждый
символ имеет ячейку значения, которая определяет текущее динамическое
значение (или отсутствие значения). @xref{Symbol Components}. Когда
символ получает локальное связывание, Emacs сохраняет содержимое
ячейки значения (или отсутствие значения) в стек, и сохраняет новое
значение в ячейку значения. Когда конструкция со связыванием завершает
выполнение, Emacs извлекает старое значение из стека, и помещает
его с ячейку значения.

@c   Dynamic binding is implemented in Emacs Lisp in a simple way.  Each
@c symbol has a value cell, which specifies its current dynamic value (or
@c absence of value).  @xref{Symbol Components}.  When a symbol is given
@c a dynamic local binding, Emacs records the contents of the value cell
@c (or absence thereof) in a stack, and stores the new local value in the
@c value cell.  When the binding construct finishes executing, Emacs pops
@c the old value off the stack, and puts it in the value cell.

@node Dynamic Binding Tips
@subsection Правильное Использование Динамического Связывания

  Динамическое связывания является мощной особенностью, и позволяет
программам ссылаться на переменные которые определены внутри локальной
области(local textual scope). Но, использование без ограничений может
привести к тому, что программу будет трудно понять. Ниже описывается
два способа правильного использования:

@c   Dynamic binding is a powerful feature, as it allows programs to
@c refer to variables that are not defined within their local textual
@c scope.  However, if used without restraint, this can also make
@c programs hard to understand.  There are two clean ways to use this
@c technique:

@itemize @bullet
@item
Если переменная не имеет глобального определения, стоит использовать
ее только внутри конструкций связывания, таких как тело
@code{let} в котором переменная была связана. Если придерживаться
этого соглашения, значение переменной не будет влиять, или не будет
затронуто, другими использованиями данной переменной в других частях
программы.

@c If a variable has no global definition, use it as a local variable
@c only within a binding construct, such as the body of the @code{let}
@c form where the variable was bound.  If this convention is followed
@c consistently throughout a program, the value of the variable will not
@c affect, nor be affected by, any uses of the same variable symbol
@c elsewhere in the program.

@item
Иначе, переменную стоит определить с @code{defvar}, @code{defconst} или
@code{defcustom}. @xref{Definition Variables}. Как правило, определение
должно быть на верхнем уровне кода в файле. Желательно, чтобы определение
содержало документацию с описанием назначения переменной. Стоит выбирать
имя таким образом, чтобы избежать конфликтов имен (@xref{Coding Conventions}).

@c Otherwise, define the variable with @code{defvar}, @code{defconst}, or
@c @code{defcustom}.  @xref{Defining Variables}.  Usually, the definition
@c should be at top-level in an Emacs Lisp file.  As far as possible, it
@c should include a documentation string which explains the meaning and
@c purpose of the variable.  You should also choose the variable's name
@c to avoid name conflicts (@pxref{Coding Conventions}).

После этого можно выполнять связывание переменной в любом месте программы,
точно зная какой будет эффект. В местах встречи с переменной можно
легко найти определение, например через @kbd{C-h v} (предоставляет
определение переменной которая загружена в Emacs).
@xref{Name Help,,, emacs, The Gnu Emacs Manual}.

@c Then you can bind the variable anywhere in a program, knowing reliably
@c what the effect will be.  Wherever you encounter the variable, it will
@c be easy to refer back to the definition, e.g., via the @kbd{C-h v}
@c command (provided the variable definition has been loaded into Emacs).
@c @xref{Name Help,,, emacs, The GNU Emacs Manual}.

Например, стандартный способ изменения связывания настраиваемой
переменной наподобие @code{case-fold-search}:

@c For example, it is common to use local bindings for customizable
@c variables like @code{case-fold-search}:

@example
@group
(defun search-for-abc ()
  "Search for the string \"abc\", ignoring case differences."
  (let ((case-fold-search nil))
    (re-search-forward "abc")))
@end group
@end example
@end itemize

@node Lexical Binding
@subsection Лексическое Связывание

  Лексическое связывание добавлено в Emacs, как не обязательная возможность,
в версии 24.1. Ожидается, что со временем ее важность возрастет. Лексическое
связывание открывает много возможностей для оптимизации, поэтому
программы использующие его могут стать более быстрыми в последующих версиях
Emacs. Лексическое связывание более совместимо с параллельным выполнением,
которое хочется добавить в Emacs.

@c   Lexical binding was introduced to Emacs, as an optional feature, in
@c version 24.1.  We expect its importance to increase in the future.
@c Lexical binding opens up many more opportunities for optimization, so
@c programs using it are likely to run faster in future Emacs versions.
@c Lexical binding is also more compatible with concurrency, which we
@c want to add to Emacs in the future.

  Лексически связанная переменная имеет @dfn{лексическую область действия}
(@dfn{lexixal scope}), подразумевая, что код ссылающийся на переменную
должен быть внутри конструкции связывания. Ниже пример:

@c   A lexically-bound variable has @dfn{lexical scope}, meaning that any
@c reference to the variable must be located textually within the binding
@c construct.  Here is an example
@iftex
@c (see the next subsection, for how to actually enable lexical binding):
(как включить лексическое связывание описано в следующей подсекции):
@end iftex
@ifnottex
(как включить лексическое связывание @pxref{Using Lexical Binding}):
@c(@pxref{Using Lexical Binding}, for how to actually enable lexical binding):
@end ifnottex

@example
@group
(let ((x 1))    ; @r{@code{x} is lexically bound.}
  (+ x 3))
     @result{} 4

(defun getx ()
  x)            ; @r{@code{x} is used free in this function.}

(let ((x 1))    ; @r{@code{x} is lexically bound.}
  (getx))
@error{} Symbol's value as variable is void: x
@end group
@end example

@noindent
Здесь, переменная @code{x} не имеет глобального значения. Когда переменная
лексически связана внутри @code{let}, она может использоваться в коде
находящемся внутри @code{let} формы. Но она @emph{не} может использоваться
внутри функции @code{getx} вызываемой из @code{let} формы, так как определение
функции @code{getx} находится вне @code{let} формы.

@c Here, the variable @code{x} has no global value.  When it is lexically
@c bound within a @code{let} form, it can be used in the textual confines
@c of that @code{let} form.  But it can @emph{not} be used from within a
@c @code{getx} function called from the @code{let} form, since the
@c function definition of @code{getx} occurs outside the @code{let} form
@c itself.

@cindex lexical environment
  Лексическое связывание работает следующим образом. Каждая конструкция
связывания определяет @dfn{лексическое окружение} (@dfn{lexical environment}),
определяющее переменные которые связаны внутри конструкции и их локальные значения.
Когда Lisp вычислителю нужно получить текущее значение переменной, значение
сначала ищется в лексическом окружении, и если в нем переменная не задана
смотрится ячейка значения символа, где хранится динамическое значение.

@c   Here is how lexical binding works.  Each binding construct defines a
@c @dfn{lexical environment}, specifying the variables that are bound
@c within the construct and their local values.  When the Lisp evaluator
@c wants the current value of a variable, it looks first in the lexical
@c environment; if the variable is not specified in there, it looks in
@c the symbol's value cell, where the dynamic value is stored.

  (Лексическое окружение представляет из себя alist с парами символ-значение,
с финальным элемента символом @code{t}, а не cons ячейкой. Такой alist может
быть передан в качестве второго аргумента в функцию  @code{eval}, если нужно
задать лексическое окружение для вычисления формы. @xref{Eval}. Большинство
программ Emacs Lisp, однако, не работают напрямую с лексическим окружением таким
образом, только специализированные программы наподобие отладчиков.)

@c   (Internally, the lexical environment is an alist of symbol-value
@c pairs, with the final element in the alist being the symbol @code{t}
@c rather than a cons cell.  Such an alist can be passed as the second
@c argument to the @code{eval} function, in order to specify a lexical
@c environment in which to evaluate a form.  @xref{Eval}.  Most Emacs
@c Lisp programs, however, should not interact directly with lexical
@c environments in this way; only specialized programs like debuggers.)

@cindex closures, example of using
  Лексическое связывание имеет неограниченное время жизни (indefinite extent).
Даже после того как конструкция связывания закончит выполнение, лексическое
окружение может быть ``сохранено'' (``kept around'') внутри Lisp объектов
называемых @dfn{замыканиями} (@dfn{closures}). Замыкание создается
при создании именованной или анонимной функции когда включено
лексическое связывание. Подробнее @xref{Closures}.

@c   Lexical bindings have indefinite extent.  Even after a binding
@c construct has finished executing, its lexical environment can be
@c ``kept around'' in Lisp objects called @dfn{closures}.  A closure is
@c created when you define a named or anonymous function with lexical
@c binding enabled.  @xref{Closures}, for details.

  При вызове замыкания как функции, ссылки на лексические переменные
из определения будут использовать сохраненное лексическое окружение.
Например:

@c   When a closure is called as a function, any lexical variable
@c references within its definition use the retained lexical environment.
@c Here is an example:

@example
(defvar my-ticker nil)   ; @r{We will use this dynamically bound}
                         ; @r{variable to store a closure.}

(let ((x 0))             ; @r{@code{x} is lexically bound.}
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
    @result{} (closure ((x . 0) t) ()
          (setq x (1+ x)))

(funcall my-ticker)
    @result{} 1

(funcall my-ticker)
    @result{} 2

(funcall my-ticker)
    @result{} 3

x                        ; @r{Note that @code{x} has no global value.}
@error{} Symbol's value as variable is void: x
@end example

@noindent
Связывание @code{let} определяет лексическое окружение в котором
переменная @code{х} локально связана с 0. Внутри этой конструкции
определяется лямбда(lambda) выражение которое увеличивает @code{х}
на один и возвращает увеличенное значение. Это лямбда выражение
автоматически становится замыканием, в котором лексическое окружение
существует даже после того как конструкция @code{let} связывания завершится.
Каждый раз при вычислении замыкания, оно увеличивает @code{x}, используя
связывания @code{x} из лексического окружения.

@c The @code{let} binding defines a lexical environment in which the
@c variable @code{x} is locally bound to 0.  Within this binding
@c construct, we define a lambda expression which increments @code{x} by
@c one and returns the incremented value.  This lambda expression is
@c automatically turned into a closure, in which the lexical environment
@c lives on even after the @code{let} binding construct has exited.  Each
@c time we evaluate the closure, it increments @code{x}, using the
@c binding of @code{x} in that lexical environment.

  В отличие от динамических переменных, которые привязаны к объекту
символа, отношение между лексическими переменными и символами
представлено только в интерпретаторе (или компиляторе). Таким образом,
функции которые принимают символ в качестве аргумента (такие как
@code{symbol-value}, @code{boundp} и @code{set}) могут получить или
изменить только динамические связывания (т.е. содержимое
ячейки значения символа).

@c   Note that unlike dynamic variables which are tied to the symbol
@c object itself, the relationship between lexical variables and symbols
@c is only present in the interpreter (or compiler).  Therefore,
@c functions which take a symbol argument (like @code{symbol-value},
@c @code{boundp}, and @code{set}) can only retrieve or modify a
@c variable's dynamic binding (i.e., the contents of its symbol's value
@c cell).

@node Using Lexical Binding
@subsection Использование Лексического Связывания

  При загрузки Emacs Lisp файла или вычислении буфера с Lisp кодом,
лексическое связывание включено, если локальная для буфера переменная
@code{lexical-binding} не-@code{nil}:

@c   When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical
@c binding is enabled if the buffer-local variable @code{lexical-binding}
@c is non-@code{nil}:

@defvar lexical-binding
Если локальная для буфера переменная не-@code{nil}, Emacs Lisp файлы и
буферы вычисляются с использованием лексического связывания вместо динамического.
(Но специальные переменные, все еще связываются динамически; см. ниже.)
Если @code{nil}, для всех локальных переменных используется динамическое
связывание. Переменная как правило устанавливается для всего Emacs Lisp
файла, как локальная для файла переменная (@pxref{File Local Variables}).
В отличие от других таких переменных, данная переменная должна быть
установлена в первой строке файла.

@c If this buffer-local variable is non-@code{nil}, Emacs Lisp files and
@c buffers are evaluated using lexical binding instead of dynamic
@c binding.  (However, special variables are still dynamically bound; see
@c below.)  If @code{nil}, dynamic binding is used for all local
@c variables.  This variable is typically set for a whole Emacs Lisp
@c file, as a file local variable (@pxref{File Local Variables}).
@c Note that unlike other such variables, this one must be set in the
@c first line of a file.
@end defvar

@noindent
При вычислении Emacs Lisp кода напрямую с использованием @code{eval},
лексическое связывание включается если @var{lexical} аргумент
для @code{eval} не-@code{nil}. @xref{Eval}.

@c When evaluating Emacs Lisp code directly using an @code{eval} call,
@c lexical binding is enabled if the @var{lexical} argument to
@c @code{eval} is non-@code{nil}.  @xref{Eval}.

@cindex special variables
  Даже когда включено лексическое связывание, некоторые переменные
продолжают быть динамически связываемыми. Такие переменные называются
@dfn{специальными переменными} (@dfn{special variables}). Все переменные
объявленные с использованием @code{defvar}, @code{devcustom}, @code{defconst}
являются специальными переменными (@pxref{Defining Variables}). Все другие
переменные могут использоваться для лексического связывания.

@c   Even when lexical binding is enabled, certain variables will
@c continue to be dynamically bound.  These are called @dfn{special
@c variables}.  Every variable that has been defined with @code{defvar},
@c @code{defcustom} or @code{defconst} is a special variable
@c (@pxref{Defining Variables}).  All other variables are subject to
@c lexical binding.

@defun special-variable-p symbol
Функция возвращает не-@code{nil} если @var{symbol} является специальной
переменной (т.е. имеет @code{defvar}, @code{defcustom}, @code{defconst} определение).
Иначе возвращается @code{nil}.

@c This function returns non-@code{nil} if @var{symbol} is a special
@c variable (i.e., it has a @code{defvar}, @code{defcustom}, or
@c @code{defconst} variable definition).  Otherwise, the return value is
@c @code{nil}.
@end defun

  Использование специальной переменной в качестве формального аргумента
не рекомендуется. Так как это приводит к не ясному поведению когда
используется режим с лексическим связыванием (иногда может быть
использовано лексическое связывание, иногда динамическое).

@c   The use of a special variable as a formal argument in a function is
@c discouraged.  Doing so gives rise to unspecified behavior when lexical
@c binding mode is enabled (it may use lexical binding sometimes, and
@c dynamic binding other times).

  Преобразование программы Emacs Lisp в вариант с лексическим связыванием
довольно простое. Сначала нужно добавить локальную для файла переменную
@code{lexical-binding} со значение @code{t} в начальную строку Emacs Lisp
файла (@pxref{File Local Variables}). Во вторых, проверить что все переменные
которые должны связываться динамически имеют определение, чтобы
они случайно не были связаны лексически.

@c   Converting an Emacs Lisp program to lexical binding is easy.  First,
@c add a file-local variable setting of @code{lexical-binding} to
@c @code{t} in the header line of the Emacs Lisp source file (@pxref{File
@c Local Variables}).  Second, check that every variable in the program
@c which needs to be dynamically bound has a variable definition, so that
@c it is not inadvertently bound lexically.

@cindex free variable
@cindex unused lexical variable
  Простой способ определить каким переменным нужно определение является
файл результат байт компиляции. @xref{Byte Compilation}. Если
не-специальная переменная связана но не используется внутри
@code{let} формы, байт-компилятор выдаст предупреждение о
не используемое лексической переменной. Байт-компилятор так же
выдаст предупреждение при использовании специальной переменной
в качестве аргумента функции.

@c   A simple way to find out which variables need a variable definition
@c is to byte-compile the source file.  @xref{Byte Compilation}.  If a
@c non-special variable is used outside of a @code{let} form, the
@c byte-compiler will warn about reference or assignment to a free
@c variable.  If a non-special variable is bound but not used within a
@c @code{let} form, the byte-compiler will warn about an unused lexical
@c variable.  The byte-compiler will also issue a warning if you use a
@c special variable as a function argument.

  (Чтобы байт-компилятор вы выдавал предупреждение об не используемой
переменной, можно использовать переменную с именем начинающемся с подчеркивания.
Байт-компилятор считает что известно о не исползуемости этих переменных.)

@c   (To silence byte-compiler warnings about unused variables, just use
@c a variable name that start with an underscore.  The byte-compiler
@c interprets this as an indication that this is a variable known not to
@c be used.)

@node Buffer-Local Variables
@section Локальные для Буфера Переменные
@cindex variable, buffer-local
@cindex buffer-local variables

  Глобальные и локальные связывания переменных есть в большинстве
языков программирования. Emacs, однако, поддерживает
дополнительные, не стандартные виды связывания переменных, такие
как @dfn{локальные для буфера} (@@dfn{buffer-local}) связывания, которые
применяются только в одном буфере. Наличие разных переменных в разных буферах
является важным методом настройки. (Переменные могут иметь связывания
которые локальны для каждого терминала. @xref{Multiple Terminals}.)

@c   Global and local variable bindings are found in most programming
@c languages in one form or another.  Emacs, however, also supports
@c additional, unusual kinds of variable binding, such as
@c @dfn{buffer-local} bindings, which apply only in one buffer.  Having
@c different values for a variable in different buffers is an important
@c customization method.  (Variables can also have bindings that are
@c local to each terminal.  @xref{Multiple Terminals}.)

@menu
* Intro to Buffer-Local::       Введение и концепция.
* Creating Buffer-Local::       Создания и удаление локальных для буфера привязок.
* Default Value::               Значение по умолчанию отображаемое если у буфера не своего
                                собственного локального для буфера значения.
@end menu

@node Intro to Buffer-Local
@subsection Введение в локальные для буфера переменные

  Локальная для буфера переменная имеет локальное связывание
ассоциированное с определенным буфером. То есть связывание действует, только
пока буфер является текущим. Если значение устанавливается пока связывание
действует (буфер является текущим), новое значение будет применено к этому
связыванию, то есть изменение будет применено только к текущему буферу.

  Обычные связывания, которые не ассоциированы с каким-то определенным
буфером, называются @dfn{связывания по умолчанию} (@dfn{default binding}).
В большинстве случаев, это глобальные связывания.

@c   The variable's ordinary binding, which is not associated with any
@c specific buffer, is called the @dfn{default binding}.  In most cases,
@c this is the global binding.

  Переменная может иметь локальное для буфера связывание в одних буферах
и не быть локально связанной в других. Значение по умолчанию разделяется
всеми буферами, кроме тех что имеют свои собственные связывания.
(Это относится и ко всем создаваемым буферам.) Если установить значение
переменной в буфере, который не имеет такой локальной переменной, установится
связывание по умолчанию, и новое значение будет видно во всех буферах
которые видели исходное значение.

@c   A variable can have buffer-local bindings in some buffers but not in
@c other buffers.  The default binding is shared by all the buffers that
@c don't have their own bindings for the variable.  (This includes all
@c newly-created buffers.)  If you set the variable in a buffer that does
@c not have a buffer-local binding for it, this sets the default binding,
@c so the new value is visible in all the buffers that see the default
@c binding.

  Основное применение локальных для буфера переменных в основных режимах
для изменения переменных управляющих командами. Например, C  и Lisp
режимы устанавливают переменную @code{paragraph-start} для определения
того, что только пустая строка разделяет параграфы. Это делается путем превращения
переменной в локальную для буфера помещенного в C или Lisp режим, и последующей
установкой значения для этого режима. @xref{Major Modes}.

@c   The most common use of buffer-local bindings is for major modes to change
@c variables that control the behavior of commands.  For example, C mode and
@c Lisp mode both set the variable @code{paragraph-start} to specify that only
@c blank lines separate paragraphs.  They do this by making the variable
@c buffer-local in the buffer that is being put into C mode or Lisp mode, and
@c then setting it to the new value for that mode.  @xref{Major Modes}.

  Обычный способ сделать переменную локальной для буфера
использовать @code{make-local-variable}, который используется
в командах основных режимов. Эффект сказывается только на текущем
буфере, остальные же продолжат использовать связывание по умолчание,
пока они сами явно не сделают переменную локальной.

@c   The usual way to make a buffer-local binding is with
@c @code{make-local-variable}, which is what major mode commands typically
@c use.  This affects just the current buffer; all other buffers (including
@c those yet to be created) will continue to share the default value unless
@c they are explicitly given their own buffer-local bindings.

@cindex automatically buffer-local
  Можно пометить переменную как @dfn{automatically buffer-local} с помощью
команды @code{make-variable-buffer-local}. Переменная помеченная
таким образом становится локальной во всех буферах, в том числе
уже созданным. По умолчанию все буферы будут разделять значение
по умолчанию, но при установке значения будет устанавливаться
локальное для буфера значение, при этом оставляя общее значение неизменным.
При этом общее значение не получится изменить с использованием @code{setq}
и нужно использовать @code{setq-default}.

@c   A more powerful operation is to mark the variable as
@c @dfn{automatically buffer-local} by calling
@c @code{make-variable-buffer-local}.  You can think of this as making the
@c variable local in all buffers, even those yet to be created.  More
@c precisely, the effect is that setting the variable automatically makes
@c the variable local to the current buffer if it is not already so.  All
@c buffers start out by sharing the default value of the variable as usual,
@c but setting the variable creates a buffer-local binding for the current
@c buffer.  The new value is stored in the buffer-local binding, leaving
@c the default binding untouched.  This means that the default value cannot
@c be changed with @code{setq} in any buffer; the only way to change it is
@c with @code{setq-default}.

@strong{Внимание:} Если переменная локальная для одного
или нескольких буферов, @code{let} будет изменять привязку
действующей переменной. Например, если текущий буфер имеет
локальную переменную, @code{let} временно изменит связывание.
Если не одной локальной переменной не действует, @code{let}
перепривяжет значение по умолчанию. Если внутри @code{let} сменить
текущий буфер в котором используется связывание локальной переменной,
привязка установленная в @code{let} потеряется. Если выйти из @code{let}
находясь в другом буфере, то связывание из @code{let} так же потеряется.
Например:

@c   @strong{Warning:} When a variable has buffer-local
@c bindings in one or more buffers, @code{let} rebinds the binding that's
@c currently in effect.  For instance, if the current buffer has a
@c buffer-local value, @code{let} temporarily rebinds that.  If no
@c buffer-local bindings are in effect, @code{let} rebinds
@c the default value.  If inside the @code{let} you then change to a
@c different current buffer in which a different binding is in effect,
@c you won't see the @code{let} binding any more.  And if you exit the
@c @code{let} while still in the other buffer, you won't see the
@c unbinding occur (though it will occur properly).  Here is an example
@c to illustrate:

@example
@group
(setq foo 'g)
(set-buffer "a")
(make-local-variable 'foo)
@end group
(setq foo 'a)
(let ((foo 'temp))
  ;; foo @result{} 'temp  ; @r{let binding in buffer @samp{a}}
  (set-buffer "b")
  ;; foo @result{} 'g     ; @r{the global value since foo is not local in @samp{b}}
  @var{body}@dots{})
@group
foo @result{} 'g        ; @r{exiting restored the local value in buffer @samp{a},}
                 ; @r{but we don't see that in buffer @samp{b}}
@end group
@group
(set-buffer "a") ; @r{verify the local value was restored}
foo @result{} 'a
@end group
@end example

@noindent
Ссылка на @code{foo} в @var{body} получает доступ к
локальной переменной буфера @samp{b}.

@c Note that references to @code{foo} in @var{body} access the
@c buffer-local binding of buffer @samp{b}.

  Когда файл определяет локальные переменные, они становятся локальными
для буфера когда открывается файл. @xref{File Variables,, emacs, The GNU Emacs Manual}.

@c   When a file specifies local variable values, these become buffer-local
@c values when you visit the file.  @xref{File Variables,,, emacs, The
@c GNU Emacs Manual}.

  Локальные переменные для буфера не могут быть сделаны
локальными для терминала переменными (@pxref{Multiple Terminals}).

@c   A buffer-local variable cannot be made terminal-local
@c (@pxref{Multiple Terminals}).

@node Creating Buffer-Local
@subsection Создание и Удаление локальных для буфера переменных

@deffn Command make-local-variable variable
Функция создает локальную для буфера переменную @var{variable} (символ) в текущем буфере.
Никак не влияет на другие буферы. Возвращается @var{variable}.

@c This function creates a buffer-local binding in the current buffer for
@c @var{variable} (a symbol).  Other buffers are not affected.  The value
@c returned is @var{variable}.

Локальное для буфера значение @var{variable} сначала равно
значению по умолчанию (не локальному для буфера). Если значение
не было, у локальной для буфера переменное его тоже сначала
не будет.

@c The buffer-local value of @var{variable} starts out as the same value
@c @var{variable} previously had.  If @var{variable} was void, it remains
@c void.

@example
@group
;; @r{In buffer @samp{b1}:}
(setq foo 5)                ; @r{Affects all buffers.}
     @result{} 5
@end group
@group
(make-local-variable 'foo)  ; @r{Now it is local in @samp{b1}.}
     @result{} foo
@end group
@group
foo                         ; @r{That did not change}
     @result{} 5                   ;   @r{the value.}
@end group
@group
(setq foo 6)                ; @r{Change the value}
     @result{} 6                   ;   @r{in @samp{b1}.}
@end group
@group
foo
     @result{} 6
@end group

@group
;; @r{In buffer @samp{b2}, the value hasn't changed.}
(with-current-buffer "b2"
  foo)
     @result{} 5
@end group
@end example


Использование @code{let} связываний для локальных для буфера переменных
не надежно, если только буфер не является текущим при выполнении всего @code{let}.
Что происходит из-за того, что @code{let} не может отличать разные виды
связываний и учитывает только для какой переменной была сделана
привязка.

@c Making a variable buffer-local within a @code{let}-binding for that
@c variable does not work reliably, unless the buffer in which you do this
@c is not current either on entry to or exit from the @code{let}.  This is
@c because @code{let} does not distinguish between different kinds of
@c bindings; it knows only which variable the binding was made for.

Если переменная локальная для терминала (terminal-local) (@pxref{Multiple Terminals}),
функция сигнализирует об ошибке, т.к. такие переменные не могут
быть локальными для буфера.

@c If the variable is terminal-local (@pxref{Multiple Terminals}), this
@c function signals an error.  Such variables cannot have buffer-local
@c bindings as well.

@strong{Внимание:} не стоит использовать @code{make-local-variable}
для переменных перехватчиков. Переменные перехватчиков становятся локальными
автоматически если использовать аргумент @var{local} в @code{add-hook} или
@code{remove-hook}.

@c @strong{Warning:} do not use @code{make-local-variable} for a hook
@c variable.  The hook variables are automatically made buffer-local as
@c needed if you use the @var{local} argument to @code{add-hook} or
@c @code{remove-hook}.
@end deffn

@defmac setq-local variable value
Макрос создает локальное для буфера связывание в текущем буфере
для переменной @var{variable}, и задает ей локальное значение @var{value}.
Макрос эквивалентен вызову @code{make-local-value} и @code{setq}. @var{variable}
должно быть символом без кавычки (unquoted symbol).

@c This macro creates a buffer-local binding in the current buffer for
@c @var{variable}, and gives it the buffer-local value @var{value}.  It
@c is equivalent to calling @code{make-local-variable} followed by
@c @code{setq}.  @var{variable} should be an unquoted symbol.
@end defmac

@deffn Command make-variable-buffer-local variable
Функция помечает @var{variable} (символ) как automatically
buffer-local (автоматически становящуюся локальной для буфера).
Установка значений для таких переменных будет изменять
локальное для буфера значение. В отличие от @code{make-local-variable},
данное действие не может быть отменено, и влияет на поведение
переменной во всех буферах.

@c This function marks @var{variable} (a symbol) automatically
@c buffer-local, so that any subsequent attempt to set it will make it
@c local to the current buffer at the time.  Unlike
@c @code{make-local-variable}, with which it is often confused, this
@c cannot be undone, and affects the behavior of the variable in all
@c buffers.

Своеобразный недостаток данной функции в том, что связывание переменной
с @code{let} и другими конструкциями связывания не создает локального
для буфера связывания. Только установка значения с использованием @code{set} или @code{setq},
вне @code{let} связывания будет выполняться с переменной в текущем буфере.

@c A peculiar wrinkle of this feature is that binding the variable (with
@c @code{let} or other binding constructs) does not create a buffer-local
@c binding for it.  Only setting the variable (with @code{set} or
@c @code{setq}), while the variable does not have a @code{let}-style
@c binding that was made in the current buffer, does so.

Если переменная @var{variable} не имеет значения, тогда вызов данной
команды задаст значение по умолчанию @code{nil}. Если @var{variable}
уже имеет default value, оно не изменение. Вызов @code{makunbound}
для @var{variable} приведет к удалению значения (станет void), но
не изменит default value (значение по умолчанию).

@c If @var{variable} does not have a default value, then calling this
@c command will give it a default value of @code{nil}.  If @var{variable}
@c already has a default value, that value remains unchanged.
@c Subsequently calling @code{makunbound} on @var{variable} will result
@c in a void buffer-local value and leave the default value unaffected.

Функция возвращает @var{variable}.

@c The value returned is @var{variable}.

@strong{Внимание:} Не стоит полагать, что нужно использовать
@code{make-variable-buffer-local} для переменных пользовательских
настроек, только потому что пользователь @emph{может} захотеть настраивать
их по разному в разных буферах. Пользователь может сделать
любую переменную локальной для буфера, когда захочет. Лучше оставить выбор за ним.

@c @strong{Warning:} Don't assume that you should use
@c @code{make-variable-buffer-local} for user-option variables, simply
@c because users @emph{might} want to customize them differently in
@c different buffers.  Users can make any variable local, when they wish
@c to.  It is better to leave the choice to them.

@code{make-variable-buffer-local} стоит использовать, когда важно, чтобы
никакие два буфера не имели одной и той же переменной.
Например, когда переменная
используется для внутренних нужд в Lisp программе, в которой важно иметь разные значения
в разных буферах, тогда использование @code{make-variable-buffer-local}
будет лучшим вариантом.

Прим. Оригинал:
The time to use @code{make-variable-buffer-local} is when it is crucial
that no two buffers ever share the same binding.  For example, when a
variable is used for internal purposes in a Lisp program which depends
on having separate values in separate buffers, then using
@code{make-variable-buffer-local} can be the best solution.
@end deffn

@defmac defvar-local variable value &optional docstring
Макрос определяет @var{variable} как переменную с начальным
значением @var{value} и @var{docstring}, и помечает ее как
automatically buffer-local. Макрос эквивалентен вызову @code{defvar}
и @code{make-variable-buffer-local}. @var{variable} должна быть
символом без кавычки.

@c This macro defines @var{variable} as a variable with initial value
@c @var{value} and @var{docstring}, and marks it as automatically
@c buffer-local.  It is equivalent to calling @code{defvar} followed by
@c @code{make-variable-buffer-local}.  @var{variable} should be an
@c unquoted symbol.
@end defmac

@defun local-variable-p variable &optional buffer
Функция возвращает @code{t} если @var{variable} локальная для буфера
в буфере @var{buffer} (по умолчанию текущий буфер); иначе возвращается
@code{nil}.

@c This returns @code{t} if @var{variable} is buffer-local in buffer
@c @var{buffer} (which defaults to the current buffer); otherwise,
@c @code{nil}.
@end defun

@defun local-variable-if-set-p variable &optional buffer
Возвращает @code{t} если @var{variable} или имеет локальное
для буфера @var{buffer} значение, или automaticaly buffer-local.
Иначе возвращается @code{nil}. Буфер по умолчанию текущий буфер.

@c This returns @code{t} if @var{variable} either has a buffer-local
@c value in buffer @var{buffer}, or is automatically buffer-local.
@c Otherwise, it returns @code{nil}.  If omitted or @code{nil},
@c @var{buffer} defaults to the current buffer.
@end defun

@defun buffer-local-value variable buffer
Функция возвращает локальную для буфера привязку @var{variable}
(символ) в буфере @var{buffer}. Если @var{variable} не имеет такой, возвращается
значение по умолчанию (default value, разделяемое значение) (@pxref{Default Value})
для @var{variable}.

@c This function returns the buffer-local binding of @var{variable} (a
@c symbol) in buffer @var{buffer}.  If @var{variable} does not have a
@c buffer-local binding in buffer @var{buffer}, it returns the default
@c value (@pxref{Default Value}) of @var{variable} instead.
@end defun

@defun buffer-local-variables &optional buffer
Функция возвращает список содержащий локальные для буфера переменные
буфера @var{buffer}. (Буфер по умолчанию текущий.) Каждый элемент списка
имеет форму @w{@code{@var{sym}. @var{val}}}, где @var{sym} локальная для
буфера переменная (символ) и @var{val} локальное для буфера значение. Если
локальная для буфера привязка void (значение не задано), то ей будет
соответствовать элемент списка @var{sym}.

@c This function returns a list describing the buffer-local variables in
@c buffer @var{buffer}.  (If @var{buffer} is omitted, the current buffer
@c is used.)  Normally, each list element has the form
@c @w{@code{(@var{sym} . @var{val})}}, where @var{sym} is a buffer-local
@c variable (a symbol) and @var{val} is its buffer-local value.  But when
@c a variable's buffer-local binding in @var{buffer} is void, its list
@c element is just @var{sym}.

@example
@group
(make-local-variable 'foobar)
(makunbound 'foobar)
(make-local-variable 'bind-me)
(setq bind-me 69)
@end group
(setq lcl (buffer-local-variables))
    ;; @r{First, built-in variables local in all buffers:}
@result{} ((mark-active . nil)
    (buffer-undo-list . nil)
    (mode-name . "Fundamental")
    @dots{}
@group
    ;; @r{Next, non-built-in buffer-local variables.}
    ;; @r{This one is buffer-local and void:}
    foobar
    ;; @r{This one is buffer-local and nonvoid:}
    (bind-me . 69))
@end group
@end example

Сохранение нового значения в @sc{cdr}s cons ячейки в данном списке,
@emph{не} изменяет значение локальных для буфера значений переменных.

@c Note that storing new values into the @sc{cdr}s of cons cells in this
@c list does @emph{not} change the buffer-local values of the variables.
@end defun

@deffn Command kill-local-variable variable
Функция удаляет локальное связывание (если есть) для @var{variable}
(символ) в текущем буфере. Как результат, связывание по умолчанию
(разделяемое между буферами, default binding) становится видным в текущем
буфере. В результате как правило, значение @var{variable} изменяется, так
как разделяемое значение как правило отличается от локального для буфера.

@c This function deletes the buffer-local binding (if any) for
@c @var{variable} (a symbol) in the current buffer.  As a result, the
@c default binding of @var{variable} becomes visible in this buffer.  This
@c typically results in a change in the value of @var{variable}, since the
@c default value is usually different from the buffer-local value just
@c eliminated.

Если удалить локальную переменную которая automatically buffer-local,
разделяемое значение будет видно в текущем буфере. Но, если снова
установить значение данной переменной, снова будет создана локальная
для буфера переменная.

@c If you kill the buffer-local binding of a variable that automatically
@c becomes buffer-local when set, this makes the default value visible in
@c the current buffer.  However, if you set the variable again, that will
@c once again create a buffer-local binding for it.

@code{kill-local-variable} возвращает @var{variable}.

@c @code{kill-local-variable} returns @var{variable}.

Функция является командой, так как иногда требуется интерактивно удалить
локальную для буфера переменную.

@c This function is a command because it is sometimes useful to kill one
@c buffer-local variable interactively, just as it is useful to create
@c buffer-local variables interactively.
@end deffn

@cindex local variables, killed by major mode
@defun kill-all-local-variables
Функция удаляет все локальные переменные текущего буфера, за исключением
переменных помеченных как постоянные (permanent) и локальных функций
перехватчиков (local hook funtions), которые имеют non-@code{nil} @code{permanent-local-hook}
свойства (@pxref{Setting Hooks}). В результате, в буфере будут
видны разделяемые (default values) значения большинства переменных.

@c This function eliminates all the buffer-local variable bindings of the
@c current buffer except for variables marked as permanent and local
@c hook functions that have a non-@code{nil} @code{permanent-local-hook}
@c property (@pxref{Setting Hooks}).  As a result, the buffer will see
@c the default values of most variables.

Функция так же сбрасывает другую информацию относящуюся к буферу, устанавливает
локальную раскладку (привязку клавиш, local keymap) в @code{nil}, синтаксическую
таблицу в @code{(standard-syntax-table)}, case table (таблицу соответствия заглавных
и строчных букв) в @code{(standard-case-table)}, таблицу аббревиатур в
@code{(fundamental-mode-abbref-table)}.

@c This function also resets certain other information pertaining to the
@c buffer: it sets the local keymap to @code{nil}, the syntax table to the
@c value of @code{(standard-syntax-table)}, the case table to
@c @code{(standard-case-table)}, and the abbrev table to the value of
@c @code{fundamental-mode-abbrev-table}.

Первым делом данная функция вызывается обычный перехватчик
@code{change-major-mode-hook} (см. ниже).

@c The very first thing this function does is run the normal hook
@c @code{change-major-mode-hook} (see below).

Каждая команда основного режима начинается с вызова данной функции, которая
выполняет переключение Fundamental(Базового) режима и очищает настройки
предыдущего основного режима. Чтобы быть уверенным, что данное действие
будет выполнено, не стоит помечать переменные устанавливаемые основным режимом
как постоянные (permanent).

@c Every major mode command begins by calling this function, which has the
@c effect of switching to Fundamental mode and erasing most of the effects
@c of the previous major mode.  To ensure that this does its job, the
@c variables that major modes set should not be marked permanent.

@code{kill-all-local-variables} возвращает @code{nil}.
@c @code{kill-all-local-variables} returns @code{nil}.
@end defun

@defvar change-major-mode-hook
Функция @code{kill-all-local-variables} запускает этот обычный перехватчик
в самом начале, что является приготовлением к выполнению действий переключения
в другой режим. Функция полезна и для дополнительных режимом, которые
должны быть забыты при смене основного режима.

@c The function @code{kill-all-local-variables} runs this normal hook
@c before it does anything else.  This gives major modes a way to arrange
@c for something special to be done if the user switches to a different
@c major mode.  It is also useful for buffer-specific minor modes
@c that should be forgotten if the user changes the major mode.

Стоит делать эту переменную локальной для буфера, чтобы она исчезала
после выполнения своей задачи, и не мешала следующему основному режиму.
@xref{Hooks}.

@c For best results, make this variable buffer-local, so that it will
@c disappear after doing its job and will not interfere with the
@c subsequent major mode.  @xref{Hooks}.
@end defvar

@cindex permanent local variable
Локальная для буфера переменная @dfn{постоянная} (@@dfn{permanent})
если имя переменной (символ) имеет не-@code{nil} значение свойства
@code{permanent-local}. На такие переменные не действует @code{kill-all-local-variables},
и локальные значения таких переменных не очищаются при смене основного режима.
Постоянные локальные переменные полезны для хранения информации о том,
откуда файл был взят или как его стоит сохранять, а не для того
как редактировать содержимое.

@c A buffer-local variable is @dfn{permanent} if the variable name (a
@c symbol) has a @code{permanent-local} property that is non-@code{nil}.
@c Such variables are unaffected by @code{kill-all-local-variables}, and
@c their local bindings are therefore not cleared by changing major modes.
@c Permanent locals are appropriate for data pertaining to where the file
@c came from or how to save it, rather than with how to edit the contents.

@node Default Value
@subsection The Default Value of a Buffer-Local Variable
@cindex default value

  Глобальное значение переменной имеющей локальные для буферов связывания,
также называется @dfn{default} (@dfn{дефолтным}) значением, потому что это
значение действует когда выбранный буфер или выбранный фрейм не
имеют своего собственного значения для переменной.

@c   The global value of a variable with buffer-local bindings is also
@c called the @dfn{default} value, because it is the value that is in
@c effect whenever neither the current buffer nor the selected frame has
@c its own binding for the variable.

  Функции @code{default-value} и @code{setq-default} используются для
получения значения и установки дефолтного значения несмотря на
наличие у текущего буфера локального значения. Например,
можно использовать @code{setq-default} для изменения дефолтного
значения @code{paragraph-start} для большинства буферов, и это
сработает даже если текущий буфер в C или Lisp режиме, которые
имеют локальных значения для данной переменной.

@c   The functions @code{default-value} and @code{setq-default} access and
@c change a variable's default value regardless of whether the current
@c buffer has a buffer-local binding.  For example, you could use
@c @code{setq-default} to change the default setting of
@c @code{paragraph-start} for most buffers; and this would work even when
@c you are in a C or Lisp mode buffer that has a buffer-local value for
@c this variable.

@c Emacs 19 feature
  Специальные формы @code{defvar} и @code{defconst} также устанавливают
дефолтное значение (если они устанавливают переменную), а не локальное
для буфера значение.

@c   The special forms @code{defvar} and @code{defconst} also set the
@c default value (if they set the variable at all), rather than any
@c buffer-local value.

@defun default-value symbol
Функция возвращает дефолтное значение @var{symbol}. Это значение
которое видно в буферах и фреймах которые не имеют собственного локального
значения для данной переменной. Если @var{symbol} не локальный для буфера,
функция работает эквивалентно @code{symbol-value} (@pxref{Acesssing Variables}).

@c This function returns @var{symbol}'s default value.  This is the value
@c that is seen in buffers and frames that do not have their own values for
@c this variable.  If @var{symbol} is not buffer-local, this is equivalent
@c to @code{symbol-value} (@pxref{Accessing Variables}).
@end defun

@c Emacs 19 feature
@defun default-boundp symbol
Функция @code{default-boundp} проверяет, что дефолтное значение @var{symbol}
существует (не void). Есл и @code{(default-boundp 'foo)} возвращает
@code{nil}, тогда @code{(default-value 'foo)} приведет к ошибке.

@c The function @code{default-boundp} tells you whether @var{symbol}'s
@c default value is nonvoid.  If @code{(default-boundp 'foo)} returns
@c @code{nil}, then @code{(default-value 'foo)} would get an error.

@code{default-boundp} для @code{default-value} тоже, что @code{boundp} для
@code{symbol-value}.

@c @code{default-boundp} is to @code{default-value} as @code{boundp} is to
@c @code{symbol-value}.
@end defun

@defspec setq-default [symbol form]@dots{}
Специальная форм задает каждому @var{symbol} новое дефолтное значение, которое
является результатом вычисления соответствующей @var{form}. @var{symbol} не вычисляется,
но вычисляется @var{form}. Значение @code{setq-default} формы значение последней
@var{form}.

@c This special form gives each @var{symbol} a new default value, which is
@c the result of evaluating the corresponding @var{form}.  It does not
@c evaluate @var{symbol}, but does evaluate @var{form}.  The value of the
@c @code{setq-default} form is the value of the last @var{form}.

Если @var{symbol} не локальный для текущего буфера, и не automatically buffer-local,
@code{setq-default} имеет тот же эффект, что @code{setq}. Если @var{symbol} локальный
для текущего буфера, тогда изменится значение видимое в буферах не
имеющих такой локальной переменной, но значение в текущем буфере останется
прежним.

@c If a @var{symbol} is not buffer-local for the current buffer, and is not
@c marked automatically buffer-local, @code{setq-default} has the same
@c effect as @code{setq}.  If @var{symbol} is buffer-local for the current
@c buffer, then this changes the value that other buffers will see (as long
@c as they don't have a buffer-local value), but not the value that the
@c current buffer sees.

@example
@group
;; @r{In buffer @samp{foo}:}
(make-local-variable 'buffer-local)
     @result{} buffer-local
@end group
@group
(setq buffer-local 'value-in-foo)
     @result{} value-in-foo
@end group
@group
(setq-default buffer-local 'new-default)
     @result{} new-default
@end group
@group
buffer-local
     @result{} value-in-foo
@end group
@group
(default-value 'buffer-local)
     @result{} new-default
@end group

@group
;; @r{In (the new) buffer @samp{bar}:}
buffer-local
     @result{} new-default
@end group
@group
(default-value 'buffer-local)
     @result{} new-default
@end group
@group
(setq buffer-local 'another-default)
     @result{} another-default
@end group
@group
(default-value 'buffer-local)
     @result{} another-default
@end group

@group
;; @r{Back in buffer @samp{foo}:}
buffer-local
     @result{} value-in-foo
(default-value 'buffer-local)
     @result{} another-default
@end group
@end example
@end defspec

@defun set-default symbol value
Функция аналогична @code{setq-default}, за исключением, того что @var{symbol}
обычный вычисляемый аргумент.

@c This function is like @code{setq-default}, except that @var{symbol} is
@c an ordinary evaluated argument.

@example
@group
(set-default (car '(a b c)) 23)
     @result{} 23
@end group
@group
(default-value 'a)
     @result{} 23
@end group
@end example
@end defun

  Переменная может быть let-связанной (@pxref{Local Variables}) со значением.
Что делает глобальное значение спратанным (shadowed);
@code{default-value} в этом случае вернет значение из let,
а не глобальное значение, и @code{set-default} будет изменять
значение связывания из let. Ниже описаны две функции, позволяющие
взаимодействовать с глобальным значением, даже если оно спрятано(shadowed)
let связыванием.

@c   A variable can be let-bound (@pxref{Local Variables}) to a value.
@c This makes its global value shadowed by the binding;
@c @code{default-value} will then return the value from that binding, not
@c the global value, and @code{set-default} will be prevented from
@c setting the global value (it will change the let-bound value instead).
@c The following two functions allow to reference the global value even
@c if it's shadowed by a let-binding.

@cindex top-level default value
@defun default-toplevel-value symbol
Функция возвращает @dfn{top-level} (@dfn{значение верхнего уровня})
@var{symbol}, являющееся значением вне всех let связываний.

@c This function returns the @dfn{top-level} default value of
@c @var{symbol}, which is its value outside of any let-binding.
@end defun

@example
@group
(defvar variable 'global-value)
    @result{} variable
@end group
@group
(let ((variable 'let-binding))
  (default-value 'variable))
    @result{} let-binding
@end group
@group
(let ((variable 'let-binding))
  (default-toplevel-value 'variable))
    @result{} global-value
@end group
@end example

@defun set-default-toplevel-value symbol value
Функция устанавливает значение верхнего уровня @var{symbol} в @var{value}.
Функция полезна, если нужно изменить глобальное значение @var{symbol}, независимо
от возможного скрытия(shadowed) let связываниям.

@c This function sets the top-level default value of @var{symbol} to the
@c specified @var{value}.  This comes in handy when you want to set the
@c global value of @var{symbol} regardless of whether your code runs in
@c the context of @var{symbol}'s let-binding.
@end defun


@node File Local Variables
@section Локальные Переменные Файла
@cindex file local variables

  Файл может определить локальные значения переменных; Emacs использует
это для создания локальных связываний для буфера для этих переменных в буферах
открывающих этот файл. @xref{File Variable, , Local Variables in Files, emacs, The GNU
Emacs Manual}, для получения базовой информации по локальным переменным файлов.
Данная часть содержит описание функций и переменных влияющих на обработку локальных
для файла переменных.

@c   A file can specify local variable values; Emacs uses these to create
@c buffer-local bindings for those variables in the buffer visiting that
@c file.  @xref{File Variables, , Local Variables in Files, emacs, The
@c GNU Emacs Manual}, for basic information about file-local variables.
@c This section describes the functions and variables that affect how
@c file-local variables are processed.

  Если локальная для файла переменная может задавать произвольную функцию
или Lisp выражение которое может быть вызвано позднее, посещение файла
может захватить ваш Emacs. Emacs имеет защиту от такого рода атак выполняя
установку только безопасных локальных для файла переменных, про чьи значения
известно, что они безопасны. Другие локальные переменные файла устанавливаются только
с разрешения пользователя.

@c   If a file-local variable could specify an arbitrary function or Lisp
@c expression that would be called later, visiting a file could take over
@c your Emacs.  Emacs protects against this by automatically setting only
@c those file-local variables whose specified values are known to be
@c safe.  Other file-local variables are set only if the user agrees.

  Для обеспечения дополнительной безопасности, @code{read-circle}
временно устанавливается в @code{nil}, когда Emacs считывает локальные
для файла переменные (@pxref{Input Functions}). Что не дает Lisp
распознавать циклические и общие Lisp структуры (@pxref{Circular Objects}).

@c   For additional safety, @code{read-circle} is temporarily bound to
@c @code{nil} when Emacs reads file-local variables (@pxref{Input
@c Functions}).  This prevents the Lisp reader from recognizing circular
@c and shared Lisp structures (@pxref{Circular Objects}).

@defopt enable-local-variables
Данная переменная определяет обработку локальных для файла переменных.
Возможные значения:

@c This variable controls whether to process file-local variables.
@c The possible values are:

@tabls @asis
@item @code{t} (значение по умолчанию)
Устанавливает безопасные переменные и спрашивает (один раз) о любых
не безопасных переменных.
@item @code{:safe}
Устанавливает только безопасные переменные и ничего больше не спрашивает.
@item @code{:all}
Устанавливает все переменные и ничего не спрашивает.
@item @code{nil}
Не устанавливает переменные.
@item anything else
Спрашивает (один раз) о всех переменных.
@end table

@c @table @asis
@c @item @code{t} (the default)
@c Set the safe variables, and query (once) about any unsafe variables.
@c @item @code{:safe}
@c Set only the safe variables and do not query.
@c @item @code{:all}
@c Set all the variables and do not query.
@c @item @code{nil}
@c Don't set any variables.
@c @item anything else
@c Query (once) about all the variables.
@c @end table
@end defopt

@defvar inhibit-local-variables-regexps
Это список регулярных выражений. Если файл имеет имя удовлетворяющее
регулярному выражению из списка, тогда в нем не выполняет проверка
на наличие каких-либо локальных для файла переменных. Пример почему
это может быть полезно описан в, @pxref{Auto Major Mode}.

@c This is a list of regular expressions.  If a file has a name
@c matching an element of this list, then it is not scanned for
@c any form of file-local variable.  For examples of why you might want
@c to use this, @pxref{Auto Major Mode}.
@end defvar

@defun hack-local-variables &optional mode-only
Функция разбирает и связывает или вычисляет если нужно, все локальные
переменные из содержимого текущего буфера. Переменная @code{enable-local-variables}
действует здесь. Но, функция не обрабатывает @samp{mode:} локальную
переменную в @w{@samp{-*-}} строке. Это выполняется функцией @code{set-auto-mode}
которая тоже учитывает значение @code{enable-local-variable} (@pxref{Auto Major Mode}).

@c This function parses, and binds or evaluates as appropriate, any local
@c variables specified by the contents of the current buffer.  The variable
@c @code{enable-local-variables} has its effect here.  However, this
@c function does not look for the @samp{mode:} local variable in the
@c @w{@samp{-*-}} line.  @code{set-auto-mode} does that, also taking
@c @code{enable-local-variables} into account (@pxref{Auto Major Mode}).

Функция работает путем перебора элементов alist хранящегося в @code{file-local-variables-alist}
и применения каждой локальной переменной за раз. Функция вызывает
@code{before-hack-local-variables-hook} и @code{hack-local-variables-hook} до
и после применения переменных соответственно. @code{before-hack-local-variables-hook}
вызывается только alist не-@code{nil}; и всегда вызывает другой перехватчик.
Функция игнорирует @samp{mode} элемент если задан тот же режим, который
уже задан для буфера.

@c This function works by walking the alist stored in
@c @code{file-local-variables-alist} and applying each local variable in
@c turn.  It calls @code{before-hack-local-variables-hook} and
@c @code{hack-local-variables-hook} before and after applying the
@c variables, respectively.  It only calls the before-hook if the alist
@c is non-@code{nil}; it always calls the other hook.  This
@c function ignores a @samp{mode} element if it specifies the same major
@c mode as the buffer already has.

Если не обязательный аргумент @var{mode-only} не-@code{nil}, тогда
все функции возвращают символ определяющий основной режим, если @w{@samp{-*-}} строка
или локальные переменные его задают, и @code{nil} иначе. Она не устанавливает режим
другие локальные для файла переменные.

@c If the optional argument @var{mode-only} is non-@code{nil}, then all
@c this function does is return a symbol specifying the major mode,
@c if the @w{@samp{-*-}} line or the local variables list specifies one,
@c and @code{nil} otherwise.  It does not set the mode nor any other
@c file-local variable.
@end defun

@defvar file-local-variables-alist
Локальная для буфера переменная, которая хранит alist(ассоциативный список) локальные для
файла настройки переменных. Каждый элемент alist имеет форму
@w{@code{(@var{var} . @var{value})}}, где @var{var} символ локальной
переменной, а @var{value} значение. Когда Emacs обращается к файлу, сначала
он собирает все локальные для файла переменные в этот alist, и затем
по очереди применяет к ним функцию @code{hack-local-variables}.

@c This buffer-local variable holds the alist of file-local variable
@c settings.  Each element of the alist is of the form
@c @w{@code{(@var{var} . @var{value})}}, where @var{var} is a symbol of
@c the local variable and @var{value} is its value.  When Emacs visits a
@c file, it first collects all the file-local variables into this alist,
@c and then the @code{hack-local-variables} function applies them one by
@c one.
@end defvar

@defvar before-hack-local-variables-hook
Emacs вызывает этот перехватчик перед применением локальных переменных
хранящихся в @code{file-local-variables-alist}.
@c Emacs calls this hook immediately before applying file-local variables
@c stored in @code{file-local-variables-alist}.
@end defvar

@defvar hack-local-variables-hook
Emacs вызывает этот перехватчик сразу после того как применит
локальные для файла переменные хранящиеся в @code{file-local-variables-alist}.

@c Emacs calls this hook immediately after it finishes applying
@c file-local variables stored in @code{file-local-variables-alist}.
@end defvar

@cindex safe local variable
  Можно определить безопасные значения для переменной с помощью
свойства @code{safe-local-variable}. Свойство может быть
функцией одного аргумента, при этом свойство будет считаться безопасным
если функция вызванная с этим аргументом вернет не-@code{nil}.
Многие часто встречающиеся локальные для файлов переменные имеют
@code{safe-local-variable} свойства, которые включают @code{fill-column},
@code{fill-prefix}, и @code{indent-tabs-mode}.
Для булевых переменных, которые считаются безопасными стоит использовать
@code{booleanp} в качестве значения свойства.

@c   You can specify safe values for a variable with a
@c @code{safe-local-variable} property.  The property has to be a
@c function of one argument; any value is safe if the function returns
@c non-@code{nil} given that value.  Many commonly-encountered file
@c variables have @code{safe-local-variable} properties; these include
@c @code{fill-column}, @code{fill-prefix}, and @code{indent-tabs-mode}.
@c For boolean-valued variables that are safe, use @code{booleanp} as the
@c property value.

  Когда определяется опция пользовательской настройки с использованием
@code{defcustom}, можно установить @code{safe-local-variable} свойство
с помощью аргумента @code{:safe @var{function}} в @code{defcustom}
(@pxref{Variable Definitions}).

@c   When defining a user option using @code{defcustom}, you can set its
@c @code{safe-local-variable} property by adding the arguments
@c @code{:safe @var{function}} to @code{defcustom} (@pxref{Variable
@c Definitions}).

@defopt safe-local-variable-values
Данная переменная предоставляет другой способ пометить некоторые
переменные как безопасные. Переменная является списком cons ячеек
@code{(@var{var} . @var{val})}, где @var{var} имя переменной и @var{val}
значение которое безопасно для данной переменной.

@c This variable provides another way to mark some variable values as
@c safe.  It is a list of cons cells @code{(@var{var} . @var{val})},
@c where @var{var} is a variable name and @var{val} is a value which is
@c safe for that variable.

Когда Emacs спрашивает пользователя нужно или нет устанавливать локальную
для файла переменную, пользователь может указать Emacs, пометить
переменную как безопасную, что добавит пару примененную и значение в
@code{safe-local-variable-values}, и сохраняет в файл с пользовательскими
настройками.

@c When Emacs asks the user whether or not to obey a set of file-local
@c variable specifications, the user can choose to mark them as safe.
@c Doing so adds those variable/value pairs to
@c @code{safe-local-variable-values}, and saves it to the user's custom
@c file.
@end defopt

@defun safe-local-variable-p sym val
Функция возвращает не-@code{nil} если для @var{sym} значение @var{val}
безопасно.

@c This function returns non-@code{nil} if it is safe to give @var{sym}
@c the value @var{val}, based on the above criteria.
@end defun

@c @cindex risky local variable   Duplicates risky-local-variable
  Некоторое переменные рассматриваются ка @dfn{рискованные} (@dfn{risky}).
Если переменная рискованная, она никогда автоматически не помещается в
@code{safe-local-variable-values}; Emacs всегда спрашивает перед установкой
рискованной пе ременной, кроме случаев если пользователь явно не разрешил
значение в настройке @code{safe-local-variable-values}.

@c   Some variables are considered @dfn{risky}.  If a variable is risky,
@c it is never entered automatically into
@c @code{safe-local-variable-values}; Emacs always queries before setting
@c a risky variable, unless the user explicitly allows a value by
@c customizing @code{safe-local-variable-values} directly.

  Любая переменная чье имя имеет не-@code{nil} значение свойства
@code{risky-local-variable} рассматривается как рискованная. При определении
настраиваемого пользователем свойства с использованием @code{defcustom},
данное свойство можно установить с помощью параметра
@code{:risky @var{value}}. (@pxref{Variable Definitions}). Кроме того, любая
переменная чье имя оканчивается на @same{-command}, @samp{-frame-alist}, @samp{function},
@samp{-functions}, @samp{-hook}, @samp{-hooks}, @samp{-form},
@samp{-forms}, @samp{-map}, @samp{-map-alist}, @samp{-mode-alist},
@samp{-program} или @samp{-predicate} автоматически рассматривается как
рискованная. Переменные @samp{font-lock-keywords}, @samp{font-lock-keywords} следующее
за цифрой, и @samp{font-lock-syntactic-keywords} тоже считаются рискованными.

@c   Any variable whose name has a non-@code{nil}
@c @code{risky-local-variable} property is considered risky.  When you
@c define a user option using @code{defcustom}, you can set its
@c @code{risky-local-variable} property by adding the arguments
@c @code{:risky @var{value}} to @code{defcustom} (@pxref{Variable
@c Definitions}).  In addition, any variable whose name ends in any of
@c @samp{-command}, @samp{-frame-alist}, @samp{-function},
@c @samp{-functions}, @samp{-hook}, @samp{-hooks}, @samp{-form},
@c @samp{-forms}, @samp{-map}, @samp{-map-alist}, @samp{-mode-alist},
@c @samp{-program}, or @samp{-predicate} is automatically considered
@c risky.  The variables @samp{font-lock-keywords},
@c @samp{font-lock-keywords} followed by a digit, and
@c @samp{font-lock-syntactic-keywords} are also considered risky.

@defun risky-local-variable-p sym
Функция возвращает не-@code{nil} если @var{sym} рискованная переменная,
основываясь на описанных выше критериях.

@c This function returns non-@code{nil} if @var{sym} is a risky variable,
@c based on the above criteria.
@end defun

@defvar ignored-local-variables
Переменная хранит список переменных, для которых не задают локальные переменные
для файлов. Любое значение заданное для таких переменных игнорируется.

@c This variable holds a list of variables that should not be given local
@c values by files.  Any value specified for one of these variables is
@c completely ignored.
@end defvar

  @samp{Eval:} ``переменная'' так же является уязвимым местом, поэтому
Emacs обычно спрашивает подтверждение перед обработкой.

@c   The @samp{Eval:} ``variable'' is also a potential loophole, so Emacs
@c normally asks for confirmation before handling it.

@defopt enable-local-eval
Переменная управляет обработкой @samp{Eval:} в @samp{-*-} строках
или списках локальных переменных посещенного Emacs файла. Значение @code{t}
означает их безусловную обработку; @code{nil} означает их игнорирование; другие
значения предполагают, что нужно спросить пользователя, что нужно делать
для каждого файла. Значение по умолчанию @code{maybe}.

@c This variable controls processing of @samp{Eval:} in @samp{-*-} lines
@c or local variables
@c lists in files being visited.  A value of @code{t} means process them
@c unconditionally; @code{nil} means ignore them; anything else means ask
@c the user what to do for each file.  The default value is @code{maybe}.
@end defopt

@defopt safe-local-eval-forms
Переменная хранит список выражений которые считаются безопасными
для вычисления когда находятся в @samp{Eval:} ``переменной''
в списке локальных переменных файла.

@c This variable holds a list of expressions that are safe to
@c evaluate when found in the @samp{Eval:} ``variable'' in a file
@c local variables list.
@end defopt

  Если выражение является вызовом функции и функция имеет свойство
@code{safe-local-eval-forms}, значение свойства определяет является
ли выражение безопасным для вычисления. Значением свойства может быть
предикатом для проверки выражения, списком
предикатов (безопасно если вычисление любого предиката успешно), или @code{t}
(всегда безопасно).

@c   If the expression is a function call and the function has a
@c @code{safe-local-eval-function} property, the property value
@c determines whether the expression is safe to evaluate.  The property
@c value can be a predicate to call to test the expression, a list of
@c such predicates (it's safe if any predicate succeeds), or @code{t}
@c (always safe provided the arguments are constant).

  Текстовые свойства так же могут представлять опасность, так как
их значения могут включать функции для вызова. Поэтому Emacs выключает
все текстовые свойства из строковых значений для локальных переменных файлов.

@c   Text properties are also potential loopholes, since their values
@c could include functions to call.  So Emacs discards all text
@c properties from string values specified for file-local variables.

@node Directory Local Variables
@section Локальные Переменные Каталогов
@cindex directory local variables

  Каталоги могут определять свои локальные переменные, которые будут общими
для всех файлов из каталога; Emacs использует их для создания локальных
переменных буферов при открытии любого файла из каталога. Такая возможность
полезна когда файлы в каталоге относятся к некоторому @dfn{проекту} (@dfn{project})
и поэтому разделяют некоторые локальные переменные.

@c   A directory can specify local variable values common to all files in
@c that directory; Emacs uses these to create buffer-local bindings for
@c those variables in buffers visiting any file in that directory.  This
@c is useful when the files in the directory belong to some @dfn{project}
@c and therefore share the same local variables.

  Есть два разных способа задать локальные переменные для каталогов:
путем помещения их в специальный файл, или определением @dfn{класса проекта}
(@dfn{project class}) для каталога.

@c   There are two different methods for specifying directory local
@c variables: by putting them in a special file, or by defining a
@c @dfn{project class} for that directory.

@defvr Constant dir-locals-file
Данная константа хранит имя файла в котором Emacs ожидает найти
локальные переменные для каталога. Имя файла @file{.dir-locals.el}@footnote{
MS-DOS версия Emacs использует @file{_dir-locals.el}, из-за ограничений
файловой системы DOS}. Если в каталоге есть такой файл, то его настройки
применяются ко все файлам в этом каталоге или в любом его подкаталоге
(опционально, применение в подкаталогах можно отключить, см. ниже).
Если какие-то подкаталоги имеют свои собственные @file{.dir-locals.el}
файлы, Emacs использует настройки из самого глубокого файла начиная
с директории в которой находится файла и двигаясь вверх под дереву директорий.
Файл определяет локальные переменные в виде списка особого вида; см.
@ref{Directory Variables, , Per-directory Local Variables, emacs, The GNU Emacs Manual}.

@c This constant is the name of the file where Emacs expects to find the
@c directory-local variables.  The name of the file is
@c @file{.dir-locals.el}@footnote{
@c The MS-DOS version of Emacs uses @file{_dir-locals.el} instead, due to
@c limitations of the DOS filesystems.
@c }.  A file by that name in a directory causes Emacs to apply its
@c settings to any file in that directory or any of its subdirectories
@c (optionally, you can exclude subdirectories; see below).
@c If some of the subdirectories have their own @file{.dir-locals.el}
@c files, Emacs uses the settings from the deepest file it finds starting
@c from the file's directory and moving up the directory tree.  The file
@c specifies local variables as a specially formatted list; see
@c @ref{Directory Variables, , Per-directory Local Variables, emacs, The
@c GNU Emacs Manual}, for more details.
@end defvr

@defun hack-dir-local-variables
Функция считывает @code{.dir-locals.el} файл и сохраняет локальные
для каталога переменные в @code{file-local-variables-alist} который является
локальным для буфера любого файла в каталоге, не применяя их.
Так же выполняется сохранение локальных для директории настроек в
@code{dir-locals-class-alist}, где определяется специальный класс для
каталога в котором найден @file{.dir-locals.el}. Данная функция вызывает @code{dir-locals-set-class-variables} и @code{dir-locals-set-directory-class}, описанные ниже.

@c This function reads the @code{.dir-locals.el} file and stores the
@c directory-local variables in @code{file-local-variables-alist} that is
@c local to the buffer visiting any file in the directory, without
@c applying them.  It also stores the directory-local settings in
@c @code{dir-locals-class-alist}, where it defines a special class for
@c the directory in which @file{.dir-locals.el} file was found.  This
@c function works by calling @code{dir-locals-set-class-variables} and
@c @code{dir-locals-set-directory-class}, described below.
@end defun

@defun hack-dir-local-variables-non-file-buffer
Данная функция ищет локальные для каталога переменные и сразу применяет
их в текущем буфере. Функция должна быть вызвана в команде режима для
не файловых буферов, таких как буферы Dired, чтобы соответствовать
настройкам для локальной директории. Для не файловых буферов, Emacs
ищет локальные для каталога переменные в @code{default-directory} и
родительских директориях.

@c This function looks for directory-local variables, and immediately
@c applies them in the current buffer.  It is intended to be called in
@c the mode commands for non-file buffers, such as Dired buffers, to let
@c them obey directory-local variable settings.  For non-file buffers,
@c Emacs looks for directory-local variables in @code{default-directory}
@c and its parent directories.
@end defun

@defun dir-locals-set-class-variables class variables
Функция определяет множество настроек переменных для символа
@var{class}. Данный класс можно позднее присвоить одной или нескольким
директориям, и Emacs применит настройки переменных ко всем файлам из этих
директорий. Список в @var{variables} может быть одной из двух
форм: @code{(@var{major-mode}. @var{alist})} или @code{(@var{directory} . @var{list})}.
В случае первой формы, для файловых буферов при включении режима который является
наследником режима @var{major-mode}, применяются все переменные в @var{alist};
@var{alist} должен иметь форму @code{(@var{name} . @var{value})}.
Специальное значение @code{nil} для @var{major-mode} означает применение
настроек для любого режима. В @var{alist} можно использовать специальное
@var{name}: @code{subdirs}. Если ассоциированное значение @code{nil}, alist
применяется только к файлам из текущей директории и не применяется к файлам
из под-директорий.

@c This function defines a set of variable settings for the named
@c @var{class}, which is a symbol.  You can later assign the class to one
@c or more directories, and Emacs will apply those variable settings to
@c all files in those directories.  The list in @var{variables} can be of
@c one of the two forms: @code{(@var{major-mode} . @var{alist})} or
@c @code{(@var{directory} . @var{list})}.  With the first form, if the
@c file's buffer turns on a mode that is derived from @var{major-mode},
@c then the all the variables in the associated @var{alist} are applied;
@c @var{alist} should be of the form @code{(@var{name} . @var{value})}.
@c A special value @code{nil} for @var{major-mode} means the settings are
@c applicable to any mode.  In @var{alist}, you can use a special
@c @var{name}: @code{subdirs}.  If the associated value is
@c @code{nil}, the alist is only applied to files in the relevant
@c directory, not to those in any subdirectories.

В случае со второй формой @var{variables}, если @var{directory} является
префиксом директории, тогда @var{list} применяется рекурсивно следуя вышеописанным
правилам; @var{list} должно быть одной из двух форм принимаемых данной фукнкцией
в качестве аргумента @var{variables}.

@c With the second form of @var{variables}, if @var{directory} is the
@c initial substring of the file's directory, then @var{list} is applied
@c recursively by following the above rules; @var{list} should be of one
@c of the two forms accepted by this function in @var{variables}.
@end defun

@defun dir-locals-set-directory-class directory class &optional mtime
Функция присваивает @var{class} всем файлам в каталоге @code{directory}
и его под-директориях. Таким образом, все настройки переменных
заданные для @var{class} будут применены к любому открытому файлу в
@var{directory} и ее дочерних каталогах. @var{class} уже должен быть определен
с использованием @code{dir-locals-set-class-variables}.

@c This function assigns @var{class} to all the files in @code{directory}
@c and its subdirectories.  Thereafter, all the variable settings
@c specified for @var{class} will be applied to any visited file in
@c @var{directory} and its children.  @var{class} must have been already
@c defined by @code{dir-locals-set-class-variables}.

Emacs использует эту функцию когда выполняет загрузку переменных
из @code{.dir-locals.el}. В этом случае не обязательный аргумент
@var{mtime} хранит время модификации файла (возвращается @code{file-attributes}).
Emacs использует это время для проверки того, что хранящиеся локальные переменные
все еще актуальны. Если присвоить класс напрямую, не через файл, данный аргумент
должен быть @code{nil}.

@c Emacs uses this function internally when it loads directory variables
@c from a @code{.dir-locals.el} file.  In that case, the optional
@c argument @var{mtime} holds the file modification time (as returned by
@c @code{file-attributes}).  Emacs uses this time to check stored
@c local variables are still valid.  If you are assigning a class
@c directly, not via a file, this argument should be @code{nil}.
@end defun

@defvar dir-locals-class-alist
Данный ассоциативный список (alist) хранит символы классов и
связанные настройки переменных. Данная переменная обновляется  функцией
@code{dir-locals-set-class-variables}.

@c This alist holds the class symbols and the associated variable
@c settings.  It is updated by @code{dir-locals-set-class-variables}.
@end defvar

@defvar dir-locals-directory-cache
Данная переменная хранит ассоциативный список из имен каталогов и
присвоенных им имен классов и времени модификации ассоциированных с
каталогами файлов с локальными переменными (если такие есть).
Функция @code{dir-locals-set-directory-class} используется для
обновления этого списка.

@c This alist holds directory names, their assigned class names, and
@c modification times of the associated directory local variables file
@c (if there is one).  The function @code{dir-locals-set-directory-class}
@c updates this list.
@end defvar

@defvar enable-dir-local-variables
Если @code{nil}, локальные для каталогов переменные игнорируются.
Данная переменная полезна для режимов в которых нужно игнорировать
локальные переменные каталогов при этом поддерживая локальные для
файлов переменные (@pxref{File Local Variables}).

@c If @code{nil}, directory-local variables are ignored.  This variable
@c may be useful for modes that want to ignore directory-locals while
@c still respecting file-local variables (@pxref{File Local Variables}).
@end defvar

@node Variable Aliases
@section Псеводнимы Для Переменных
@cindex variable aliases
@cindex alias, for variables

  Иногда бывает полезно иметь переменную синоним, переменная имеющая тоже
значение и изменение одной является изменением другой. При изменении
имени переменной, когда становится понятно, что старое имя не так хорошо,
бывает полезно сохранить старую переменную в качестве @dfn{синоним} (@dfn{alias})
для обратной совместимости. Это можно сделать с использованием
@code{defvaralias}.

@c   It is sometimes useful to make two variables synonyms, so that both
@c variables always have the same value, and changing either one also
@c changes the other.  Whenever you change the name of a
@c variable---either because you realize its old name was not well
@c chosen, or because its meaning has partly changed---it can be useful
@c to keep the old name as an @emph{alias} of the new one for
@c compatibility.  You can do this with @code{defvaralias}.

@defun defvaralias new-alias base-variable &optional docstring
Функция определяет символ @var{new-alias} в качестве синонима
для символа @var{base-variable}. Это означает что  получение
значения @var{new-alias} возвращает значение @var{base-variable},
и изменение значения @var{new-alias} изменяет значение @var{base-variable}.
Две переменные являющиеся синонимами всегда разделяют
одно и тоже значение и одни и те же связывания.

@c This function defines the symbol @var{new-alias} as a variable alias
@c for symbol @var{base-variable}. This means that retrieving the value
@c of @var{new-alias} returns the value of @var{base-variable}, and
@c changing the value of @var{new-alias} changes the value of
@c @var{base-variable}.  The two aliased variable names always share the
@c same value and the same bindings.

Если аргумент @var{docstring} не-@code{nil}, он определяет документацию
для @var{new-alias}; иначе, псевдоним получает ту же документацию,
что и @var{base-variable}, за исключением ситуации если @var{base-variable}
тоже является синонимом. В этом случае будет взята документация
в конце цепочки из символа не являющегося псевдонимом.

@c If the @var{docstring} argument is non-@code{nil}, it specifies the
@c documentation for @var{new-alias}; otherwise, the alias gets the same
@c documentation as @var{base-variable} has, if any, unless
@c @var{base-variable} is itself an alias, in which case @var{new-alias} gets
@c the documentation of the variable at the end of the chain of aliases.

Функция возвращает @var{base-variable}.
@c This function returns @var{base-variable}.
@end defun

  Синонимы для переменных это удобный способ замены старого
имени на новое. @code{make-obsolete-variable} указывает, что
старое имя является устаревшим и может быть удалено в будущем.

@c   Variable aliases are convenient for replacing an old name for a
@c variable with a new name.  @code{make-obsolete-variable} declares that
@c the old name is obsolete and therefore that it may be removed at some
@c stage in the future.

@defun make-obsolete-variable obsolete-name current-name when &optional access-type
Функция приводит к тому, что при байт компиляции выдается предупреждение
а том что @var{obsolete-name} устаревшая. Если @var{current-name} символ,
для которого новое имя @var{current-name}, в предупреждении будет сказано,
что стоит использовать @var{current-name}. Если @var{current-name} строка,
она является сообщением и заменяемой переменной нет. Аргумент @var{when} должен быть
строкой указывающей на то, когда переменная была сделана устаревшей (как правило номер версии).

@c This function makes the byte compiler warn that the variable
@c @var{obsolete-name} is obsolete.  If @var{current-name} is a symbol,
@c it is the variable's new name; then the warning message says to use
@c @var{current-name} instead of @var{obsolete-name}.  If
@c @var{current-name} is a string, this is the message and there is no
@c replacement variable.  @var{when} should be a string indicating when
@c the variable was first made obsolete (usually a version number
@c string).

Не обязательный аргумент @var{acces-type}, если не-@code{nil}, должен
определять вид доступа вызывающего предупреждение об устаревании; значение
может быть @code{get} или @code{set}.

@c The optional argument @var{access-type}, if non-@code{nil}, should
@c specify the kind of access that will trigger obsolescence warnings; it
@c can be either @code{get} or @code{set}.
@end defun

  Можно сделать синоним и объявить переменную устаревшей с помощью
макроса @code{define-obsolete-variable-alias}.

@c   You can make two variables synonyms and declare one obsolete at the
@c same time using the macro @code{define-obsolete-variable-alias}.

@defmac define-obsolete-variable-alias obsolete-name current-name &optional when docstring
Макрос помечает переменную @var{obsolete-name} как устаревшую и делает
ее синонимом для переменной @var{current-name}. Он эквивалентен следующему:

@c This macro marks the variable @var{obsolete-name} as obsolete and also
@c makes it an alias for the variable @var{current-name}.  It is
@c equivalent to the following:

@example
(defvaralias @var{obsolete-name} @var{current-name} @var{docstring})
(make-obsolete-variable @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

@defun indirect-variable variable
Функция возвращает переменную в конце цепочки синонимом @var{variable}.
Если @var{variable} не символ, или @var{variable} не определена
как синоним, функция возвращает @var{variable}.

@c This function returns the variable at the end of the chain of aliases
@c of @var{variable}.  If @var{variable} is not a symbol, or if @var{variable} is
@c not defined as an alias, the function returns @var{variable}.

Функция сигнализирует об ошибке @code{cyclic-variable-indirection} если
есть цикл в цепочке символов,

@c This function signals a @code{cyclic-variable-indirection} error if
@c there is a loop in the chain of symbols.
@end defun

@example
(defvaralias 'foo 'bar)
(indirect-variable 'foo)
     @result{} bar
(indirect-variable 'bar)
     @result{} bar
(setq bar 2)
bar
     @result{} 2
@group
foo
     @result{} 2
@end group
(setq foo 0)
bar
     @result{} 0
foo
     @result{} 0
@end example

@node Variables with Restricted Values
@section Переменные С Ограничением На Значения
@cindex lisp variables defined in C, restrictions

  Как правило Lisp переменной может быть присвоено значение
любого Lisp объекта. Но некоторые Lisp переменные не определены
в Lisp, а определены в C. Большинство таких переменных
определено в C коде с использованием @code{DEFVAR_LISP}. Как и переменные
определенные в Lisp, такие переменные могут принимать любые значения.
Но, некоторые переменные определены с использованием
@code{DEFVAR_INT} или @code{DEFVAR_BOOL}. @xref{Defining Lisp variables in C,,
Writing Emacs  Primitives}, для получения информации по функциям вида
@code{syms_of_@var{filename}}, и краткого обсуждения реализации C.

@c   Ordinary Lisp variables can be assigned any value that is a valid
@c Lisp object.  However, certain Lisp variables are not defined in Lisp,
@c but in C@.  Most of these variables are defined in the C code using
@c @code{DEFVAR_LISP}.  Like variables defined in Lisp, these can take on
@c any value.  However, some variables are defined using
@c @code{DEFVAR_INT} or @code{DEFVAR_BOOL}.  @xref{Defining Lisp
@c variables in C,, Writing Emacs Primitives}, in particular the
@c description of functions of the type @code{syms_of_@var{filename}},
@c for a brief discussion of the C implementation.

  Переменные типа @code{DEFVAR_BOOL} могут содержать только значения
@code{nil} или @code{t}. Попытка присвоить им другое значение привет
к присвоению @code{t}:

@c   Variables of type @code{DEFVAR_BOOL} can only take on the values
@c @code{nil} or @code{t}.  Attempting to assign them any other value
@c will set them to @code{t}:

@example
(let ((display-hourglass 5))
  display-hourglass)
     @result{} t
@end example

@defvar byte-boolean-vars
This variable holds a list of all variables of type @code{DEFVAR_BOOL}.
@end defvar

  Переменные тип @code{DEFVAR_INT} могут хранить только целые значение.
Попытка присвоить им другое значение приведет к ошибке:
  
@c   Variables of type @code{DEFVAR_INT} can take on only integer values.
@c Attempting to assign them any other value will result in an error:

@example
(setq undo-limit 1000.0)
@error{} Wrong type argument: integerp, 1000.0
@end example

@node Generalized Variables
@section Обобщенные Переменные

@cindex generalized variable
@cindex place form
@dfn{Обобщенные переменные} (@dfn{generalized variables}) одно из многих мест
в памяти Lisp где могут хранится значения. Простейшая форма такого места это
обычная Lisp переменная. Но @sc{car} и @sc{cdr} списка, элементы массивов,
свойства символов, и многие другие места так же используются Lisp для
хранения значений.

@c A @dfn{generalized variable} or @dfn{place form} is one of the many places
@c in Lisp memory where values can be stored.  The simplest place form is
@c a regular Lisp variable.  But the @sc{car}s and @sc{cdr}s of lists, elements
@c of arrays, properties of symbols, and many other locations are also
@c places where Lisp values are stored.

Обобщенные переменные являются аналогом lvalues в C, где
@samp{x = a[i]} получает элемент из массива и @samp{a[i] = x}
сохраняет значение элемента используя ту же запись. Так же
как формы вроде @code{a[i]} могут быть lvalues в C, есть некоторое
множество формы которые могут быть обобщенными переменными в Lisp.

@c Generalized variables are analogous to lvalues in the C
@c language, where @samp{x = a[i]} gets an element from an array
@c and @samp{a[i] = x} stores an element using the same notation.
@c Just as certain forms like @code{a[i]} can be lvalues in C, there
@c is a set of forms that can be generalized variables in Lisp.

@menu
* Setting Generalized Variables::   Макрос @code{setf}.
* Adding Generalized Variables::    Определение новой @code{setf} формы.
@end menu

@node Setting Generalized Variables
@subsection Макрос @code{setf}

 Макрос @code{setf} является базовым способом работы с обобщенными переменными.
Формы @code{setf} как @code{setq}, за исключением того, что
принимает произвольную форму в качестве левого аргумента, а не только
символ. Например, @code{(setf (car a) b)} устанавливает car
@code{a} в @code{b}, так же как @code{(setcar a b)}, но без
необходимости помнить две разных функции для установки и получения значения.

@c The @code{setf} macro is the most basic way to operate on generalized
@c variables.  The @code{setf} form is like @code{setq}, except that it
@c accepts arbitrary place forms on the left side rather than just
@c symbols.  For example, @code{(setf (car a) b)} sets the car of
@c @code{a} to @code{b}, doing the same operation as @code{(setcar a b)},
@c but without having to remember two separate functions for setting and
@c accessing every type of place.

@defmac setf [place form]@dots{}
Макрос вычисляет @var{form} и сохраняет ее в @var{place}, которое
должно быть корректной формой обобщенной переменой. Если есть
несколько @var{place} и @var{form}, присваивание выполняется последовательно
так же как и в форме @code{setq}. @code{setf} возвращает значение последней
@var{form}.

@c This macro evaluates @var{form} and stores it in @var{place}, which
@c must be a valid generalized variable form.  If there are several
@c @var{place} and @var{form} pairs, the assignments are done sequentially
@c just as with @code{setq}.  @code{setf} returns the value of the last
@c @var{form}.
@end defmac

Следующий Lisp формы могут работать как обобщенные переменные, и
поэтому могут использоваться в качестве аргумента @var{place} в
@code{setf}:

@c The following Lisp forms will work as generalized variables, and
@c so may appear in the @var{place} argument of @code{setf}:

@itemize
@item
Символ. Если точнее, то @code{(setf x y)} тоже самое, что
@code{(setq x y)}, и @code{setq} строго говоря излишняя функция если
есть @code{setf}. Многие программисты продолжают использовать @code{setq}
для установки простых переменных, исключительно по историческим
или стилистическим причинам. Макрос @code{(setf x y)} раскрывается в
@code{(setq x y)}, поэтому по производительности разницы у скомпилированного
кода не будет.

@c A symbol naming a variable.  In other words, @code{(setf x y)} is
@c exactly equivalent to @code{(setq x y)}, and @code{setq} itself is
@c strictly speaking redundant given that @code{setf} exists.  Many
@c programmers continue to prefer @code{setq} for setting simple
@c variables, though, purely for stylistic or historical reasons.
@c The macro @code{(setf x y)} actually expands to @code{(setq x y)},
@c so there is no performance penalty for using it in compiled code.

@item
Вызов любой из следующих стандартных Lisp функций:
@c A call to any of the following standard Lisp functions:

@smallexample
aref      cddr      symbol-function
car       elt       symbol-plist
caar      get       symbol-value
cadr      gethash
cdr       nth
cdar      nthcdr
@end smallexample

@item
Вызов любой из следующих специфичных для Emacs функций:
@c A call to any of the following Emacs-specific functions:

@smallexample
alist-get                     process-get
frame-parameter               process-sentinel
terminal-parameter            window-buffer
keymap-parent                 window-display-table
match-data                    window-dedicated-p
overlay-get                   window-hscroll
overlay-start                 window-parameter
overlay-end                   window-point
process-buffer                window-start
process-filter                default-value
@end smallexample
@end itemize

@noindent
@code{setf} сигнализирует об ошибке если передать @var{place} форму которую
Lisp не знает как обработать.

@c @code{setf} signals an error if you pass a @var{place} form that it
@c does not know how to handle.

@c And for cl-lib's cl-getf.
Стоит отметить, что для @code{nthcdr}, списочный аргумент функции должен
быть корректной @var{place} формой. Например @code{(setf (nthcdr 0 foo 7))}
установит @code{foo} в 7.

@c Note that for @code{nthcdr}, the list argument of the function must
@c itself be a valid @var{place} form.  For example, @code{(setf (nthcdr
@c 0 foo) 7)} will set @code{foo} itself to 7.
@c The use of @code{nthcdr} as a @var{place} form is an extension
@c to standard Common Lisp.

@c FIXME I don't think is a particularly good way to do it,
@c but these macros are introduced before generalized variables are.

Макрос @code{push} (@pxref{List Variables}) и @code{pop}
(@pxref{List Elements}) могут работать с обобщенными переменными
а не только со списками. @code{pop @var{place}} удаляет и возвращает
первый элемент списка хранящегося в @var{place}. Что является аналогом
@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))},
за исключением того, что все под-формы вычисляются только один раз.
@code{(push @var{x} @var{place})} вставляет @var{x} в начало списка
хранящегося в @var{place}. Форма эквивалента
@code{(setf @var{place} (cons @var{x} @var{place}))}, за исключение
того что под-формы вычисляются один раз. Стоит отметить, что
использование @code{push} и @code{pop} для @code{nthcdr} могут
быть использованы для вставки и удаления в любое место списка.

@c The macros @code{push} (@pxref{List Variables}) and @code{pop}
@c (@pxref{List Elements}) can manipulate generalized variables,
@c not just lists.  @code{(pop @var{place})} removes and returns the first
@c element of the list stored in @var{place}.  It is analogous to
@c @code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))},
@c except that it takes care to evaluate all subforms only once.
@c @code{(push @var{x} @var{place})} inserts @var{x} at the front of
@c the list stored in @var{place}.  It is analogous to @code{(setf
@c @var{place} (cons @var{x} @var{place}))}, except for evaluation of the
@c subforms.  Note that @code{push} and @code{pop} on an @code{nthcdr}
@c place can be used to insert or delete at any position in a list.

Библиотека @file{cl-lib} определяет разные расширения для обобщенных
переменных, включая дополнительные @code{setf} места.
@xref{Generalized Variables,,, cl, Common Lisp Extensions}.

@c The @file{cl-lib} library defines various extensions for generalized
@c variables, including additional @code{setf} places.
@c @xref{Generalized Variables,,, cl, Common Lisp Extensions}.


@node Adding Generalized Variables
@subsection Определение новых @code{setf} форм

Данный раздел описывает как определить новую формы с которой сможет
работать @code{setf}.

@c This section describes how to define new forms that @code{setf} can
@c operate on.

@defmac gv-define-simple-setter name setter &optional fix-return
Макрос позволяет просто определить @code{setf} методы в простых случаях.
@var{name} имя функции, макроса, или специальной формы.
Макрос может быть использован когда @var{name} имеет
прямо заданную функцию @var{setter} для обновления, например:
@code{(gv-define-simple-setter car setcar)}.

@c This macro enables you to easily define @code{setf} methods for simple
@c cases.  @var{name} is the name of a function, macro, or special form.
@c You can use this macro whenever @var{name} has a directly
@c corresponding @var{setter} function that updates it, e.g.,
@c @code{(gv-define-simple-setter car setcar)}.

Макрос преобразует вызов в форму
@c This macro translates a call of the form

@example
(setf (@var{name} @var{args}@dots{}) @var{value})
@end example

в
@c into
@example
(@var{setter} @var{args}@dots{} @var{value})
@end example

@noindent
Так как по описанию @code{setf} возвращает @var{value}. Нет проблем
например с, @code{car} и @code{setcar}, потому что @code{setcar} возвращает
установленное значение. Если @var{setter} не возвращает установленное
значение @var{value}, нужно использовать не-@code{nil} значение для
@var{fix-return} аргумента @code{gv-define-simple-setter}. Тогда
макрос будет раскрываться примерно таким образом:

@c Such a @code{setf} call is documented to return @var{value}.  This is
@c no problem with, e.g., @code{car} and @code{setcar}, because
@c @code{setcar} returns the value that it set.  If your @var{setter}
@c function does not return @var{value}, use a non-@code{nil} value for
@c the @var{fix-return} argument of @code{gv-define-simple-setter}.  This
@c expands into something equivalent to
@example
(let ((temp @var{value}))
  (@var{setter} @var{args}@dots{} temp)
  temp)
@end example
Таким образом гарантируя возвращение корректного значения.
@c so ensuring that it returns the correct result.
@end defmac


@defmac gv-define-setter name arglist &rest body
Данный макрос позволяет задать обработку @code{setf} в более
сложных случаях, чем предыдущий. Данная форма может понадобится, например,
если нет простой функции установки значения для вызова, или если у такой
функции другие аргументы для сохранения значения.

@c This macro allows for more complex @code{setf} expansions than the
@c previous form.  You may need to use this form, for example, if there
@c is no simple setter function to call, or if there is one but it
@c requires different arguments to the place form.

Макрос раскрывает в форму
@code{(setf (@var{name} @var{args}@dots{}) @var{value})}
со связыванием @code{setf} форм аргументов
@code{(@var{value} @var{args}@dots{})} в соответствии с @var{argslist}.
После чего выполняется @var{body}. @var{body} должно возвращать
Lisp форму которая выполняет присваивание, и в завершении вернуть значение
которое было установлено. Пример использования макроса:

@c This macro expands the form
@c @code{(setf (@var{name} @var{args}@dots{}) @var{value})} by
@c first binding the @code{setf} argument forms
@c @code{(@var{value} @var{args}@dots{})} according to @var{arglist},
@c and then executing @var{body}.  @var{body} should return a Lisp
@c form that does the assignment, and finally returns the value that was
@c set.  An example of using this macro is:

@example
(gv-define-setter caar (val x) `(setcar (car ,x) ,val))
@end example
@end defmac

@findex gv-define-expander
@findex gv-letplace
@c FIXME?  Not sure what or how much to say about these.
@c See cl.texi for an example of using gv-letplace.
Чтобы получить больше контроля над раскрытием макрос, стоит
рассмотреть макрос @code{gv-define-expander}. Макрос @code{gv-letplace} может
быть полезен в определении макросов которые работают аналогично @code{setf};
например макрос @code{incf} из Common Lisp. Больше информации можно
получить из @file{gv.el}.

@c For more control over the expansion, see the macro @code{gv-define-expander}.
@c The macro @code{gv-letplace} can be useful in defining macros that
@c perform similarly to @code{setf}; for example, the @code{incf} macro
@c of Common Lisp.  Consult the source file @file{gv.el} for more details.

@cindex CL note---no @code{setf} functions
@quotation
@b{Common Lisp примечание:} Common Lisp определяет другой способ
задания @code{setf} поведения, путем задания так называемых
@code{setf} функций. Имена таких функций являются списками @code{(setf @var{name})}
а не символы. Например @code{(defun (setf foo) @dots{})} определит
функцию которая будет использоваться для @code{foo}. Emacs такую
возможность не поддерживает. В случае использования
@code{setf} с формой которая не имеет подходящего способа раскрытия
будет ошибка на этапе компиляции. В Common Lisp ошибки не будет
так как функция @code{(setf @var{func})} может быть объявлена позднее.

@c @b{Common Lisp note:} Common Lisp defines another way to specify the
@c @code{setf} behavior of a function, namely @code{setf} functions,
@c whose names are lists @code{(setf @var{name})} rather than symbols.
@c For example, @code{(defun (setf foo) @dots{})} defines the function
@c that is used when @code{setf} is applied to @code{foo}.  Emacs does
@c not support this.  It is a compile-time error to use @code{setf} on a
@c form that has not already had an appropriate expansion defined.  In
@c Common Lisp, this is not an error since the function @code{(setf
@c @var{func})} might be defined later.
@end quotation
