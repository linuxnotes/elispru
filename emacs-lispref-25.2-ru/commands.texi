@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2017 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Command Loop
@chapter Командный Цикл
@c @chapter Command Loop
@cindex editor command loop
@cindex command loop

  Когда Emacs запускается, он входит в @dfn{командый цикл
редактора}(@dfn{editor command loop}) почти сразу.  Цикл считывает
последовательности клавиш, выполняет соответствующие им действия и
отображает результаты. В данной главе, опиысывается выполнение
указанных действий и функции за них отвечающие.
  
@c   When you run Emacs, it enters the @dfn{editor command loop} almost
@c immediately.  This loop reads key sequences, executes their definitions,
@c and displays the results.  In this chapter, we describe how these things
@c are done, and the subroutines that allow Lisp programs to do them.

@menu
* Command Overview::    Как командый цикл считывает команды.
* Defining Commands::   Определение того, как функция должна считывать аргументы.
* Interactive Call::    Вызов интерактивной команды и считывание аргументов.
* Distinguish Interactive::  Создание команды, определяющей интерактивный вызов.
* Command Loop Info::   Переменные устанавливаемые командным циклом,
                            позволяющие получить различную информацию.
* Adjusting Point::     Выравнивание курсора после команды.
* Input Events::        Как выглядит ввод при чтении.
* Reading Input::       Как считывать события ввода с клавиатуры или мыши.
* Special Events::      События обрабатываемые сразу и независимо.
* Waiting::             Ожидание пользовательского ввода или время ожидания.
* Quitting::            Как работает @kbd{C-g}.  Как впоймать отложенный выход.
* Prefix Command Arguments::    Как работает установка префиксного аргумента для команды.
* Recursive Editing::   Вход в рекурсивное редактирование, и почем обычно оно не нужно.
* Disabling Commands::  Как командный цикл обрабатывает выключенные команды.
* Command History::     Как устанавливается история команд, и как к ней обращаться.
* Keyboard Macros::     Как реализоаваны клавиатурные макросы.
@end menu

@c @menu
@c * Command Overview::    How the command loop reads commands.
@c * Defining Commands::   Specifying how a function should read arguments.
@c * Interactive Call::    Calling a command, so that it will read arguments.
@c * Distinguish Interactive::     Making a command distinguish interactive calls.
@c * Command Loop Info::   Variables set by the command loop for you to examine.
@c * Adjusting Point::     Adjustment of point after a command.
@c * Input Events::        What input looks like when you read it.
@c * Reading Input::       How to read input events from the keyboard or mouse.
@c * Special Events::      Events processed immediately and individually.
@c * Waiting::             Waiting for user input or elapsed time.
@c * Quitting::            How @kbd{C-g} works.  How to catch or defer quitting.
@c * Prefix Command Arguments::    How the commands to set prefix args work.
@c * Recursive Editing::   Entering a recursive edit,
@c                           and why you usually shouldn't.
@c * Disabling Commands::  How the command loop handles disabled commands.
@c * Command History::     How the command history is set up, and how accessed.
@c * Keyboard Macros::     How keyboard macros are implemented.
@c @end menu

@node Command Overview
@section Обзор Командного Цикла
@c @section Command Loop Overview

  Считывание последовательностей клавиш или событий ввода и преобразование
их в команды главное, что делает командный цикл. Для этого
используется функция @code{read-key-sequence}, которую могут
вызывать и Lisp программы (@pxref{Key Sequence Input}).
Кроме того последовательности ввода можно считывать низкоуровнево
с помощью @code{read-key} или @code{read-event} (@pxref{Reading One Event}),
ожидающий ввод можно отбросить с помощью команды @code{discard-input} (@pxref{Event Input Misc}).

@c   The first thing the command loop must do is read a key sequence,
@c which is a sequence of input events that translates into a command.
@c It does this by calling the function @code{read-key-sequence}.  Lisp
@c programs can also call this function (@pxref{Key Sequence Input}).
@c They can also read input at a lower level with @code{read-key} or
@c @code{read-event} (@pxref{Reading One Event}), or discard pending
@c input with @code{discard-input} (@pxref{Event Input Misc}).

  Последовательность клавиш преобразуется в команду используя
текущую активную раскладку. Как это делается описано @xref{Key Lookup}.
Результатом должен быть клавиатурный макрос или интерактивная функция.
Если клавиша @kbd{M-x}, тогда считыавется другая команда, которая
потом вызывается, команда @code{execute-extended-command} (@pxref{Interactive Call}).

@c   The key sequence is translated into a command through the currently
@c active keymaps.  @xref{Key Lookup}, for information on how this is done.
@c The result should be a keyboard macro or an interactively callable
@c function.  If the key is @kbd{M-x}, then it reads the name of another
@c command, which it then calls.  This is done by the command
@c @code{execute-extended-command} (@pxref{Interactive Call}).

  Перед выполнение команды Emacs вызывает @code{undo-bounday},
чтобы отменить границу между функциональными единицами отмены
(дальше просто единицы отмены). @xref{Maintaining Undo}.

@c   Prior to executing the command, Emacs runs @code{undo-boundary} to
@c create an undo boundary.  @xref{Maintaining Undo}.
  При выполнении команды Emacs сначала считывает аргументы,
используя вызов @code{command-execute} (@pxref{Interactive Call}).
Для команд написанных на Lisp, способ считывания аргументов указывается
в спецификации @code{interactive}. При считывании аргументов
может использоваться префикс-аргумент (@pxref{Prefix Command Arguments})
или может использоваться мини-буфер для запроса аргументов
(@pxref{Minibuffers}). Например, для комнады @code{find-file}
в спецификации @code{interactive} указывается, что имя файла
должно считываться в мини-буфере. Тело функции @code{find-file}
не использует мини-буфер, поэтому при вызове @code{find-file}
из Lisp кода, имя файла должно передаваться как обычный аргумент Lisp
функции.

@c   To execute a command, Emacs first reads its arguments by calling
@c @code{command-execute} (@pxref{Interactive Call}).  For commands
@c written in Lisp, the @code{interactive} specification says how to read
@c the arguments.  This may use the prefix argument (@pxref{Prefix
@c Command Arguments}) or may read with prompting in the minibuffer
@c (@pxref{Minibuffers}).  For example, the command @code{find-file} has
@c an @code{interactive} specification which says to read a file name
@c using the minibuffer.  The function body of @code{find-file} does not
@c use the minibuffer, so if you call @code{find-file} as a function from
@c Lisp code, you must supply the file name string as an ordinary Lisp
@c function argument.

  Если команда является клавиатурным макросом (то есть строкой
или вектором), Emacs выполняет ее вызывая @code{execute-kbd-macro}
(@pxref{Keyboard Macros}).

@c   If the command is a keyboard macro (i.e., a string or vector),
@c Emacs executes it using @code{execute-kbd-macro} (@pxref{Keyboard
@c Macros}).

@defvar pre-command-hook
Обычный перехватчик, запускаемый циклом команд перед выполнением
каждой команды. Во время выполнения перехватчика @code{this-command}
указывает на команду, которая должна выполнится, а @code{last-command}
указывает на предыдущую команду. @xref{Command Loop Info}.

@c This normal hook is run by the editor command loop before it executes
@c each command.  At that time, @code{this-command} contains the command
@c that is about to run, and @code{last-command} describes the previous
@c command.  @xref{Command Loop Info}.
@end defvar

@defvar post-command-hook
Обычный перехватчик, запускаемый командным циклом после выполнения
каждой команды (включая команды завершившиеся преждевремнно
в результате выхода или ошибки). Во время выполнения перехватчика
@code{this-command} указывает на только что выполненную команду,
а @code{last-command} указывает на предыдущую выполненную команду.

@c This normal hook is run by the editor command loop after it executes
@c each command (including commands terminated prematurely by quitting or
@c by errors).  At that time, @code{this-command} refers to the command
@c that just ran, and @code{last-command} refers to the command before
@c that.

Данный перехватчик так же выполняется в начале цикла команд,
при этом @code{this-command} и @code{last-command} оба @code{nil}.

@c This hook is also run when Emacs first enters the command loop (at
@c which point @code{this-command} and @code{last-command} are both
@c @code{nil}).
@end defvar

  Выход подавляется при выполнении @code{pre-command-hook} и
@code{post-command-hook}, то есть если случается ошибка при
выполнении одного из перехватичиков, выполнение перехватчика не
прекращается. При это ошибка замалчивается, а функция в которой
произошла ошибка удаляется из перехватчика.

@c   Quitting is suppressed while running @code{pre-command-hook} and
@c @code{post-command-hook}.  If an error happens while executing one of
@c these hooks, it does not terminate execution of the hook; instead
@c the error is silenced and the function in which the error occurred
@c is removed from the hook.

  Запрос приходящий на Emacs Server (@pxref{Emacs Server,,, emacs, The GNU Emacs Manual}
запускает оба этих перехватчика, только для команд клавиатуры.

@c   A request coming into the Emacs server (@pxref{Emacs Server,,,
@c emacs, The GNU Emacs Manual}) runs these two hooks just as a keyboard
@c command does.

@node Defining Commands
@section Определение Команд
@c @section Defining Commands
@cindex defining commands
@cindex commands, defining
@cindex functions, making them interactive
@cindex interactive function

  Специальная форма @code{interactive} превращает Lisp функцию в
команду. Форма @code{interactive} должна находится на верхнем уровне
теле, и как правило является первой формой в теле. Форма работает
с lambda выражением (@pxref{Lambda Expressions}) и @code{defun} формами
(@pxref{Defining Functions}). При выполнении функции форма ничего
не делеает, но она представляет собой флаг для Emacs, указывающий,
что функция может быть вызвана интерактивно. Аргументы формы @code{interactive}
определяют как должны считывыаться аргументы для фунцкии
при интерактивном вызове.

@c   the special form @code{interactive} turns a Lisp function into a
@c command.  The @code{interactive} form must be located at top-level in
@c the function body, usually as the first form in the body; this applies
@c to both lambda expressions (@pxref{Lambda Expressions}) and
@c @code{defun} forms (@pxref{Defining Functions}).  This form does
@c nothing during the actual execution of the function; its presence
@c serves as a flag, telling the Emacs command loop that the function can
@c be called interactively.  The argument of the @code{interactive} form
@c specifies how the arguments for an interactive call should be read.

@cindex @code{interactive-form} property
  Вместо использования формы @code{interactive}, можно задать
свойство @code{interactive-form} символа функции. Свойство
имеет преимущество перед формой @code{interactive}. Эта
возможность редко используется.

@c   Alternatively, an @code{interactive} form may be specified in a
@c function symbol's @code{interactive-form} property.  A non-@code{nil}
@c value for this property takes precedence over any @code{interactive}
@c form in the function body itself.  This feature is seldom used.

@anchor{The interactive-only property}
@cindex @code{interactive-only} property
  Некоторые функции должны вызываться только интерактивно и никогда
напрямую из Lisp кода. В таких случаях функции нужно задавать
свойство @code{interactive-only} (не-@code{nil}), напрямую, либо
через @code{declare} форму (@pxref{Declare Form}). Байт компилятор
будет выдаваться предупреждение если эти команды будут вызываться
из Lisp. Вывод @code{describe-function} будет включать схожую информацию.
Значением свойства может быть строка, которая будет использоваься
байт-компилятором для показа предупреждения (строка должна оканчиваться
периодом (видимо точка) и не должна начинаться с заглавной буквы,
например, @code{"use (system-name) intead."}); @code{t}; любым другим
символом, который будет использоваться в качестве альтернативной
функции для Lisp кода.

@c   Sometimes, a function is only intended to be called interactively,
@c never directly from Lisp.  In that case, give the function a
@c non-@code{nil} @code{interactive-only} property, either directly
@c or via @code{declare} (@pxref{Declare Form}).  This causes the
@c byte compiler to warn if the command is called from Lisp.  The output
@c of @code{describe-function} will include similar information.
@c The value of the property can be: a string, which the byte-compiler
@c will use directly in its warning (it should end with a period, and not
@c start with a capital, e.g., @code{"use (system-name) instead."}); @code{t}; any
@c other symbol, which should be an alternative function to use in Lisp
@c code.

@menu
* Using Interactive::     Основные правила формы @code{interactive}.
* Interactive Codes::     Стандартные сивольные кода используемые для
                              чтения различных аргументов.
* Interactive Examples::  Примеры считывания интерактивных аргументов.
* Generic Commands::      Выбор среди разных схожих команд.
@end menu

@c @menu
@c * Using Interactive::     General rules for @code{interactive}.
@c * Interactive Codes::     The standard letter-codes for reading arguments
@c                              in various ways.
@c * Interactive Examples::  Examples of how to read interactive arguments.
@c * Generic Commands::      Select among command alternatives.
@c @end menu

@node Using Interactive
@subsection Использование @code{interactive}
@c @subsection Using @code{interactive}
@cindex arguments, interactive entry
@cindex interactive spec, using

  Раздел расказывает как написать @code{interactive} форму, превращающую
Lisp функцию в интерактивную команду, и как посмотреть форму @code{interactive}
команды.

@c   This section describes how to write the @code{interactive} form that
@c makes a Lisp function an interactively-callable command, and how to
@c examine a command's @code{interactive} form.

@defspec interactive arg-descriptor
Специальная форма обьявляет функцию командой, т.е. она может
вызываться интерактивно (черзе @kbd{M-x} или при вводе связанной с ней
клавиатурной комбинации). Аргумент @var{arg-descriptor} определяет как
вычислять аргументы для команды, когда она вызывается интерактивно.

@c This special form declares that a function is a command, and that it
@c may therefore be called interactively (via @kbd{M-x} or by entering a
@c key sequence bound to it).  The argument @var{arg-descriptor} declares
@c how to compute the arguments to the command when the command is called
@c interactively.

Команда может вызываться из Lisp программ как любая другая функция,
но тогда вызывающий код должен предоставить аргументы и @var{arg-descriptor}
не используется.

@c A command may be called from Lisp programs like any other function, but
@c then the caller supplies the arguments and @var{arg-descriptor} has no
@c effect.

@cindex @code{interactive-form}, symbol property
Форма @code{interactive} должна нахоидтся на верхнем уровне
тела функции, или в свойстве @code{interactive-from} символа
функции (@pxref{Symbol Properties}). Цикла команд проверяет наличие данной
формы перед вызовом функции (@pxref{Interactive Call}). Когда
функция вызывается выполняется форма тела, и если в теле есть @code{interactive}
форма, она просто возвращает @code{nil}, даже без вычисления своих аргументов.

@c The @code{interactive} form must be located at top-level in the
@c function body, or in the function symbol's @code{interactive-form}
@c property (@pxref{Symbol Properties}).  It has its effect because the
@c command loop looks for it before calling the function
@c (@pxref{Interactive Call}).  Once the function is called, all its body
@c forms are executed; at this time, if the @code{interactive} form
@c occurs within the body, the form simply returns @code{nil} without
@c even evaluating its argument.

Негласная договоренность предписывает помещать форму @code{interactive}
в первую форму тела функции. Свойство @code{interactive-form} имеет
приоритет над @code{interactive} формой, если
заданы оба. Свойство символа @code{interactive-form} может использоваться
для доавбления интерактивности в сущестующую функцию или изменения
способа обработки аргументов при интерактивном вызове, без переопределния
функции.

@c By convention, you should put the @code{interactive} form in the
@c function body, as the first top-level form.  If there is an
@c @code{interactive} form in both the @code{interactive-form} symbol
@c property and the function body, the former takes precedence.  The
@c @code{interactive-form} symbol property can be used to add an
@c interactive form to an existing function, or change how its arguments
@c are processed interactively, without redefining the function.
@end defspec

Есть три варианта аргумета @var{arg-description}:
@c There are three possibilities for the argument @var{arg-descriptor}:

@itemize @bullet
@item
Аргумент может быть не задан или быть @code{nil}, тогда команда
вызывается без аргументов. В случае если комнде требуются аргументы,
будет ошибка.

@c It may be omitted or @code{nil}; then the command is called with no
@c arguments.  This leads quickly to an error if the command requires one
@c or more arguments.

@item
Аргумент может быть строкой, представляющей последовательность
элементов разделенных символом новой строки, по одной строке
на аргумент@footnote{Некотоые элементы могут задавать два аргумента.}.
Каждый элемент состоит из кодового символа (@pxref{Interactive Codes}),
за которым может следовать строка запроса (которую некоторые
символы используют, а некоторые игнорируют). Например:

@c It may be a string; its contents are a sequence of elements separated
@c by newlines, one for each argument@footnote{Some elements actually
@c supply two arguments.}.  Each element consists of a code character
@c (@pxref{Interactive Codes}) optionally followed by a prompt (which
@c some code characters use and some ignore).  Here is an example:

@smallexample
(interactive "P\nbFrobnicate buffer: ")
@end smallexample

@noindent
Кодовый символ @samp{P} определяет, что в качестве первого аргумента
будет браться префик команды (@pxref{Prefix Command Arguments}).
@samp{bFrobnicate buffer:} запросит у пользователя имя существующего
буфера в качестве второго аргумента.

@c The code letter @samp{P} sets the command's first argument to the raw
@c command prefix (@pxref{Prefix Command Arguments}).  @samp{bFrobnicate
@c buffer: } prompts the user with @samp{Frobnicate buffer: } to enter
@c the name of an existing buffer, which becomes the second and final
@c argument.

Строка запроса может использовать @samp{%} для вставки предыдущих
значений аргументов (начиная с первого), в запрос. Подстановка выполняется
функцией @code{format-message} (@pxref{Formatting Strings}). Например,
так можно считать имя существующего буфера и новое имя
в которое его нужно переименовать:

@c The prompt string can use @samp{%} to include previous argument values
@c (starting with the first argument) in the prompt.  This is done using
@c @code{format-message} (@pxref{Formatting Strings}).  For example, here is how
@c you could read the name of an existing buffer followed by a new name to
@c give to that buffer:

@smallexample
@group
(interactive "bBuffer to rename: \nsRename buffer %s to: ")
@end group
@end smallexample

@cindex @samp{*} in @code{interactive}
@cindex read-only buffers in interactive
Если @samp{*} появится начале строки, сигнализируется ошибка,
если буфер в режиме только для чтения.

@c If @samp{*} appears at the beginning of the string, then an error is
@c signaled if the buffer is read-only.

@cindex @samp{@@} in @code{interactive}
Если @samp{@@} появится в начале строки, и если клавиатурая комбинация
для запуска команды содержит события мыши (под клавиатурной комбинацией
понимается последовательность событий ввода), тогда окно, связанное с первым
из событий выделяется до запуска команды.

@c If @samp{@@} appears at the beginning of the string, and if the key
@c sequence used to invoke the command includes any mouse events, then
@c the window associated with the first of those events is selected
@c before the command is run.

@cindex @samp{^} in @code{interactive}
@cindex shift-selection, and @code{interactive} spec
Если в начале строки есть @samp{^} и команда выполнена через
@dfn{shift-translation}, перед выполнением
команды устанавливается метка и временно активируется
регион, или расширяется активный регион. Если команды
вызвана без shift-translation и регион временно активен,
он деактивируется перед выполнением. shift-translation контролируется
на уровне пользователя с помощью @code{shift-select-mode}; см.
@ref{Shift Selection,,, emacs, The GNU Emacs Manual}.

@c If @samp{^} appears at the beginning of the string, and if the command
@c was invoked through @dfn{shift-translation}, set the mark and activate
@c the region temporarily, or extend an already active region, before the
@c command is run.  If the command was invoked without shift-translation,
@c and the region is temporarily active, deactivate the region before the
@c command is run.  Shift-translation is controlled on the user level by
@c @code{shift-select-mode}; see @ref{Shift Selection,,, emacs, The GNU
@c Emacs Manual}.

@samp{*}, @samp{@@}, @code{^} можно использовать вместе, порядок не имеет
значения. За чтение аргумента все равно отвечает оставшаяся
часть строки, которая начинается с первого символа отличного от
@samp{*}, @samp{@@}, @samp{^}.

@c You can use @samp{*}, @samp{@@}, and @code{^} together; the order does
@c not matter.  Actual reading of arguments is controlled by the rest of
@c the prompt string (starting with the first character that is not
@c @samp{*}, @samp{@@}, or @samp{^}).

@item
Может быть задано Lisp выражение не являющееся строкой. В этом
случае выражение должно быть формой, вычисление которого
возвращает список аргументов для передачи в команду. Как правило
такое выражение вызывает функции для чтение пользовательского
ввода, как правило с использованием мини-буфера (@pxref{Minibuffers})
или напрямую с клавиатуры (@pxref{Reading Input}).

@c It may be a Lisp expression that is not a string; then it should be a
@c form that is evaluated to get a list of arguments to pass to the
@c command.  Usually this form will call various functions to read input
@c from the user, most often through the minibuffer (@pxref{Minibuffers})
@c or directly from the keyboard (@pxref{Reading Input}).

Предоставление точки курсора в качестве значения аргумента довольно
распространено, но если значение считывается (с использоавнием
мини-буфера или без), стоит убедиться, что в качестве аргумента
передается целое число (а не строка). Текущий буфер может получать
вывод подпроцесса, в случае если данные подпроцесса приходят
во время ожидания ввода, положение точки курсора и метки может
измениться.

@c Providing point or the mark as an argument value is also common, but
@c if you do this @emph{and} read input (whether using the minibuffer or
@c not), be sure to get the integer values of point or the mark after
@c reading.  The current buffer may be receiving subprocess output; if
@c subprocess output arrives while the command is waiting for input, it
@c could relocate point and the mark.

Ниже пример того, как @emph{НЕ} стоит делать:
@c Here's an example of what @emph{not} to do:

@smallexample
(interactive
 (list (region-beginning) (region-end)
       (read-string "Foo: " nil 'my-history)))
@end smallexample

@noindent
Ниже пример как избежать проблемы, с помощью
получения данных точки курсора и метки после
считывания ввода с клавиатуры.

@c Here's how to avoid the problem, by examining point and the mark after
@c reading the keyboard input:

@smallexample
(interactive
 (let ((string (read-string "Foo: " nil 'my-history)))
   (list (region-beginning) (region-end) string)))
@end smallexample

@strong{Внимание:} значения аргументов не должны содержать
данные которые не могут быть считаны псоле печати. Некоторое
инструменты сохраняют @code{command-history} в файл, чтобы
потом считать ее в следующих сессиях, если аргументы команды
содержат типы данных которые печатаются как @samp{#<@dots{}>},
они не будут работать.

@c @strong{Warning:} the argument values should not include any data
@c types that can't be printed and then read.  Some facilities save
@c @code{command-history} in a file to be read in the subsequent
@c sessions; if a command's arguments contain a data type that prints
@c using @samp{#<@dots{}>} syntax, those facilities won't work.

Однако, есть несколько исключений: можно использовать
ограниченный набор выражений таких как @code{(point)},
@code{(mark)}, @code{(region-beginning)}, @code{(region-end)},
так как Emacs специальным образом умеет их распознавать
и помещает эти выражения (а не их значение) в историю команд.
Чтобы определять является ли выражение специальным,
нужно запустить команду а потом проверить значени
@code{(car command-history)}.

@c There are, however, a few exceptions: it is ok to use a limited set of
@c expressions such as @code{(point)}, @code{(mark)},
@c @code{(region-beginning)}, and @code{(region-end)}, because Emacs
@c recognizes them specially and puts the expression (rather than its
@c value) into the command history.  To see whether the expression you
@c wrote is one of these exceptions, run the command, then examine
@c @code{(car command-history)}.
@end itemize

@cindex examining the @code{interactive} form
@defun interactive-form function
Функция возвращает форму @code{interactive} для @var{function}.
Если @var{function} интерактивная (@pxref{Interactive Call}),
значением будет @code{interactive} форма @code{(interactive @var{spec})},
определяющая как будут вычисляться аругменты. Иначе, возвращается
@code{nil}. Если @var{function} символ, используется его ячейка функции.

@c This function returns the @code{interactive} form of @var{function}.
@c If @var{function} is an interactively callable function
@c (@pxref{Interactive Call}), the value is the command's
@c @code{interactive} form @code{(interactive @var{spec})}, which
@c specifies how to compute its arguments.  Otherwise, the value is
@c @code{nil}.  If @var{function} is a symbol, its function definition is
@c used.
@end defun

@node Interactive Codes
@subsection Кодовые Символы для @code{ineractive}
@c @subsection Code Characters for @code{interactive}
@cindex interactive code description
@cindex description for interactive codes
@cindex codes, interactive, description of
@cindex characters for interactive codes

   Нижи приводится список ключевых слов и их значений, которые
будут использоваться при описании кодовых символов.
@c   The code character descriptions below contain a number of key words,
@c defined here as follows:

@table @b
@item Completion
@cindex interactive completion
(Завершение.)
Предоставить авто-завершение. @kbd{TAB}, @kbd{SPC}, и @kbd{RET}
предоставляют авто-завершение имен, так как аргумент считывается
с помощью @code{completing-read} (@pxref{Completion}). @kbd{?}
отображает список возможных завершений.

@c Provide completion.  @key{TAB}, @key{SPC}, and @key{RET} perform name
@c completion because the argument is read using @code{completing-read}
@c (@pxref{Completion}).  @kbd{?} displays a list of possible completions.

@item Existing
(Существующий.)
Требуется имя существующего объекта. Некорректные имена не принимаются;
каманды выхода из минибуфера не будет работать если ввод не верен.

@c Require the name of an existing object.  An invalid name is not
@c accepted; the commands to exit the minibuffer do not exit if the current
@c input is not valid.

@item Default
@cindex default argument string
(По умолчанию.)
Значение по умолчанию, которое будет использоваться если пользователь
ничего не ввел. Значение по умолчанию зависит от кодового символа.

@c A default value of some sort is used if the user enters no text in the
@c minibuffer.  The default depends on the code character.

@item No I/O
(Без ввода-вывода.)
Кодовый символ вычисляет аргументы без считывания ввода.
Таким образом, строка запроса не используется, и если
она даже задана будет игнорироваться.

@c This code letter computes an argument without reading any input.
@c Therefore, it does not use a prompt string, and any prompt string you
@c supply is ignored.

Даже если кодовый символ не используется строку запроса, перевод строки
все равно должен присутствовать, если только это не последний
кодовый символ.

@c Even though the code letter doesn't use a prompt string, you must follow
@c it with a newline if it is not the last code character in the string.

@item Prompt
(Запрос.)
Строка запроса, следующая сразу за кодовым символом. Запрос
заканчивается в конце строки определяющией @code{interative} или
символом перевода строки (если кодовых символов несколько).

@c A prompt immediately follows the code character.  The prompt ends either
@c with the end of the string or with a newline.

@item Special
(Специальный.)
Кодовый символ имеет значение только в начале строки @code{interactive},
и не использует строку запроса или символ перевода строки, символ
одиночный и изолированный.
(Прим. То есть за ним могут сразу идти другие специальные символы или другие
символы без перевода строки или строки запроса.)

@c This code character is meaningful only at the beginning of the
@c interactive string, and it does not look for a prompt or a newline.
@c It is a single, isolated character.
@end table

@cindex reading interactive arguments
  Ниже приводятся кодовые символы, котороые можно использовать в строке
  @code{interactive}.
  @c Here are the code character descriptions for use with @code{interactive}:

@table @samp
@item *
Сигализировать ошибку если буфер в режиме только для чтения. Special.
@c Signal an error if the current buffer is read-only.  Special.

@item @@
Выбирает окно указанное в первом событии мыши ключевой
последовательности вызвавшей команду. Special.
@c Select the window mentioned in the first mouse event in the key
@c sequence that invoked this command.  Special.

@item ^
Если команда выполнилось черзе shift-translation, установить метку
и временно активировать регион, или расширить активный регион,
перед выполнение команды. Если команды выполнена без shift-translation,
и регион временно активен, деактивировать регион перед выполнением команды.
Special.

@c If the command was invoked through shift-translation, set the mark and
@c activate the region temporarily, or extend an already active region,
@c before the command is run.  If the command was invoked without
@c shift-translation, and the region is temporarily active, deactivate
@c the region before the command is run.  Special.

@item a
Имя функции (то есть символ удовлетворяющий @code{fboundp}). Existing,
Completion, Prompt.
@c A function name (i.e., a symbol satisfying @code{fboundp}).  Existing,
@c Completion, Prompt.

@item b
Имя существующего буфера. По умолчанию, используется имя текущего
буфера (@pxref{Buffers}). Existing, Completion, Default, Prompt.

@c The name of an existing buffer.  By default, uses the name of the
@c current buffer (@pxref{Buffers}).  Existing, Completion, Default,
@c Prompt.

@item B
Имя буфера. Существование буфера не обязательно. По умолчанию
используется имя предыдущего используемого буфера, отличного от
текущего. Completion, Default, Prompt.

@c A buffer name.  The buffer need not exist.  By default, uses the name of
@c a recently used buffer other than the current buffer.  Completion,
@c Default, Prompt.

@item c
Символ. Курсор не переводится в эхо область. Prompt.
@c A character.  The cursor does not move into the echo area.  Prompt.

@item C
Имя команды (т.е. символ удовлетворяющий @code{commandp}). Existing,
Completion, Prompt.

@c A command name (i.e., a symbol satisfying @code{commandp}).  Existing,
@c Completion, Prompt.

@item d
@cindex position argument
Позиция точки курсора, число (@pxref{Point}). No I/O.
@c The position of point, as an integer (@pxref{Point}).  No I/O.

@item D
Имя каталога. Значение по умолчанию каталог по умолчанию текущего буфера,
@code{default-directory} (@pxref{File Name Expansion}).
Existing, Completion, Default, Prompt.

@c A directory name.  The default is the current default directory of the
@c current buffer, @code{default-directory} (@pxref{File Name Expansion}).
@c Existing, Completion, Default, Prompt.

@item e
Первые или следующие не клавиатурное событий в последовательности
событий вызвавшей команду. Более точно, @samp{e} получает события, являющиеся
списками, и можно смотреть данные в этих списках. @xref{Input Events}. No I/O.

@c The first or next non-keyboard event in the key sequence that invoked
@c the command.  More precisely, @samp{e} gets events that are lists, so
@c you can look at the data in the lists.  @xref{Input Events}.  No I/O.

Можно использовать @samp{e}, для событий мыши и для специальных системных
событий (@pxref{Misc Events}). Список данных события, который получит команда
зависти от события. @xref{Input Events}, где описаны формы списков
для каждого события.

@c You use @samp{e} for mouse events and for special system events
@c (@pxref{Misc Events}).  The event list that the command receives
@c depends on the event.  @xref{Input Events}, which describes the forms
@c of the list for each event in the corresponding subsections.

Можно использовать @samp{e} больше одного раза для одной команды.
Если ключевая последовательность выполняющая команду имеет
@var{n} событий, представленных в виде списков, @var{n}-ое @samp{e}
будет соответствовать @var{n}-ому событию. События не являющиеся списками,
такие как функциональные клавиши и @acronym{ASCII} символы, не учитываются.

@c You can use @samp{e} more than once in a single command's interactive
@c specification.  If the key sequence that invoked the command has
@c @var{n} events that are lists, the @var{n}th @samp{e} provides the
@c @var{n}th such event.  Events that are not lists, such as function keys
@c and @acronym{ASCII} characters, do not count where @samp{e} is concerned.

@item f
Имя существующего файла (@pxref{File Names}). Каталог по умолчанию
@code{default-directory}. Existing, Completion, Default, Prompt.

@c A file name of an existing file (@pxref{File Names}).  The default
@c directory is @code{default-directory}.  Existing, Completion, Default,
@c Prompt.

@item F
Имя файла. Файл не обязан существовать. Completion, Default, Prompt.
@c A file name.  The file need not exist.  Completion, Default, Prompt.

@item G
Имя файла. Файл не обязан существовать. Если пользователь введедт
только имя каталога, тогда значением будет имя каталога, без
добавления имени файла. Completion, Default, Prompt.

@c A file name.  The file need not exist.  If the user enters just a
@c directory name, then the value is just that directory name, with no
@c file name within the directory added.  Completion, Default, Prompt.

@item i
Арумент без значения. Код подставляет @code{nil} в качестве
значения аргумента. No I/O.

@c An irrelevant argument.  This code always supplies @code{nil} as
@c the argument's value.  No I/O.

@item k
Последовательность клавиш (@pxref{Key Sequences}). Считывает события
пока команда (или неопределенность команды) не будет найдена в текущей
раскладке. Последовательность клавиш представляется в виде строки или
вектора. Курсор не перемещаяется в эхо обсласть. Prompt.

@c A key sequence (@pxref{Key Sequences}).  This keeps reading events
@c until a command (or undefined command) is found in the current key
@c maps.  The key sequence argument is represented as a string or vector.
@c The cursor does not move into the echo area.  Prompt.

Если @samp{k} считываетс последовательность заканчивающуюся событием down
(прим. видимо нажатие), так же считывается и отбрасывается следующее
up событие (прим. видимо отпускание клавиши). Получить доступ к пропущенному
up события можно с помощью кодового символа @samp{U}.

@c If @samp{k} reads a key sequence that ends with a down-event, it also
@c reads and discards the following up-event.  You can get access to that
@c up-event with the @samp{U} code character.

Данный вид ввода используется такими командами как @code{describe-key}
и @code{global-set-key}.

@c This kind of input is used by commands such as @code{describe-key} and
@c @code{global-set-key}.

@item K
Последовательность клавиш, которую нужно изменить. Работает аналогично
@samp{k}, за исключением подавления последнего события ввода,
что является соглашением, которое обычно используется (если нужно)
для преобразования не определенного ключа в определенный.
(прим. тут последнее событие up походу не подавляется).

@c A key sequence, whose definition you intend to change.  This works like
@c @samp{k}, except that it suppresses, for the last input event in the key
@c sequence, the conversions that are normally used (when necessary) to
@c convert an undefined key into a defined one.

@item m
@cindex marker argument
Позиция метки, как число. No I/O.
@c The position of the mark, as an integer.  No I/O.

@item M
Произвольный текст, считываемый в мини-буфере для текущего буфера.
Текст возвращается в виде строки (@pxref{Input Methods,,, emacs, The GNU
Emacs Manual}). Prompt.

@c Arbitrary text, read in the minibuffer using the current buffer's input
@c method, and returned as a string (@pxref{Input Methods,,, emacs, The GNU
@c Emacs Manual}).  Prompt.

@item n
Число, считываемое с помощью мини-буфера. Если ввод не число, данные
запрашиваются повторно. @samp{n} не испльзует аргумент префикс(prefix).
Prompt.

@c A number, read with the minibuffer.  If the input is not a number, the
@c user has to try again.  @samp{n} never uses the prefix argument.
@c Prompt.

@item N
Числовой префикс(prefix) аргумент, но если он не число, значение считыватся
как для @kbd{n}. Значение всегда число. @xref{Prefix Command Arguments}.
Prompt.

@c The numeric prefix argument; but if there is no prefix argument, read
@c a number as with @kbd{n}.  The value is always a number.  @xref{Prefix
@c Command Arguments}.  Prompt.

@item p
@cindex numeric prefix argument usage
Числовой префикс(prefix) аргумент. No I/O.

@c The numeric prefix argument.  (Note that this @samp{p} is lower case.)
@c No I/O.

@item P
@cindex raw prefix argument usage
Префикс аргумент как есть (raw). No I/O.
@c The raw prefix argument.  (Note that this @samp{P} is upper case.)  No
@c I/O.

@item r
@cindex region argument
Точка курсора и метка, в качестве двух числовых аргументов, первым
идет меньшее значение. Это единственный кодовый символ задающий два
последовательных аргумента, а не один. В случае, если метка в текущем
буфере, при выполнении команды не установлена сигнализируется ошибка. No I/O.

@c Point and the mark, as two numeric arguments, smallest first.  This is
@c the only code letter that specifies two successive arguments rather than
@c one.  This will signal an error if the mark is not set in the buffer
@c which is current when the command is invoked.  No I/O.

@item s
Произвольный текст, считывающийся из мини-буфера и возвращаемый
как строка (@pxref{Text from Minibuffer}). Ввод прерывается по
@kbd{C-j} и @kbd{RET}. (@kbd{C-q} может использоватсья для включения
любого из символов прерывания в ввод.) Prompt.

@c Arbitrary text, read in the minibuffer and returned as a string
@c (@pxref{Text from Minibuffer}).  Terminate the input with either
@c @kbd{C-j} or @key{RET}.  (@kbd{C-q} may be used to include either of
@c these characters in the input.)  Prompt.

@item S
Интернированный символ, имя которого считывается в мини-буфере. Прерывание
ввода выполняется @kbd{C-j} или @kbd{RET}. Другие символы обычно не входящие
в символы (например пробелы, круглый или квадратные скобки) в этом случае
ввод не прервут. Prompt.

@c An interned symbol whose name is read in the minibuffer.  Terminate
@c the input with either @kbd{C-j} or @key{RET}.  Other characters that
@c normally terminate a symbol (e.g., whitespace, parentheses and
@c brackets) do not do so here.  Prompt.

@item U
Последовательность клавишь или @code{nil}. Может использоваться
после @samp{k} или @samp{K} аргумента, для получения up(отпускания) события
которое было отброшено после считывания down события @samp{k} или @samp{K}.
Если up событие не отбрасывалось @samp{U} вернет @code{nil} в качестве
значения аргумента. No I/O.

@c A key sequence or @code{nil}.  Can be used after a @samp{k} or
@c @samp{K} argument to get the up-event that was discarded (if any)
@c after @samp{k} or @samp{K} read a down-event.  If no up-event has been
@c discarded, @samp{U} provides @code{nil} as the argument.  No I/O.

@item v
Переменная обьявленная в качестве пользовательской опции (т.е.
удовлетворяющая предикату @code{custom-variable-p}). Переменная
считывается используя @code{read-variable}. @xref{Definition of read-variable}.
Existing, Completion, Prompt.

@c A variable declared to be a user option (i.e., satisfying the
@c predicate @code{custom-variable-p}).  This reads the variable using
@c @code{read-variable}.  @xref{Definition of read-variable}.  Existing,
@c Completion, Prompt.

@item x
Lisp объект, заданный своей печатной формой (read syntax), окончание
ввода выполняется по @kbd{C-j} или @kbd{RET}. Объект не вычисляется.
@xref{Object from Minibuffer}. Prompt.

@c A Lisp object, specified with its read syntax, terminated with a
@c @kbd{C-j} or @key{RET}.  The object is not evaluated.  @xref{Object from
@c Minibuffer}.  Prompt.

@item X
@cindex evaluated expression argument
Значение Lisp формы. @samp{X} считывается как @samp{x}, после
чего значение вычисляется и вычисленное значение ставновится
аргументом дял команды. Prompt.

@c A Lisp form's value.  @samp{X} reads as @samp{x} does, then evaluates
@c the form so that its value becomes the argument for the command.
@c Prompt.

@item z
Имя кодировки (как символ). Если пользователь ничего не ввел,
будет использовано @code{nil} в качестве значение аргумента. Completion,
Existing, Prompt.

@c A coding system name (a symbol).  If the user enters null input, the
@c argument value is @code{nil}.  @xref{Coding Systems}.  Completion,
@c Existing, Prompt.

@item Z
Имя кодировки (символ) --- но только если комада имеет аргумент префикс.
Без аргумента префикса, @samp{Z} возвращает @code{nil} в качестве значения
аргумента. Completion, Existing, Prompt.

@c A coding system name (a symbol)---but only if this command has a prefix
@c argument.  With no prefix argument, @samp{Z} provides @code{nil} as the
@c argument value.  Completion, Existing, Prompt.
@end table

@node Interactive Examples
@subsection Перимеры Использования @code{interactive}
@c @subsection Examples of Using @code{interactive}
@cindex examples of using @code{interactive}
@cindex @code{interactive}, examples of using

  Несколько примерно @code{interactive}:
  @c Here are some examples of @code{interactive}:

@example
@group
(defun foo1 ()              ; @r{@code{foo1} без аргументов,}
    (interactive)           ;   @r{просто перемещение на 2 слова вперед.}
    (forward-word 2))
     @result{} foo1
@end group

@group
(defun foo2 (n)             ; @r{@code{foo2} один аргумент,}
    (interactive "^p")      ;   @r{числовое значение префикса.}
                            ; @r{при @code{shift-select-mode},}
                            ;   @r{будет активирован или расширен регион.}
    (forward-word (* 2 n)))
     @result{} foo2
@end group

@group
(defun foo3 (n)             ; @r{@code{foo3} один аргумент,}
    (interactive "nCount:") ;   @r{считываемый в мини-буфере.}
    (forward-word (* 2 n)))
     @result{} foo3
@end group

@group
(defun three-b (b1 b2 b3)
  "Select three existing buffers.
Put them into three windows, selecting the last one."
@end group
    (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
    (delete-other-windows)
    (split-window (selected-window) 8)
    (switch-to-buffer b1)
    (other-window 1)
    (split-window (selected-window) 8)
    (switch-to-buffer b2)
    (other-window 1)
    (switch-to-buffer b3))
     @result{} three-b
@group
(three-b "*scratch*" "declarations.texi" "*mail*")
     @result{} nil
@end group
@end example

@node Generic Commands
@subsection Выбор среди Альтернативных Команд
@c @subsection Select among Command Alternatives
@cindex generic commands
@cindex alternatives, defining

Макрос @code{define-alternatives} может использоваться
для определения (@dfn{обобщенных комаанд}) @dfn{generic commands}.
Это интерактивные функции, чья реализация может быть выбрана
из несокльких альтернатив в зависимости от предпочтений пользователя.

@c The macro @code{define-alternatives} can be used to define
@c @dfn{generic commands}.  These are interactive functions whose
@c implementation can be selected from several alternatives, as a matter
@c of user preference.

@defmac define-alternatives command &rest customizations
Определяет новвую комманду @var{command}, как символ.
@c Define the new command @var{command}, a symbol.

Когда пользователь запускает @kbd{M-x @var{command} @key{RET}} в первый
раз, Emacs спросит у пользователя какую форму команды использовать, и
сохранит выбор с помощью переменной настройки. Использование префикс
аргумента приведет к повторению процееса выбора альтернативы.

@c When a user runs @kbd{M-x @var{command} @key{RET}} for the first time,
@c Emacs prompts for which real form of the command to use, and records
@c the selection by way of a custom variable.  Using a prefix argument
@c repeats this process of choosing an alternative.

Переменная @code{@var{command}-alternatives} должна содержаить
ассоциативный список с альтернативами реализации команды @var{command}.
Пока переменная не установлена @code{define-alternatives} не имеет
никакого эффекта.

@c The variable @code{@var{command}-alternatives} should contain an alist
@c with alternative implementations of @var{command}.
@c Until this variable is set, @code{define-alternatives} has no effect.

Если @var{customization} не-@code{nil}, она должна состоять из
разных ключевых слов для @code{defcustom} (обычно @code{:group}
и @code{:version} и значений для них для добавления в определение
@code{@var{command}-alternatives}).

@c If @var{customizations} is non-@code{nil}, it should consist of
@c alternating @code{defcustom} keywords (typically @code{:group} and
@c @code{:version}) and values to add to the declaration of
@c @code{@var{command}-alternatives}.
@end defmac

@node Interactive Call
@section Интерактивный Вызов
@c @section Interactive Call
@cindex interactive call

  После определения командным циклом для кобинации клавиш команды,
команды выполняется функцией @code{command-execute}. Если команда
является функцией, @code{command-execute} вызывает @code{call-interactively},
которая считывает аргументы и вызывает команду. Эту фунцию можно
вызвать и вне командного цикла.

@c   After the command loop has translated a key sequence into a command,
@c it invokes that command using the function @code{command-execute}.  If
@c the command is a function, @code{command-execute} calls
@c @code{call-interactively}, which reads the arguments and calls the
@c command.  You can also call these functions yourself.

  Термин ``команда'', в данном контексте указывает на интерактивно
вызываемую функцию (или обьект схожий с функцией), или клавиатурный
макрос. Она не имеет отношения к последовательности клавиш используемой
для вызова команды (@pxref{Keymaps}).

@c   Note that the term ``command'', in this context, refers to an
@c interactively callable function (or function-like object), or a
@c keyboard macro.  It does not refer to the key sequence used to invoke
@c a command (@pxref{Keymaps}).

@defun commandp object &optional for-call-interactively
Функция возвращает @code{t} если @var{object} команда.
Иначе возвращается @code{nil}.

@c This function returns @code{t} if @var{object} is a command.
@c Otherwise, it returns @code{nil}.

Команды включают строки и векторы (которые обрабатываются как
клавиатурные макросы), ламбда (lambda) выражения которые содержат
форму @code{interactive} на верхнем уровне (@pxref{Using Interactive}),
объекты функций в байт-коде построенные по таким лямбда выражениям,
объекты автозагрузки, которые объявлены как интерактивные (не-@code{nil}
четверты аргумент в @code{autoload}), и некоторые примитивные функции.
Кроме того символ считается командой, если имеет свойство @code{interactive-form}
не-@code{nil}, или его ячейка функции удовлетворяет @code{commandp}.

@c Commands include strings and vectors (which are treated as keyboard
@c macros), lambda expressions that contain a top-level
@c @code{interactive} form (@pxref{Using Interactive}), byte-code
@c function objects made from such lambda expressions, autoload objects
@c that are declared as interactive (non-@code{nil} fourth argument to
@c @code{autoload}), and some primitive functions.  Also, a symbol is
@c considered a command if it has a non-@code{nil}
@c @code{interactive-form} property, or if its function definition
@c satisfies @code{commandp}.

Если @var{for-call-interactively} не-@code{nil}, @code{commandp}
возвращает @code{t} только для объектов которые
могут быть вызваны с помощью @code{code-interactively}---то есть
не для клавиатурных макросов.

@c If @var{for-call-interactively} is non-@code{nil}, then
@c @code{commandp} returns @code{t} only for objects that
@c @code{call-interactively} could call---thus, not for keyboard macros.

Пример использования @code{commandp} можно найти по
@code{documentation} в @ref{Accessing Documentation}.

@c See @code{documentation} in @ref{Accessing Documentation}, for a
@c realistic example of using @code{commandp}.
@end defun

@defun call-interactively command &optional record-flag keys
Функция вызывает интерактивную функцию @var{command},
с аргументами вычисляемымми по спецификации интерактивного вызоыва.
(прим. та что задается в форме @code{interactive}.) Возвращается
то, что вернет @code{command}.

@c This function calls the interactively callable function @var{command},
@c providing arguments according to its interactive calling specifications.
@c It returns whatever @var{command} returns.

Для функции со следующей сигнатурой:
@c If, for instance, you have a function with the following signature:

@example
(defun foo (begin end)
  (interactive "r")
  ...)
@end example

вызов
@c then saying

@example
(call-interactively 'foo)
@end example

вызовет @code{foo} с регионом (@code{point} и @code{mark}) в
качестве аргументов.

@c will call @code{foo} with the region (@code{point} and @code{mark}) as
@c the arguments.

В случае если @var{command} не функция или не может быть вызвана
интерактивно сигнализируется ошибка. Клавиатурные макросы
(строки и вектора) не принимаются, несмотря на то, что они считаются
коммандами, потому что они не являются функциями. Если
@var{command} символ, тогда @code{call-interactively} испольует
его определение функции.

@c An error is signaled if @var{command} is not a function or if it
@c cannot be called interactively (i.e., is not a command).  Note that
@c keyboard macros (strings and vectors) are not accepted, even though
@c they are considered commands, because they are not functions.  If
@c @var{command} is a symbol, then @code{call-interactively} uses its
@c function definition.

@cindex record command history
Если @var{record-flag} не-@code{nil}, тогда команда и аргументы
добавляется в список @code{command-history}.
Иначе, команда добавляется в список только, если использует
мини-буфер для чтения аргументов. @xref{Command History}.

@c If @var{record-flag} is non-@code{nil}, then this command and its
@c arguments are unconditionally added to the list @code{command-history}.
@c Otherwise, the command is added only if it uses the minibuffer to read
@c an argument.  @xref{Command History}.

Аргумент @var{keys}, если задан, должен быть вектором, который
определяет последовательность событий для предоставления комнаде,
если она будет запрашивать события вызвавшие ее. Если @var{keys}
не задано или @code{nil}, по умолчанию используется результа
@code{this-command-keys-vector}. @xref{Definition of this-command-keys-vector}.

@c The argument @var{keys}, if given, should be a vector which specifies
@c the sequence of events to supply if the command inquires which events
@c were used to invoke it.  If @var{keys} is omitted or @code{nil}, the
@c default is the return value of @code{this-command-keys-vector}.
@c @xref{Definition of this-command-keys-vector}.
@end defun

@defun funcall-interactively function &rest arguments
Функция работает как @code{funcall} (@pxref{Calling Functions}),
но делает вызов выглядящим как интерактивный: и вызов
@code{called-interactively-p} внутри @var{function} вернет @code{t}.
Если @var{function} не команда, она вызывается без сигнализации об
ошибке.

@c This function works like @code{funcall} (@pxref{Calling Functions}),
@c but it makes the call look like an interactive invocation: a call to
@c @code{called-interactively-p} inside @var{function} will return
@c @code{t}.  If @var{function} is not a command, it is called without
@c signaling an error.
@end defun

@defun command-execute command &optional record-flag keys special
@cindex keyboard macro execution
Функция выполняет @code{command}. Аргумент @var{command} должен
удоавлетворять предикату @code{commandp}, т.е. должен быть
интерактивной функцией или клавиатурным макросом.

@c This function executes @var{command}.  The argument @var{command} must
@c satisfy the @code{commandp} predicate; i.e., it must be an interactively
@c callable function or a keyboard macro.

Если @var{command} строка или вектор, то для вызоа
используется @code{execute-kbd-macro} (см. ниже),
вместе с аргументами @var{record-flag} и @var{keys}.

@c A string or vector as @var{command} is executed with
@c @code{execute-kbd-macro}.  A function is passed to
@c @code{call-interactively} (see above), along with the
@c @var{record-flag} and @var{keys} arguments.

Если @var{command} символ, использутся его определение функции.
Символ для которого определение @code{autoload} считается командой
если было объявлено для интерактивного вызова. Для таких определений
выполяется загрузка библиотеки и дополнительной проверки
соответствующего символа.

@c If @var{command} is a symbol, its function definition is used in its
@c place.  A symbol with an @code{autoload} definition counts as a
@c command if it was declared to stand for an interactively callable
@c function.  Such a definition is handled by loading the specified
@c library and then rechecking the definition of the symbol.

Аргумент @var{special}, если задан, приводит к игнорированию аргумента
префикса без его очистки. Используется для выполнения
специальных событий (@pxref{Special Events}).

@c The argument @var{special}, if given, means to ignore the prefix
@c argument and not clear it.  This is used for executing special events
@c (@pxref{Special Events}).
@end defun

@deffn Command execute-extended-command prefix-argument
@cindex read command name
Функция считывает имя команды из минибуфера используя
@code{completion-read} (@pxref{Completion}). Потом она
использует @code{command-exectue} для вызова указанной
комманды. Результат выполнения команды становится результатом
@code{execute-extended-command}.

@c This function reads a command name from the minibuffer using
@c @code{completing-read} (@pxref{Completion}).  Then it uses
@c @code{command-execute} to call the specified command.  Whatever that
@c command returns becomes the value of @code{execute-extended-command}.

@cindex execute with prefix argument
Если команда запрашивает аргумент префикс, она получит значение
@var{prefix-argument}. Если @code{execte-extended-command}
вызывается интерактивно, ее префикс аргумент используется
в качестве значения @var{prefix-argument}, и таким образом
передается введенной команде.

@c If the command asks for a prefix argument, it receives the value
@c @var{prefix-argument}.  If @code{execute-extended-command} is called
@c interactively, the current raw prefix argument is used for
@c @var{prefix-argument}, and thus passed on to whatever command is run.

@c !!! Should this be @kindex?
@cindex @kbd{M-x}
@code{execute-extended-command} как правило связана с @kbd{M-x},
потоэтому она использует в качестве строки запроса @w{@samp{M-x }}.
(Лучше было бы использовать в качестве запроса событие
вызова комаанды, но в реализации это боль, поэтому забили.)
Значение аргумента префикса включается в строку запроса.

@c @code{execute-extended-command} is the normal definition of @kbd{M-x},
@c so it uses the string @w{@samp{M-x }} as a prompt.  (It would be better
@c to take the prompt from the events used to invoke
@c @code{execute-extended-command}, but that is painful to implement.)  A
@c description of the value of the prefix argument, if any, also becomes
@c part of the prompt.

@example
@group
(execute-extended-command 3)
---------- Buffer: Minibuffer ----------
3 M-x forward-word RET
---------- Buffer: Minibuffer ----------
     @result{} t
@end group
@end example
@end deffn

@node Distinguish Interactive
@section Определение Интерактивных Вызовов
@c @section Distinguish Interactive Calls
@cindex distinguish interactive calls
@cindex is this call interactive

  Иногда команда должна отображать дополнительную
информацию (например информативное сообщение в эхо области) для
интерактивных вызовов. Рекомендуемым способом проверки
того, что функция вызвана с помощью @code{call-interactively}
дать ей необязательный аргумент @code{print-message} и задать в
спецификации @code{interactive} определение возвращающее не-@code{nil}.
Например:

@c   Sometimes a command should display additional visual feedback (such
@c as an informative message in the echo area) for interactive calls
@c only.  There are three ways to do this.  The recommended way to test
@c whether the function was called using @code{call-interactively} is to
@c give it an optional argument @code{print-message} and use the
@c @code{interactive} spec to make it non-@code{nil} in interactive
@c calls.  Here's an example:

@example
(defun foo (&optional print-message)
  (interactive "p")
  (when print-message
    (message "foo")))
@end example

@noindent
@code{"p"} используется, потому что числовой аргумент префикс
всегда не-@code{nil}. При таком определении, функция отобразит
сообщение при вызове из клавиатурного макроса.

@c We use @code{"p"} because the numeric prefix argument is never
@c @code{nil}.  Defined in this way, the function does display the
@c message when called from a keyboard macro.

  Приведенный способ с дополнительным аргументов, как правило
наилучший вариант, потому что предоставляет вызывающему
сказать ``рассматривай данный вызов как интерактивный''. Но
можно использовать и @code{called-interactively-p}.

@c   The above method with the additional argument is usually best,
@c because it allows callers to say ``treat this call as interactive''.
@c But you can also do the job by testing @code{called-interactively-p}.

@defun called-interactively-p kind
Функция возвращает @code{t} когда функция была вызвана с использованием
@code{call-interactively}.

@c This function returns @code{t} when the calling function was called
@c using @code{call-interactively}.

Аргумент @var{kind} должен быть символом @code{interactive} или
символом @code{any}. Если @code{interactive}, тогда @code{called-interactively-p}
вернет @code{t}, только если вызов был сделан напрямую пользователем---например,
если пользователь ввел последовательность клавиш связанную с вызываемой функцией,
но @emph{не} в случае если пользователь вызвал макрос, который вызвал функцию
(@pxref{Keyboard Macros}). Если @var{kind} @code{any}, @code{called-interactively-p}
вернет @code{t} для любого вида интерактивного вызова, в том числе клавиатурные
макросы.

@c The argument @var{kind} should be either the symbol @code{interactive}
@c or the symbol @code{any}.  If it is @code{interactive}, then
@c @code{called-interactively-p} returns @code{t} only if the call was
@c made directly by the user---e.g., if the user typed a key sequence
@c bound to the calling function, but @emph{not} if the user ran a
@c keyboard macro that called the function (@pxref{Keyboard Macros}).  If
@c @var{kind} is @code{any}, @code{called-interactively-p} returns
@c @code{t} for any kind of interactive call, including keyboard macros.

В случае сомнений стоит использовать @code{any}, единственный
известный правильный случай использования @code{interactive} если
нужно решить показывать ли пользователю вспомогательное сообщение
при выполнении функции.

@c If in doubt, use @code{any}; the only known proper use of
@c @code{interactive} is if you need to decide whether to display a
@c helpful message while a function is running.

Функция не считается вызваной интерактивно если она была вызвана
через Lisp вычисление (или через @code{apply} или @code{funcall}).

@c A function is never considered to be called interactively if it was
@c called via Lisp evaluation (or with @code{apply} or @code{funcall}).
@end defun

@noindent
Пример использования @code{called-interactively-p}:
@c Here is an example of using @code{called-interactively-p}:

@example
@group
(defun foo ()
  (interactive)
  (when (called-interactively-p 'any)
    (message "Interactive!")
    'foo-called-interactively))
@end group

@group
;; @r{Type @kbd{M-x foo}.}
     @print{} Interactive!
@end group

@group
(foo)
     @result{} nil
@end group
@end example

@noindent
Другой пример противопоставляющий прямые и не прямые вызовы
@code{called-interactively-p}.

@c Here is another example that contrasts direct and indirect calls to
@c @code{called-interactively-p}.

@example
@group
(defun bar ()
  (interactive)
  (message "%s" (list (foo) (called-interactively-p 'any))))
@end group

@group
;; @r{Type @kbd{M-x bar}.}
     @print{} (nil t)
@end group
@end example

@node Command Loop Info
@section Информация О Работе Командного Цикла
@c @section Information from the Command Loop
@cindex command loop variables

Командный цикл редактора устанавливает ряд Lisp переменных для
для хранения записей статуса для своих нужд и запускаемых команд.
За исключением переменных @code{this-command} и @code{last-command}
как правило не рекомендуется менять переменные в Lisp программах.

@c The editor command loop sets several Lisp variables to keep status
@c records for itself and for commands that are run.  With the exception of
@c @code{this-command} and @code{last-command} it's generally a bad idea to
@c change any of these variables in a Lisp program.

@defvar last-command
Переменная хранит имя предыдущей команды выполненной командным циклом
(не текущая). Как правило, но не обязательно, значением является символ у которого определена
функция.

@c This variable records the name of the previous command executed by the
@c command loop (the one before the current command).  Normally the value
@c is a symbol with a function definition, but this is not guaranteed.

Значение копируется из @code{this-command} когда очередная команда заканчивает
работу и управление возвращается в командный цикл, за исключением случаев
когда команда определеяет префикс аргумент для следующей команды.

@c The value is copied from @code{this-command} when a command returns to
@c the command loop, except when the command has specified a prefix
@c argument for the following command.

Переменная всегдла локальна для текущего терминала и не может
быть локально для буфера. @xref{Multiple Terminals}.

@c This variable is always local to the current terminal and cannot be
@c buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar real-last-command
Переменная устанавливается Emacs, аналогична @code{last-command},
но никогда не изменяется в Lisp программах.

@c This variable is set up by Emacs just like @code{last-command},
@c but never altered by Lisp programs.
@end defvar

@defvar last-repeatable-command
Переменная хранит последнюю выполненную команду, которая не является
частью события ввода. В lisp есть команда @code{repeat} которая попытается
выполнить эту команду, @xref{Repeating,,, emacs, The GNU Emacs Manual}.

@c This variable stores the most recently executed command that was not
@c part of an input event.  This is the command @code{repeat} will try to
@c repeat, @xref{Repeating,,, emacs, The GNU Emacs Manual}.
@end defvar

@defvar this-command
@cindex current command
Переменная хранит имя текущей выполняемой команды. Аналогично @code{last-command},
как правило это символ у которого определена функция.

@c This variable records the name of the command now being executed by
@c the editor command loop.  Like @code{last-command}, it is normally a symbol
@c with a function definition.

Командный цикл устанавливает эту переменную перед запуском команды,
и копирует значение в @code{last-command} когда команда заканчивает
выполнение (если команда не задает префикс для следующей команды).

@c The command loop sets this variable just before running a command, and
@c copies its value into @code{last-command} when the command finishes
@c (unless the command specified a prefix argument for the following
@c command).

@cindex kill command repetition
Некоторые команды устанавливают эту переменную при выполнении, как
флаг для следующей команды. В частности, функции для удаления
текста устанавливают @code{this-command} в @code{kill-region}, в результате
любая сразу следующая команда удаления текста будет знать, что
нужно добавить удаляемый ей текст к тексту предыдущего удаления.

@c Some commands set this variable during their execution, as a flag for
@c whatever command runs next.  In particular, the functions for killing text
@c set @code{this-command} to @code{kill-region} so that any kill commands
@c immediately following will know to append the killed text to the
@c previous kill.
@end defvar

Если нужно, чтобы команда не попадала в предыдущю команду в случае если
она завершится с ошибкой, это можно настроить несколькими способами.
Один из них установить @code{this-command} в @code{t} в начале команды,
и вернуть оригинальное значение @code{this-commmand} при успешном завершении,
например так:

@c If you do not want a particular command to be recognized as the previous
@c command in the case where it got an error, you must code that command to
@c prevent this.  One way is to set @code{this-command} to @code{t} at the
@c beginning of the command, and set @code{this-command} back to its proper
@c value at the end, like this:

@example
(defun foo (args@dots{})
  (interactive @dots{})
  (let ((old-this-command this-command))
    (setq this-command t)
    @r{@dots{}do the work@dots{}}
    (setq this-command old-this-command)))
@end example

@noindent
@code{this-command} не используется внутри @code{let}, потому что,
тогда исходное значение восстановится и в случае ошибки---возможность
@code{let} которая в данном случае сделат то, что не требуется.

@c We do not bind @code{this-command} with @code{let} because that would
@c restore the old value in case of error---a feature of @code{let} which
@c in this case does precisely what we want to avoid.

@defvar this-original-command
Переменная имеет тоже значение что и @code{this-command} за исключением
случая когда выполняется переназначение команды (@pxref{Remapping Commands}).
В этом случае @code{this-command} получает реально запущенную команду
(результат переназначения), а @code{this-original-command} получает
команду которая была задана для запуска, но была переназначена на другую команду.

@c This has the same value as @code{this-command} except when command
@c remapping occurs (@pxref{Remapping Commands}).  In that case,
@c @code{this-command} gives the command actually run (the result of
@c remapping), and @code{this-original-command} gives the command that
@c was specified to run but remapped into another command.
@end defvar

@defun this-command-keys
Функция возвращает строку или вектор содержащую последовательность клавиш
которые вызвали комманду, и любые предыдущие команды, которые
генерировали префикс аргумент для текущей команды. Любые события
считываемые командой с помощью @code{read-event} без задержки добавляются
в конец.

@c This function returns a string or vector containing the key sequence
@c that invoked the present command, plus any previous commands that
@c generated the prefix argument for this command.  Any events read by the
@c command using @code{read-event} without a timeout get tacked on to the end.

Но, если команда вызвала @code{read-key-sequence}, возвращается
последняя считанная последовательность. @xref{Key Sequence Input}.
Значение является строкой если все события в последовательности символы
которые помещаются в строку. @xref{Input Events}.

@c However, if the command has called @code{read-key-sequence}, it
@c returns the last read key sequence.  @xref{Key Sequence Input}.  The
@c value is a string if all events in the sequence were characters that
@c fit in a string.  @xref{Input Events}.

@example
@group
(this-command-keys)
;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}
     @result{} "^U^X^E"
@end group
@end example
@end defun

@defun this-command-keys-vector
@anchor{Definition of this-command-keys-vector}
Аналогично @code{this-command-keys}, но результат всегда возвращается
в виде вектора, что позволяет избегать сложностей связанных с
хранением в строку (@pxref{Strings of Events}).

@c Like @code{this-command-keys}, except that it always returns the events
@c in a vector, so you don't need to deal with the complexities of storing
@c input events in a string (@pxref{Strings of Events}).
@end defun

@defun clear-this-command-keys &optional keep-record
Функция очищает таблицу событий для @code{this-command-keys}.
Если только @var{keep-record} не-@code{nil}, так же очистятся
записи которые бы вернула функция @code{recent-keys} (@pxref{Recording Input}).
Функция полезна после чтения пароля, чтобы предотвратить
возможное отображение пароля в эхо области в последующих коммандах.

@c This function empties out the table of events for
@c @code{this-command-keys} to return.  Unless @var{keep-record} is
@c non-@code{nil}, it also empties the records that the function
@c @code{recent-keys} (@pxref{Recording Input}) will subsequently return.
@c This is useful after reading a password, to prevent the password from
@c echoing inadvertently as part of the next command in certain cases.
@end defun

@defvar last-nonmenu-event
Переменная хранит последне событие ввода считанное как часть
последовательности клавиш, исключя события от меню мыши.

@c This variable holds the last input event read as part of a key sequence,
@c not counting events resulting from mouse menus.

Одно из использований переменной указание для @code{x-popup-menu} места
где поднимать меню. Так же она используется в @code{y-or-n-p}
(@pxref{Yes-or-No Queries}).

@c One use of this variable is for telling @code{x-popup-menu} where to pop
@c up a menu.  It is also used internally by @code{y-or-n-p}
@c (@pxref{Yes-or-No Queries}).
@end defvar

@defvar last-command-event
Переменная хранит последнее событие ввода, которое было считано
командным циклом как часть команды. Основное использование
переменной в @code{self-insert-command}, используемой для
определения какие вставлять символы.

@c This variable is set to the last input event that was read by the
@c command loop as part of a command.  The principal use of this variable
@c is in @code{self-insert-command}, which uses it to decide which
@c character to insert.

@example
@group
last-command-event
;; @r{Now use @kbd{C-u C-x C-e} to evaluate that.}
     @result{} 5
@end group
@end example

@noindent
Значение 5, потому что это @acronym{ASCII} код @kbd{C-e}.
@c The value is 5 because that is the @acronym{ASCII} code for @kbd{C-e}.
@end defvar

@defvar last-event-frame
Переменная хранит фрейм к которому относится последнее событие ввода.
Как правило это фрейм, который был текущим в момент генерации события,
но если фрейм имел перенаправление ввода на другой фрейм, то значением
переменной будет фрейм на который было перенаправлено событие.
@xref{Input Focus}.

@c This variable records which frame the last input event was directed to.
@c Usually this is the frame that was selected when the event was
@c generated, but if that frame has redirected input focus to another
@c frame, the value is the frame to which the event was redirected.
@c @xref{Input Focus}.

Если последнее событие поступило от клавиатурного макроса, значеним
будет @code{macro}.

@c If the last event came from a keyboard macro, the value is @code{macro}.
@end defvar

@node Adjusting Point
@section Выравнивание Точки Курсора После Выполнения Команд
@c @section Adjusting Point After Commands
@cindex adjusting point
@cindex invisible/intangible text, and point
@cindex @code{display} property, and point display
@cindex @code{composition} property, and point display

  Не просто отобразить значение курсора в начале последовательности
текста, который имеет @code{display}, @code{composition} или не виден.
Поэтому, после завершения команды и возвращения в командный цикл,
если точка курсора находится внутри такой последовательности, командный
цикл перемещает точку курсора на границу такой последовательности.

@c   It is not easy to display a value of point in the middle of a
@c sequence of text that has the @code{display}, @code{composition} or
@c is invisible.  Therefore, after a command finishes and returns to the
@c command loop, if point is within such a sequence, the command loop
@c normally moves point to the edge of the sequence.

  Команда может заблокировать данную функцию путем установки
переменной @code{disable-point-adjustment}:
@c   A command can inhibit this feature by setting the variable
@c @code{disable-point-adjustment}:

@defvar disable-point-adjustment
Если значение переменной не-@code{nil}, после выполнения команды
не выполняется проверка того, в какой последовательности находится
курсор и не выполняется перемещение курсорса на границу последовательности.

@c If this variable is non-@code{nil} when a command returns to the
@c command loop, then the command loop does not check for those text
@c properties, and does not move point out of sequences that have them.

Команднывй цикл устанавливает значение перменной в @code{nil}, перед
выполнением каждой команды.

@c The command loop sets this variable to @code{nil} before each command,
@c so if a command sets it, the effect applies only to that command.
@end defvar

@defvar global-disable-point-adjustment
Если установить переменную в не-@code{nil}, перемещение курсора
на границу сложных для отображения последовательностей будет
отключено глобально.

@c If you set this variable to a non-@code{nil} value, the feature of
@c moving point out of these sequences is completely turned off.
@end defvar

@node Input Events
@section События Ввода
@c @section Input Events
@cindex events
@cindex input events

Командный цикл Emacs считывает последовательность @dfn{событий ввода}
(@dfn{input events}), которые представляют события от клавиатуры, мыши или
системные события посылаемые Emacs. События от клавиатуры представляются
в виде символом(знаков) или объектов символов, другие события всегда списки. Данный
раздел подробно описывает представление и смысл событий ввода.

@c The Emacs command loop reads a sequence of @dfn{input events} that
@c represent keyboard or mouse activity, or system events sent to Emacs.
@c The events for keyboard activity are characters or symbols; other
@c events are always lists.  This section describes the representation
@c and meaning of input events in detail.

@defun eventp object
Функция возвращает не-@code{nil} если @var{object} является событием ввода
или типом события.

@c This function returns non-@code{nil} if @var{object} is an input event
@c or event type.

Каждый символ может быть использован как событие или тип события.
@code{eventp} не может понять был ли символ предназначен для
использования в качестве события. Вместо этого, предикат отличает
был ли символ использован в событии, которое было считано как
ввод в текущей сессии Emacs. Если символ еще не был использован
в качестве события @code{eventp} вернет @code{nil}.

@c Note that any symbol might be used as an event or an event type.
@c @code{eventp} cannot distinguish whether a symbol is intended by Lisp
@c code to be used as an event.  Instead, it distinguishes whether the
@c symbol has actually been used in an event that has been read as input in
@c the current Emacs session.  If a symbol has not yet been so used,
@c @code{eventp} returns @code{nil}.
@end defun

@menu
* Keyboard Events::             Обычные символы(значе)---клавиши с символами на них.
* Function Keys::               Функциональные клавиши---клавиши с именами, не символами.
* Mouse Events::                Обзор событий мыши.
* Click Events::                Нажатие и отпускание кнопки мыши.
* Drag Events::                 Движение мыже перед с зажатой кнопкой.
* Button-Down Events::          События нажатия кнопки мыши, до ее отпускаия.
* Repeat Events::               Двойное и тройное нажатие.
* Motion Events::               Простое движение мыши, без нажатой кнопки.
* Focus Events::                Движение мыши между фреймами.
* Misc Events::                 Другие события, которые может генерировать система.
* Event Examples::              Примеры списков для событий мыши.
* Classifying Events::          Определение наличия модификаторов в символе события.
                                Типы события.
* Accessing Mouse::             Функция доступа к данным события мыши.
* Accessing Scroll::            Функция доступа для событий полосы прокрутки.
* Strings of Events::           Соображения по поводу помещения событий клавиатуры
                                  в строку.
@end menu

@c @menu
@c * Keyboard Events::             Ordinary characters -- keys with symbols on them.
@c * Function Keys::               Function keys -- keys with names, not symbols.
@c * Mouse Events::                Overview of mouse events.
@c * Click Events::                Pushing and releasing a mouse button.
@c * Drag Events::                 Moving the mouse before releasing the button.
@c * Button-Down Events::          A button was pushed and not yet released.
@c * Repeat Events::               Double and triple click (or drag, or down).
@c * Motion Events::               Just moving the mouse, not pushing a button.
@c * Focus Events::                Moving the mouse between frames.
@c * Misc Events::                 Other events the system can generate.
@c * Event Examples::              Examples of the lists for mouse events.
@c * Classifying Events::          Finding the modifier keys in an event symbol.
@c                                 Event types.
@c * Accessing Mouse::             Functions to extract info from mouse events.
@c * Accessing Scroll::            Functions to get info from scroll bar events.
@c * Strings of Events::           Special considerations for putting
@c                                   keyboard character events in a string.
@c @end menu

@node Keyboard Events
@subsection События Клавиатуры
@cindex keyboard events

Есть два вида ввода который можно получить от клавиатуры: обычные
клавиши или функциональные клавиши. Обычные клавишу сответствуют символам(знакам);
события которые ими генерируются в Lisp представляются в виде символов(знаков).
Тип события символа есть сам этот символ(знак) (представляется как число);
@ref{Classifying Events}.

@c There are two kinds of input you can get from the keyboard: ordinary
@c keys, and function keys.  Ordinary keys correspond to characters; the
@c events they generate are represented in Lisp as characters.  The event
@c type of a character event is the character itself (an integer); see
@c @ref{Classifying Events}.

@cindex modifier bits (of input character)
@cindex basic code (of input character)
Символьные события состоят из @dfn{базовых кодов} (@dfn{basic code})
значения которых находятся между 0 и 524287, плюс любые из или
все из @dfn{битов модификации} (@dfn{modifier bits}):

@c An input character event consists of a @dfn{basic code} between 0 and
@c 524287, plus any or all of these @dfn{modifier bits}:

@table @asis
@item meta
@c The
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
бит означает, что символ(знак) введен
введен при удержании meta(мета, как правило нажать-отпустить Esc или зажатая Alt) клавиши.
@c bit in the character code indicates a character
@c typed with the meta key held down.

@item control
@c The
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
бит указывает, что
символ рассматривается как не-@acronym{ASCII} control символ.
@c bit in the character code indicates a non-@acronym{ASCII}
@c control character.

@sc{ascii} control символы, такие как @kbd{C-a} имеют имеют свои
базовые кода, поэтому Emacs не требуются специальные биты для
их распознавания. Например 1 код для @kbd{C-a}.

@c @sc{ascii} control characters such as @kbd{C-a} have special basic
@c codes of their own, so Emacs needs no special bit to indicate them.
@c Thus, the code for @kbd{C-a} is just 1.

Но если ввести control комбинацию которая не в @acronym{ASCII}, такую
как @kbd{%} при зажатой клавише control, код символ будет
вычисляться как числовое значение для @kbd{%} плюс
@c But if you type a control combination not in @acronym{ASCII}, such as
@c @kbd{%} with the control key, the numeric value you get is the code
@c for @kbd{%} plus
@tex
@math{2^{26}}
@end tex
@ifnottex
2**26
@end ifnottex
(предполагая, что терминал поддерживает не-@acronym{ASCII}
control символы).
@c (assuming the terminal supports non-@acronym{ASCII}
@c control characters).

@item shift
@c The
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит в коде символа указывает, что @acronym{ASCII} control
символ введен с зажатой shift клавишей.

@c bit in the character code indicates an @acronym{ASCII} control
@c character typed with the shift key held down.

Для букв, базовые коды c shift будут укзывать на символ в верхнем регистре,
а для цифр и пунктуации, shift клавиша будет приводить к выбору
полностью другого базаового кода. Чтобы оставаться внутри
пространства @acronym{ASCII} символов, когда это возможно, Emacs
старается избегать использования
@c For letters, the basic code itself indicates upper versus lower case;
@c for digits and punctuation, the shift key selects an entirely different
@c character with a different basic code.  In order to keep within the
@c @acronym{ASCII} character set whenever possible, Emacs avoids using the
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бита для таких символов.
@c bit for those characters.

Но, @acronym{ASCII} не предоставляет способа отличить @kbd{C-A} от
@kbd{C-a}, поэтому Emacs использует
@c However, @acronym{ASCII} provides no way to distinguish @kbd{C-A} from
@c @kbd{C-a}, so Emacs uses the
@tex
@math{2^{25}}
@end tex
@ifnottex
2**25
@end ifnottex
бит в @kbd{C-A} и не использует
в @kbd{C-a}

@c bit in @kbd{C-A} and not in
@c @kbd{C-a}.

@item hyper
@c The
@tex
@math{2^{24}}
@end tex
@ifnottex
2**24
@end ifnottex
бит в символе указывает на символ введенный
с зажатой клавишей hyper.
@c bit in the character code indicates a character
@c typed with the hyper key held down.

@item super
@c The
@tex
@math{2^{23}}
@end tex
@ifnottex
2**23
@end ifnottex
бит в символе указывает, что символ введен
с зажатой клавишей super.

@c bit in the character code indicates a character
@c typed with the super key held down.

@item alt
@c The
@tex
@math{2^{22}}
@end tex
@ifnottex
2**22
@end ifnottex
бит в коде символа указывает, что символ введен с зажатой
клавишей alt. (На большинстве клавиатур символв помеченный как @key{Alt}
обрабатывается как meta символ, не как alt.)

@c bit in the character code indicates a character typed with the alt key
@c held down.  (The key labeled @key{Alt} on most keyboards is actually
@c treated as the meta key, not this.)
@end table

  Лучше всего избегать упоминания специальных битов в своих программах.
Тест на биты модификации, использует функцию @code{event-modifiers}
(@pxref{Classifying Events}). При создании привязок для клавиш,
можно использовать синтаксис чтения для символов с битами
модификации (@samp{\C-}, @samp{\M-}, и так далее). Для создания
привязок с помощью @code{define-key}, можно использовать списки,
такие как @code{(control hyper ?x)} для задания символов (@pxref{Changing
Key Bindings}). Функция @code{event-convert-list} преобразует такой
список в тип события (@pxref{Classifying Events}).

@c   It is best to avoid mentioning specific bit numbers in your program.
@c To test the modifier bits of a character, use the function
@c @code{event-modifiers} (@pxref{Classifying Events}).  When making key
@c bindings, you can use the read syntax for characters with modifier bits
@c (@samp{\C-}, @samp{\M-}, and so on).  For making key bindings with
@c @code{define-key}, you can use lists such as @code{(control hyper ?x)} to
@c specify the characters (@pxref{Changing Key Bindings}).  The function
@c @code{event-convert-list} converts such a list into an event type
@c (@pxref{Classifying Events}).

@node Function Keys
@subsection Функциональные Клавиши
@c @subsection Function Keys

@cindex function keys
Большинство клавиатур имеют @dfn{функциональные клавиши} (@dfn{function keys})---
клавиши, которые имеют или символы не являющиеся символами(знаками).
Функциональные клавиши в Emacs Lisp представлены как символы, имя символа,
является меткой для функциональной клавиши с этой же меткой. Имя символа
при этом записывается в нижнем регистре. Например, нажатие клавиши @key{F1}
генерирует событие ввода представленное символом @code{f1}.

@c Most keyboards also have @dfn{function keys}---keys that have names or
@c symbols that are not characters.  Function keys are represented in
@c Emacs Lisp as symbols; the symbol's name is the function key's label,
@c in lower case.  For example, pressing a key labeled @key{F1} generates
@c an input event represented by the symbol @code{f1}.

Типом события от функциональной клавиши является сам символ события.
@xref{Classifying Events}.

@c The event type of a function key event is the event symbol itself.
@c @xref{Classifying Events}.

Ниже приводится несколько особых случаев именования символов
для функциональных клавиш:
@c Here are a few special cases in the symbol-naming convention for
@c function keys:

@table @asis
@item @code{backspace}, @code{tab}, @code{newline}, @code{return}, @code{delete}
Данные клавиши соответствуют общим управляющим  симвлам(знакам) @acronym{ASCII}
для которых на большинстве клавиатур есть кнопки.

@c These keys correspond to common @acronym{ASCII} control characters that have
@c special keys on most keyboards.

В @acronym{ASCII}, @kbd{C-i} и @kbd{TAB} представляют собой один и тот
же символ. Если терминал может может их отличасть, Emacs передает
это различе представляя первое как число 9, а @kbd{TAB} как
символ @code{tab}.

@c In @acronym{ASCII}, @kbd{C-i} and @key{TAB} are the same character.  If the
@c terminal can distinguish between them, Emacs conveys the distinction to
@c Lisp programs by representing the former as the integer 9, and the
@c latter as the symbol @code{tab}.

В большинстве случаев, различать их бесполезно. И нормальной является
ситуация, когда в @code{local-function-key-map} (@pxref{Translation Keymaps})
@code{tab} отображается в 9. Таким образом, привязка для символа с кодом 9
(@kbd{C-i}) так же применяется для @code{tab}. Аналогично для других
символов в этой группе. Функция @code{read-char} аналогично преобразует
такие события в символы.

@c Most of the time, it's not useful to distinguish the two.  So normally
@c @code{local-function-key-map} (@pxref{Translation Keymaps}) is set up
@c to map @code{tab} into 9.  Thus, a key binding for character code 9
@c (the character @kbd{C-i}) also applies to @code{tab}.  Likewise for
@c the other symbols in this group.  The function @code{read-char}
@c likewise converts these events into characters.

В @acronym{ASCII}, @key{BS} соответствует @kbd{C-h}. Но @code{backspace}
преобразуется в символс кодом 127 (@key{DEL}), а не в @kbd{BS} с кодом 8.
Так предпочитает болшинство пользователей.

@c In @acronym{ASCII}, @key{BS} is really @kbd{C-h}.  But @code{backspace}
@c converts into the character code 127 (@key{DEL}), not into code 8
@c (@key{BS}).  This is what most users prefer.

@item @code{left}, @code{up}, @code{right}, @code{down}
Стрелки курсора
@c Cursor arrow keys
@item @code{kp-add}, @code{kp-decimal}, @code{kp-divide}, @dots{}
Клавиши на цифровом блоке (в правой части на обычных клавиатурах).
@c Keypad keys (to the right of the regular keyboard).
@item @code{kp-0}, @code{kp-1}, @dots{}
Клавиши цифр на цифровом блоке.
@c Keypad keys with digits.
@item @code{kp-f1}, @code{kp-f2}, @code{kp-f3}, @code{kp-f4}
PF клавиши цифрового блока (?).
@c Keypad PF keys.
@item @code{kp-home}, @code{kp-left}, @code{kp-up}, @code{kp-right}, @code{kp-down}
Стрелочки на цифровом блоке. Emacs обычно преобразует их в
соответствующие клавиши не цифрового блока @code{home}, @code{left}, @dots{}

@c Keypad arrow keys.  Emacs normally translates these into the
@c corresponding non-keypad keys @code{home}, @code{left}, @dots{}
@item @code{kp-prior}, @code{kp-next}, @code{kp-end}, @code{kp-begin}, @code{kp-insert}, @code{kp-delete}
Дополнительные дубликаты клавиш цифрового блока находящиееся в других
местах. Emacs как правило преобразует их в клавиши не цифрового
блока с аналогичным названием.

@c Additional keypad duplicates of keys ordinarily found elsewhere.  Emacs
@c normally translates these into the like-named non-keypad keys.
@end table

Можно использовать клавиши модификаторы @key{ALT}, @key{CTRL},
@key{META}, @key{SHIFT}, и @key{SUPER} вместе с фукнциональными клавишами.
Такие клавши будут представляться с дополнительным символом префиксом:

@c You can use the modifier keys @key{ALT}, @key{CTRL}, @key{HYPER},
@c @key{META}, @key{SHIFT}, and @key{SUPER} with function keys.  The way to
@c represent them is with prefixes in the symbol name:

@table @samp
@item A-
Для alt модификатора.
@c The alt modifier.
@item C-
Для control модификатора.
@c The control modifier.
@item H-
Для hyper модификатора.
@c The hyper modifier.
@item M-
Для meta модификатора.
@c The meta modifier.
@item S-
Для shift модификатора.
@c The shift modifier.
@item s-
Для super модификатора.
@c The super modifier.
@end table

Таким образом символ для @key{F3} при зажатой @key{META} будет
представляться @code{M-f3}. При использовании более одного
модификатора рекомедуется записывать их в алфавитном порядке, но
при этом когда запись используется как аргумент в функциях
задания привязок порядок модификаторов не имеет значения.

@c Thus, the symbol for the key @key{F3} with @key{META} held down is
@c @code{M-f3}.  When you use more than one prefix, we recommend you
@c write them in alphabetical order; but the order does not matter in
@c arguments to the key-binding lookup and modification functions.

@node Mouse Events
@subsection События Мыши
@c @subsection Mouse Events

Emacs поддерживает четыре вида событий мыши: щелчок (нажать и отпустить),
перетаскивание(движение с нажатием), нажатие кнопки, движение (без нажатия).
Все события мыши представляются списками. @sc{car} списка представляет
тип события, что укзывает на то какая клавиша была нажата и какие
кнопки модификаторы при этом использовались.  Тип события может
различать двойной и тройной клик (@pxref{Repeat Events}). Остальные
элементы списка предоставляют позицию и время.

@c Emacs supports four kinds of mouse events: click events, drag events,
@c button-down events, and motion events.  All mouse events are represented
@c as lists.  The @sc{car} of the list is the event type; this says which
@c mouse button was involved, and which modifier keys were used with it.
@c The event type can also distinguish double or triple button presses
@c (@pxref{Repeat Events}).  The rest of the list elements give position
@c and time information.

Для поиска команд значение имеет только тип события: два события одного
типа обязательно вызывают одну и ту же команду. Команда может получить
доступ к полной информации о событии испльзуя кодовый символ @samp{e}
в спецификации @code{interactive} @xref{Interactive Codes}.

@c For key lookup, only the event type matters: two events of the same type
@c necessarily run the same command.  The command can access the full
@c values of these events using the @samp{e} interactive code.
@c @xref{Interactive Codes}.

Ключевая последовательность, которая начинается с события мыши считывается
используя раскладку буфера в окне которого нахдоилась мыш, а не текущего
буфера. Это не означает, что щелчок в окне выделяет это окно или
буфер.

@c A key sequence that starts with a mouse event is read using the keymaps
@c of the buffer in the window that the mouse was in, not the current
@c buffer.  This does not imply that clicking in a window selects that
@c window or its buffer---that is entirely under the control of the command
@c binding of the key sequence.

@node Click Events
@subsection События Щелчки
@c @subsection Click Events
@cindex click event
@cindex mouse click event

Когда пользователь нажимает и отпускает кнопку мыши находясь на
одном месте, генерируется событие @dfn{щелчок} (@dfn{click}).
Все события щелчки имеют одинаковый формат:

@c When the user presses a mouse button and releases it at the same
@c location, that generates a @dfn{click} event.  All mouse click event
@c share the same format:

@example
(@var{event-type} @var{position} @var{click-count})
@end example

@table @asis
@item @var{event-type}
Символ который указывает, какая кнопка была нажата. Может быть одним
из символов @code{mouse-1}, @code{mouse-2}, @dots{}, кнопки
нумеруются слева-направо.

@c This is a symbol that indicates which mouse button was used.  It is
@c one of the symbols @code{mouse-1}, @code{mouse-2}, @dots{}, where the
@c buttons are numbered left to right.

Можно использовать префиксы @samp{A-}, @samp{C-}, @samp{H-}, @samp{M-},
@samp{S-} и @samp{s-} для модификаторов alt, control, hyper, meta, shift
и super, если щелчок выполняется при зажатых функциональных клавишах.

@c You can also use prefixes @samp{A-}, @samp{C-}, @samp{H-}, @samp{M-},
@c @samp{S-} and @samp{s-} for modifiers alt, control, hyper, meta, shift
@c and super, just as you would with function keys.

Символ выполняет функцию типа события. Привязки клавиш поисываются
этими типами, то есть привязка для @code{mouse-1}, будет работать
для всех событий для которых @var{event-type} @code{mouse-1}.

@c This symbol also serves as the event type of the event.  Key bindings
@c describe events by their types; thus, if there is a key binding for
@c @code{mouse-1}, that binding would apply to all events whose
@c @var{event-type} is @code{mouse-1}.

@item @var{position}
@cindex mouse position list
@dfn{список позиций мыши} (@dfn{mouse position list}) указыват на место
где был произведен щелчок, ниже будут подробности.

@c This is a @dfn{mouse position list} specifying where the mouse click
@c occurred; see below for details.

@item @var{click-count}
Количество быстрых повторных нажатий одной и той же кнопки на
данный момент. @xref{Repeat Events}.

@c This is the number of rapid repeated presses so far of the same mouse
@c button.  @xref{Repeat Events}.
@end table

  Для получения данных о положении мыши из
@var{position} слота списка данных события, как праило используются
функции описанные в @ref{Accessing Mouse}. Конкретный формат зависит
от того, где был сделан щелчок. Для щелчков в текстовой области,
строке режима, строке заголовка или области краев или оступов, список
позиций мыши будет иметь форму

@c   To access the contents of a mouse position list in the
@c @var{position} slot of a click event, you should typically use the
@c functions documented in @ref{Accessing Mouse}.  The explicit format of
@c the list depends on where the click occurred.  For clicks in the text
@c area, mode line, header line, or in the fringe or marginal areas, the
@c mouse position list has the form

@example
(@var{window} @var{pos-or-area} (@var{x} . @var{y}) @var{timestamp}
 @var{object} @var{text-pos} (@var{col} . @var{row})
 @var{image} (@var{dx} . @var{dy}) (@var{width} . @var{height}))
@end example

@noindent
Элементы списка имеют следующие значения:
@c The meanings of these list elements are as follows:

@table @asis
@item @var{window}
Окно в которым был сделан щелчок.
@c The window in which the click occurred.

@item @var{pos-or-area}
Позиция в буфере символа на котором был щелчок в текстовой области;
или если щелчок был вне текстовой области область окна. Может
быть одним из символов @code{mode-line}, @code{header-line}, @code{vertical-line},
@code{left-margin}, @code{right-margin}, @code{lift-frienge}, или
@code{right-fringe}.

@c The buffer position of the character clicked on in the text area; or,
@c if the click was outside the text area, the window area where it
@c occurred.  It is one of the symbols @code{mode-line},
@c @code{header-line}, @code{vertical-line}, @code{left-margin},
@c @code{right-margin}, @code{left-fringe}, or @code{right-fringe}.

Если Emacs регистрирует для события мнимые клавиши префикса, тогда
@var{pos-or-area} является списком с одним с из перечисленных выше
символов. @xref{Key Sequence Input}.

@c In one special case, @var{pos-or-area} is a list containing a symbol
@c (one of the symbols listed above) instead of just the symbol.  This
@c happens after the imaginary prefix keys for the event are registered
@c by Emacs.  @xref{Key Sequence Input}.

@item @var{x}, @var{y}
Координаты пикселя щелчка. Для области текста начало коородинат
находится в верхнему левому углу текстовой области
и соответствует координате @code{(0 . 0)}. @xref{Window Sizes}.
Для щелчков на строке режима и строке заголовка началом координат является
верхний левый угол окна. Для краев(fringes) и оступов(margins)
и верхних границ, @var{x} не имеет смысла. Для краев(fringes)
и отступов(margins), @var{y} считается относительно нижней
границы строки заголовка. Во всех случаях, @var{x} и @var{y}
увеличиываются вправо и вниз относительно начала координат.

@c The relative pixel coordinates of the click.  For clicks in the text
@c area of a window, the coordinate origin @code{(0 . 0)} is taken to be
@c the top left corner of the text area.  @xref{Window Sizes}.  For
@c clicks in a mode line or header line, the coordinate origin is the top
@c left corner of the window itself.  For fringes, margins, and the
@c vertical border, @var{x} does not have meaningful data.  For fringes
@c and margins, @var{y} is relative to the bottom edge of the header
@c line.  In all cases, the @var{x} and @var{y} coordinates increase
@c rightward and downward respectively.

@item @var{timestamp}
Время наступления события, в виде числа соответствующего
количеству милисекунд с некоторого зависящего от
системы начального времени.

@c The time at which the event occurred, as an integer number of
@c milliseconds since a system-dependent initial time.

@item @var{object}
@code{nil} если в позиции щелчка нет текстового свойства строкового-свойства,
иначе cons ячейка в форме (@var{string} . @var{string-pos})
где

@c Either @code{nil} if there is no string-type text property at the
@c click position, or a cons cell of the form (@var{string}
@c . @var{string-pos}) if there is one:

@table @asis
@item @var{string}
Строка на которой был щелчок, включая любые свойства.
@c The string which was clicked on, including any properties.

@item @var{string-pos}
Позиция в строке где был щелчок.
@c The position in the string where the click occurred.
@end table

@item @var{text-pos}
Для щелчков  области оступов или краев, позиция первого видимого символа(знака)
в соответствующей строке окна. Для щелчков на строке режима или строке
заголовка, @code{nil}. Для других событий, ближайшая к щелчку позиция
в буфере.

@c For clicks on a marginal area or on a fringe, this is the buffer
@c position of the first visible character in the corresponding line in
@c the window.  For clicks on the mode line or the header line, this is
@c @code{nil}.  For other events, it is the buffer position closest to
@c the click.

@item @var{col}, @var{row}
Номер колонки и строки глифа под @var{x}, @var{y} позицией. Если
@var{x} находится за последнией колонкой текста, @var{col} значение
@var{col} будет вычислено, используя ширину символа по умолчанию, для
расширения количества колонок до @var{x}. Строка 0, соовтетствует
строке заголовка если она есть, иначе верхняя колонка текстовой области.
Колонка 0 соответствует самой левой колонке области текста. Или
крайняя левая строка режимов или заголовка, для щелчков на них.
Для щелчков на краях(fringes) или вертикальных границах, в данных
свойствах нет смысла. Для щелчков на отступах(margins), @var{col}
считается от левого угла области отступа, и @var{row} отсчитывается
от верха области отступа.


@c These are the actual column and row coordinate numbers of the glyph
@c under the @var{x}, @var{y} position.  If @var{x} lies beyond the last
@c column of actual text on its line, @var{col} is reported by adding
@c fictional extra columns that have the default character width.  Row 0
@c is taken to be the header line if the window has one, or the topmost
@c row of the text area otherwise.  Column 0 is taken to be the leftmost
@c column of the text area for clicks on a window text area, or the
@c leftmost mode line or header line column for clicks there.  For clicks
@c on fringes or vertical borders, these have no meaningful data.  For
@c clicks on margins, @var{col} is measured from the left edge of the
@c margin area and @var{row} is measured from the top of the margin area.

@item @var{image}
Объект изображения на котором был выполнен щелчок. Если щелчок
был на изображении, то объект определяется функцией @code{find-image},
инчае значение @code{nil}.

@c This is the image object on which the click occurred.  It is either
@c @code{nil} if there is no image at the position clicked on, or it is
@c an image object as returned by @code{find-image} if click was in an image.

@item @var{dx}, @var{dy}
Координаты в пикселях относительно левого верхнего @code{(0. 0)}
угла объекта @var{object}. Если @var{object} @code{nil}, координаты относительно
левого верхнего угла глифа символа на котором выполнен щелчок.
 
@c These are the pixel coordinates of the click, relative to
@c the top left corner of @var{object}, which is @code{(0 . 0)}.  If
@c @var{object} is @code{nil}, the coordinates are relative to the top
@c left corner of the character glyph clicked on.

@item @var{width}, @var{height}
Ширина и высота в пикселях объекта @var{object}, или если
он @code{nil}, глифа символа на котором щелкнули.

@c These are the pixel width and height of @var{object} or, if this is
@c @code{nil}, those of the character glyph clicked on.
@end table

Для щелчков на полосе прокрутки, @var{position} имеет форму:
@c For clicks on a scroll bar, @var{position} has this form:

@example
(@var{window} @var{area} (@var{portion} . @var{whole}) @var{timestamp} @var{part})
@end example

@table @asis
@item @var{window}
Окно к которому относится полоса прокрутки.
@c The window whose scroll bar was clicked on.

@item @var{area}
Символ @code{vertical-scroll-bar}.
@c This is the symbol @code{vertical-scroll-bar}.

@item @var{portion}
Количество пикселей от верха полосы прокрутки до позиции щелчка.
В некоторых фреймворках(toolkits), в том числе GTK+, Emacs не может
получить эти данные и значение всегда @code{0}.

@c The number of pixels from the top of the scroll bar to the click
@c position.  On some toolkits, including GTK+, Emacs cannot extract this
@c data, so the value is always @code{0}.

@item @var{whole}
Длина в пикселях полосы прокрутки. В некоторых фреймворках, включая
GTK+, Emacs не может получить эти данные, и значение всегда @code{0}.

@c The total length, in pixels, of the scroll bar.  On some toolkits,
@c including GTK+, Emacs cannot extract this data, so the value is always
@c @code{0}.

@item @var{timestamp}
Время щелчка в милисекундах. В некоторых фреймворках, включая
GTK+, Emacs не может получить это значение и значение всегда
@code{0}.

@c The time at which the event occurred, in milliseconds.  On some
@c toolkits, including GTK+, Emacs cannot extract this data, so the value
@c is always @code{0}.

@item @var{part}
Часть полосы прокрутки на которой выполнен щелчок. Один из символов
@code{handle} (ползуно полосы прокрутки), @code{above-handle} (область
над ползунком), @code{below-handle} (область ниже ползунка), @code{up}
(стрелка вверх на одном конце полосы прокрутки), или @code{down} (стрелка
вниз на конце полосы прокрутки).

@c The part of the scroll bar on which the click occurred.  It is one of
@c the symbols @code{handle} (the scroll bar handle), @code{above-handle}
@c (the area above the handle), @code{below-handle} (the area below the
@c handle), @code{up} (the up arrow at one end of the scroll bar), or
@c @code{down} (the down arrow at one end of the scroll bar).
@c The 'top', 'bottom', and 'end-scroll' codes don't seem to be used.
@end table


@node Drag Events
@subsection События Перетаскивания
@c @subsection Drag Events
@cindex drag event
@cindex mouse drag event

@dfn{Событие перетаскивания}(@dfn{drag event}) происходит, когда пользователь нажимает
кнопку мыши, передвигает ее не отпуская кнопки и потом отпускает.
Как другие события мыши перетаскивание представляется списком.
Список хранит начальную и конечную позиции:

@c With Emacs, you can have a drag event without even changing your
@c clothes.  A @dfn{drag event} happens every time the user presses a mouse
@c button and then moves the mouse to a different character position before
@c releasing the button.  Like all mouse events, drag events are
@c represented in Lisp as lists.  The lists record both the starting mouse
@c position and the final position, like this:

@example
(@var{event-type}
 (@var{window1} START-POSITION)
 (@var{window2} END-POSITION))
@end example

Для события перетаскивания имя символа @var{event-type} содержит
префикс @samp{drag-}. Например, перетаскивание с зажатой кнопкой 2
сгенерирует событие @code{drag-mouse-2}. Второой и третий элементы
события содержат начальную и конечную позиции перетаскивания, как
списки указывающие на позицию мыши (@pxref{Click Events}). Но,
перетаскивание может завершится вне границ фрейма в котором оно
началось. В этом случае, список с описанием позции третьего элемента
списка события содержит фрейм в позиции окна (прим. или сам фрейм ?).

@c For a drag event, the name of the symbol @var{event-type} contains the
@c prefix @samp{drag-}.  For example, dragging the mouse with button 2
@c held down generates a @code{drag-mouse-2} event.  The second and third
@c elements of the event give the starting and ending position of the
@c drag, as mouse position lists (@pxref{Click Events}).  You can access
@c the second element of any mouse event in the same way.  However, the
@c drag event may end outside the boundaries of the frame that was
@c initially selected.  In that case, the third element's position list
@c contains that frame in place of a window.

Префикс @samp{drag-} следуюет за прфиксами модификаторов,
такими как @samp{C-} и @samp{M-}.

@c The @samp{drag-} prefix follows the modifier key prefixes such as
@c @samp{C-} and @samp{M-}.

Если @code{read-key-sequence} получит событие перетаскивания, для
которого нет связывания и есть соответствующее привязка для
щелчка, перетаскивание заменяется на щелчок в начальной позиции.
То есть не нужно различать щелчок и перетаскивание, если это
явно не нужно.

@c If @code{read-key-sequence} receives a drag event that has no key
@c binding, and the corresponding click event does have a binding, it
@c changes the drag event into a click event at the drag's starting
@c position.  This means that you don't have to distinguish between click
@c and drag events unless you want to.

@node Button-Down Events
@subsection События Нажатия Кнопки
@c @subsection Button-Down Events
@cindex button-down event
События щелчок и перетаскивание происходят когда пользователь
отпускает кнопку. Они не могут случиться раньше, потому что
не способа их различить, до того как кнопка будет отпущена.

@c Click and drag events happen when the user releases a mouse button.
@c They cannot happen earlier, because there is no way to distinguish a
@c click from a drag until the button is released.

Если нужно сделать действие, как только кнопка будет нажата,
нужно обрабатывать @dfn{событие нажания} (@dfn{button-down}).
Событие происходит сразу, как только кнопка нажимается. Событие
представляется списком, таким же как для события щелчка
(@pxref{Click Events}), за исключением того, что символ
@var{event-type} содержит префикс @samp{down-}. Префикс @samp{down-}
следуюет за префиксами модификаторами, такими как @samp{C-} или @samp{M-}.

@c If you want to take action as soon as a button is pressed, you need to
@c handle @dfn{button-down} events.@footnote{Button-down is the
@c conservative antithesis of drag.}  These occur as soon as a button is
@c pressed.  They are represented by lists that look exactly like click
@c events (@pxref{Click Events}), except that the @var{event-type} symbol
@c name contains the prefix @samp{down-}.  The @samp{down-} prefix follows
@c modifier key prefixes such as @samp{C-} and @samp{M-}.

Функция @code{read-key-sequence} игнорирует события нажатия кнопок, если
они не имеют привязок, и поэтому командный цикл Emacs их тоже игнорирует.
Обычный причина использовать события нажатия, заключается в отслеживании
движения мыши (путем считывания событий движения), до того как
кнопка будет отпущена.

@c The function @code{read-key-sequence} ignores any button-down events
@c that don't have command bindings; therefore, the Emacs command loop
@c ignores them too.  This means that you need not worry about defining
@c button-down events unless you want them to do something.  The usual
@c reason to define a button-down event is so that you can track mouse
@c motion (by reading motion events) until the button is released.
@c @xref{Motion Events}.

@node Repeat Events
@subsection Повторяющиеся События
@c @subsection Repeat Events
@cindex repeat events
@cindex double-click events
@cindex triple-click events
@cindex mouse events, repeated

Если быстро нажать какую-то кнопку мыши больше чем один раз без
перемещения мыши, Emacs сгенерирует @dfn{повтояющееся} (@dfn{repeat})
событие для второго и последующих нажатий.

@c If you press the same mouse button more than once in quick succession
@c without moving the mouse, Emacs generates special @dfn{repeat} mouse
@c events for the second and subsequent presses.

Самое распространенное повторяющееся события @dfn{double-click} (@dfn{двойной
щелчок}). Emacs генерирует двойной щелчок,  когда щелчок выполняется дважды;
событие возникает при отпускании кнопки (как для всех события щелчков).

@c The most common repeat events are @dfn{double-click} events.  Emacs
@c generates a double-click event when you click a button twice; the event
@c happens when you release the button (as is normal for all click
@c events).

Тип события двойного щелчка содержит префикс @samp{double-}. Т.е. событием двойного
щелчка второй кнопкой мыши, с зажатой клавишей @key{meta} будет:
@code{M-double-mouse-2}.
Если двойной щелчок не имеет связываний, используются связывания
событий обычного щелчка. Таким образом, если обработка двойного щелкка
не нужна, можно не обращать внимания на это событие.

@c The event type of a double-click event contains the prefix
@c @samp{double-}.  Thus, a double click on the second mouse button with
@c @key{meta} held down comes to the Lisp program as
@c @code{M-double-mouse-2}.  If a double-click event has no binding, the
@c binding of the corresponding ordinary click event is used to execute
@c it.  Thus, you need not pay attention to the double click feature
@c unless you really want to.

Когда пользователь деляет двойной щелчок, Emacs сначал генерирует
событие обычного щелчка, а потом двойного щелчка(double-click). Поэтому
обработчик для двойного щелчка, должен учитывать, что обработчик для
обычного щелчлка уже выполнился, к моменту запуска. То есть результат
двойного щелчка, должен основываться на результате одинарного.

@c When the user performs a double click, Emacs generates first an ordinary
@c click event, and then a double-click event.  Therefore, you must design
@c the command binding of the double click event to assume that the
@c single-click command has already run.  It must produce the desired
@c results of a double click, starting from the results of a single click.

Удобно когда смысл двойного щелчка, как-то базируется на одинарном---
что является рекомендованной практикой в построении пользовательских
интерфейсов.

@c This is convenient, if the meaning of a double click somehow builds
@c on the meaning of a single click---which is recommended user interface
@c design practice for double clicks.

Если сделать щелчок, затем нажать кнопку и начать движение мыши,
будет сгенерировано @dfn{dboule-drag} (@dfn{двойное перемещение}) событие
когда кнопка будет отпущена. Это событие содержит тип @samp{double-grag},
вместо @samp{drag}. Если double-drag не имеет привязок(обработчиков),
Emacs ищет связывания для обычного перемещения.

@c If you click a button, then press it down again and start moving the
@c mouse with the button held down, then you get a @dfn{double-drag} event
@c when you ultimately release the button.  Its event type contains
@c @samp{double-drag} instead of just @samp{drag}.  If a double-drag event
@c has no binding, Emacs looks for an alternate binding as if the event
@c were an ordinary drag.

Перед двойным щелчком(double-click) или двойным перемещением(double-drag),
Emacs генерирует событие @dfn{double-down} (@dfn{двойное нажатие}), при
втором нажатии пользователем на кнопку. Тип события содержит
@samp{double-down}, вместо @samp{down}. Если double-down не имеет
привязок, берутся связывания для обычного нажатия. Если связываний(обработчиков)
нет, событие игнорируется.

@c Before the double-click or double-drag event, Emacs generates a
@c @dfn{double-down} event when the user presses the button down for the
@c second time.  Its event type contains @samp{double-down} instead of just
@c @samp{down}.  If a double-down event has no binding, Emacs looks for an
@c alternate binding as if the event were an ordinary button-down event.
@c If it finds no binding that way either, the double-down event is
@c ignored.

В итоге, когда выполняется два щелчка на кнопку, сначала генерируются
событие нажатие(down), потом щелчок(click), потом двойное нажатие(double-down),
и при отпускании двойной щелчок(double-click) или двойное перемещение(double-drag).

@c To summarize, when you click a button and then press it again right
@c away, Emacs generates a down event and a click event for the first
@c click, a double-down event when you press the button again, and finally
@c either a double-click or a double-drag event.

В случае если нажать третий раз будут @dfn{тройное нажатие}
(@dfn{triple-down}), @dfn{тройной щелчок}(@dfn{triple-click}) или
@dfn{тройное перемещение}(@dfn{triple-drag}). Данные события
имеют префикс @dfn{triple} вместо @samp{double}. Если для
тройного события нет обработчиков, используются обработчики
двойного и потом одинарного или никакие.

@c If you click a button twice and then press it again, all in quick
@c succession, Emacs generates a @dfn{triple-down} event, followed by
@c either a @dfn{triple-click} or a @dfn{triple-drag}.  The event types of
@c these events contain @samp{triple} instead of @samp{double}.  If any
@c triple event has no binding, Emacs uses the binding that it would use
@c for the corresponding double event.

Если продолжать на кнопку, события после третьего будут генерировать
тройные события. Emacs не имеет отдельного типа события для четверных,
пятерных и т.д. событий. Но можно посмотреть список событий и найти
сколько раз кнопка была нажата.

@c If you click a button three or more times and then press it again, the
@c events for the presses beyond the third are all triple events.  Emacs
@c does not have separate event types for quadruple, quintuple, etc.@:
@c events.  However, you can look at the event list to find out precisely
@c how many times the button was pressed.

@defun event-click-count event
Функция возвращает количество последовательных нажатий кнопки, что
привело к возникновению события @var{event}. Если @var{event} двойное-нажатие(double-down),
двойной щелчок(double-click) или двойное перемещение(double-drag) значение 2,
для тройных событий 3, для одинарных 1.

@c This function returns the number of consecutive button presses that led
@c up to @var{event}.  If @var{event} is a double-down, double-click or
@c double-drag event, the value is 2.  If @var{event} is a triple event,
@c the value is 3 or greater.  If @var{event} is an ordinary mouse event
@c (not a repeat event), the value is 1.
@end defun

@defopt double-click-fuzz
Переменная определяет дельту смещения в пикселах, в рамках которого нажатия
кнопки мыши будут считаться повторными нажатиями.

@c To generate repeat events, successive mouse button presses must be at
@c approximately the same screen position.  The value of
@c @code{double-click-fuzz} specifies the maximum number of pixels the
@c mouse may be moved (horizontally or vertically) between two successive
@c clicks to make a double-click.

Так же задается порог смещения, при превышении которого движение
мыши считается перетаскиванием.

@c This variable is also the threshold for motion of the mouse to count
@c as a drag.
@end defopt

@defopt double-click-time
Количество милисекунд между нажатиями, в рамках которого
второй нажатие считается двойным щелчком. Если значение @code{nil},
то двойные щелчки и нажатия не будут гененрироватья совсем. Если
значение @code{t}, временное ограничение будет отключено, и
двойные щелчки будут определяться только по позиции.

@c To generate repeat events, the number of milliseconds between
@c successive button presses must be less than the value of
@c @code{double-click-time}.  Setting @code{double-click-time} to
@c @code{nil} disables multi-click detection entirely.  Setting it to
@c @code{t} removes the time limit; Emacs then detects multi-clicks by
@c position only.
@end defopt

@node Motion Events
@subsection События Движения
@c @subsection Motion Events
@cindex motion event
@cindex mouse motion events

Иногда Emacs генерирует события @dfn{движение мыши} (@dfn{mouse motion})
для описания движения мыши без нажатия кнопок. События движения мыши
представляется списком, который выглядит как:

@c Emacs sometimes generates @dfn{mouse motion} events to describe motion
@c of the mouse without any button activity.  Mouse motion events are
@c represented by lists that look like this:

@example
(mouse-movement POSITION)
@end example

@noindent
@var{position} список позиция мыши (@pxref{Click Events}),
задающей текущую позицию курсора мыши. Как и с конечной позицией
события перемещения(drag), позиция может быть за границами изначально
выбранного фрейма, и тогда в позиции окна находится фрейм.

@c @var{position} is a mouse position list (@pxref{Click Events}),
@c specifying the current position of the mouse cursor.  As with the
@c end-position of a drag event, this position list may represent a
@c location outside the boundaries of the initially selected frame, in
@c which case the list contains that frame in place of a window.

Специальная форма @code{track-mouse} включает генерацию событий движения
внутри тела. Вне формы @code{track-mouse}, Emacs не генерирует события движения
мыши. @xref{Mouse Tracking}.

@c The special form @code{track-mouse} enables generation of motion
@c events within its body.  Outside of @code{track-mouse} forms, Emacs
@c does not generate events for mere motion of the mouse, and these
@c events do not appear.  @xref{Mouse Tracking}.

@node Focus Events
@subsection События Получения Фокуса
@c @subsection Focus Events
@cindex focus event

Оконная система предоставляет общий способ пользователю контролировать
какое окно получит ввод. Выбор окна называется @dfn{фокус}(@dfn{focus}).
Когда пользователь что-то делает и переключается между Emacs фреймами, генериуется
событие @dfn{фокуса} (@dfn{focus event}). Стандартная обработка для
события фокуса, в глобальной раскладке, выбор нового фрейма в Emacs,
как ожидает пользователь. @xref{Input Focus} содержит подробности, в том
числе описание перехватчиков.

@c Window systems provide general ways for the user to control which window
@c gets keyboard input.  This choice of window is called the @dfn{focus}.
@c When the user does something to switch between Emacs frames, that
@c generates a @dfn{focus event}.  The normal definition of a focus event,
@c in the global keymap, is to select a new frame within Emacs, as the user
@c would expect.  @xref{Input Focus}, which also describes hooks related
@c to focus events.

События фокуса в Lisp представляются списками:
@c Focus events are represented in Lisp as lists that look like this:

@example
(switch-frame @var{new-frame})
@end example

@noindent
где @var{new-frame}, фрейм куда переключились .
@c where @var{new-frame} is the frame switched to.

Некоторые менеджеры окнонных систем X(X windows managers), устроены
так, что простого перемещения мыши в окно достаточно, для получения
фокуса этим окном. Обычно, Lisp программам не нужно знать, о том, что
фокус изменился, до получения еще какого-то ввода. Emacs генерирует
событие фокуса (focus event) только когда пользователь
нажмет кнопку на клавиатуа или кнопку мыши внутри другого фрейма;
простое перемещение мыши между фреймами не генерирует событие фокуса.

@c Some X window managers are set up so that just moving the mouse into a
@c window is enough to set the focus there.  Usually, there is no need
@c for a Lisp program to know about the focus change until some other
@c kind of input arrives.  Emacs generates a focus event only when the
@c user actually types a keyboard key or presses a mouse button in the
@c new frame; just moving the mouse between frames does not generate a
@c focus event.

Событие фокуса в середине ключевой последовательности (клавиатурной кобминации)
будет искажать последовательность. Поэтому Emacs никогда не генерирует событие фокуса в
середине ключевой последовательности. Если пользователь
изменяет фокус в середине ключевой последовательности---то есть, после
префиксной комбинации---Emacs переупорядочивает события, так чтобы
событие фокуса шло до или послел ключевой последовательности, но
не внутри нее.

@c A focus event in the middle of a key sequence would garble the
@c sequence.  So Emacs never generates a focus event in the middle of a key
@c sequence.  If the user changes focus in the middle of a key
@c sequence---that is, after a prefix key---then Emacs reorders the events
@c so that the focus event comes either before or after the multi-event key
@c sequence, and not within it.

@node Misc Events
@subsection Разные Системные События
@c @subsection Miscellaneous System Events

Несколько типов событий представляют события в системе.
@c A few other event types represent occurrences within the system.

@table @code
@cindex @code{delete-frame} event
@item (delete-frame (@var{frame}))
Данное событие указывает, что пльзователь дал команду оконному
менеджеру (window manager) удалить определенное окно, являющееся Emacs фреймом.

@c This kind of event indicates that the user gave the window manager
@c a command to delete a particular window, which happens to be an Emacs frame.

Стандартное действие для события @code{delete-frame} удалить @var{frame}.
@c The standard definition of the @code{delete-frame} event is to delete @var{frame}.

@cindex @code{iconify-frame} event
@item (iconify-frame (@var{frame}))
Данное событие возникает если пльзователь свернул (iconified) @var{frame}
в оконном менеджере (window manager). Стандартное действия для
события @code{ignore}; так как фрейм уже будет свернут и Emacs
не нужно ничего делать. Цель данного события предоставить взможность его
отследилть, если это нужно.

@c This kind of event indicates that the user iconified @var{frame} using
@c the window manager.  Its standard definition is @code{ignore}; since the
@c frame has already been iconified, Emacs has no work to do.  The purpose
@c of this event type is so that you can keep track of such events if you
@c want to.

@cindex @code{make-frame-visible} event
@item (make-frame-visible (@var{frame}))
Событие указывает, что пользователь развернул фрейм (deiconified) @var{frame}
в оконном менеджере (window manager). Стандартная обрабтка события @code{ignore},
так как фрейм уже будет развернут, и Emacs ничего не нужно делать.

@c This kind of event indicates that the user deiconified @var{frame} using
@c the window manager.  Its standard definition is @code{ignore}; since the
@c frame has already been made visible, Emacs has no work to do.

@cindex @code{wheel-up} event
@cindex @code{wheel-down} event
@item (wheel-up @var{position})
@itemx (wheel-down @var{position})
Событие генерируется при прокрутки колесика мыши. Элемент @var{position}
список позиции мыши (mouse position list) (@pxref{Click Events}),
содержит данные позиции курсора мыши, при возникновения события.

@c These kinds of event are generated by moving a mouse wheel.  The
@c @var{position} element is a mouse position list (@pxref{Click
@c Events}), specifying the position of the mouse cursor when the event
@c occurred.

@vindex mouse-wheel-up-event
@vindex mouse-wheel-down-event
События генерируется только на некотоых систсема. На некторых
системах вместо него используется @code{mouse-4}, @code{mouse-5}. Чтобы
код был переносимым стоит испльзвать @code{mouse-wheel-up-event} и
@code{mouse-whell-down-event}, определенные в @file{mwheel.el} для
определения каких типов событий стоит ожидать от колесика мыши.

@c This kind of event is generated only on some kinds of systems.  On some
@c systems, @code{mouse-4} and @code{mouse-5} are used instead.  For
@c portable code, use the variables @code{mouse-wheel-up-event} and
@c @code{mouse-wheel-down-event} defined in @file{mwheel.el} to determine
@c what event types to expect for the mouse wheel.

@cindex @code{drag-n-drop} event
@item (drag-n-drop @var{position} @var{files})
Событие возникает если, группу файлов выделить в приложении отличном
от Emacs, а затем перетащить и отпустить в Emacs фрейме.

@c This kind of event is generated when a group of files is
@c selected in an application outside of Emacs, and then dragged and
@c dropped onto an Emacs frame.

@var{position} список описывающий позицию события, в том же формате,
что испльзуется для событий щелчков мыши (@pxref{Click Events}),
и @var{files} список имен файлов которые были перетащены. Обычная
обработка события заключается в открытии файлов.

@c The element @var{position} is a list describing the position of the
@c event, in the same format as used in a mouse-click event (@pxref{Click
@c Events}), and @var{files} is the list of file names that were dragged
@c and dropped.  The usual way to handle this event is by visiting these
@c files.

Данное событие генерируется не во всех операцинных системах.
@c This kind of event is generated, at present, only on some kinds of
@c systems.

@cindex @code{help-echo} event
@item help-echo
Вид события генерируется, когда курсор мыши движется над
текстом в буфере у которого есть текстовое свойство @code{help-echo}.
Сгенерированное событие имеет форму:

@c This kind of event is generated when a mouse pointer moves onto a
@c portion of buffer text which has a @code{help-echo} text property.
@c The generated event has this form:

@example
(help-echo @var{frame} @var{help} @var{window} @var{object} @var{pos})
@end example

@noindent
Подробное описание параметров и способ их использования при
отображаении текста в эхо-области описаны в @ref{Text help-echo}.

@c The precise meaning of the event parameters and the way these
@c parameters are used to display the help-echo text are described in
@c @ref{Text help-echo}.

@cindex @code{sigusr1} event
@cindex @code{sigusr2} event
@cindex user signals
@item sigusr1
@itemx sigusr2
События генерируются когда процесс Emacs получает сигналы
@code{SIGUSR1}, @code{SIGUSR2}. События не содержат дополнительных
данных, потому что ее не предоставляют сигналы.
События могут быть полезны при отладке (@pxref{Error Debugging}).

@c These events are generated when the Emacs process receives
@c the signals @code{SIGUSR1} and @code{SIGUSR2}.  They contain no
@c additional data because signals do not carry additional information.
@c They can be useful for debugging (@pxref{Error Debugging}).

Чтобы обрабтать сигнал, нужно связать соответствующее событие
с интерактивной командой в @code{special-event-map} (@pxref{Active Keymaps}).
Команда вызывается без аргументов, а событие сигнала доступно через
@code{last-input-event}. Например:

@c To catch a user signal, bind the corresponding event to an interactive
@c command in the @code{special-event-map} (@pxref{Active Keymaps}).
@c The command is called with no arguments, and the specific signal event is
@c available in @code{last-input-event}.  For example:

@smallexample
(defun sigusr-handler ()
  (interactive)
  (message "Caught signal %S" last-input-event))

(define-key special-event-map [sigusr1] 'sigusr-handler)
@end smallexample

Чтобы протестировать обработчик, можно послать Emac сигнал, например так:
@c To test the signal handler, you can make Emacs send a signal to itself:

@smallexample
(signal-process (emacs-pid) 'sigusr1)
@end smallexample

@cindex @code{language-change} event
@item language-change
Вид события генерируемый в MS-Windows когда меняется язык ввода. Как
правило это значит, что с клавиатуры будут приходить символы другого
языка. События имеет следующую форму:

@c This kind of event is generated on MS-Windows when the input language
@c has changed.  This typically means that the keyboard keys will send to
@c Emacs characters from a different language.  The generated event has
@c this form:

@smallexample
(language-change @var{frame} @var{codepage} @var{language-id})
@end smallexample

@noindent
Здесь @var{frame} текущий фрейм при получении события; @var{codepage}
номер новой кодовой страницы (codepage); @var{language-id} цифровой ID нового
языка ввода. Кодовая система (coding-system) (@pxref{Coding Systems}) соответствующая
@var{codepage} @code{cp@var{codepage}} или @code{windows-@var{codepage}}. Для
преобразования @var{language-id} в строку (например, чтобы использовать функции зависящие
от языка, такие как @code{set-language-environment}) используется функция
@code{w32-get-locale-info}, таким образом:

@c Here @var{frame} is the frame which was current when the input
@c language changed; @var{codepage} is the new codepage number; and
@c @var{language-id} is the numerical ID of the new input language.  The
@c coding-system (@pxref{Coding Systems}) that corresponds to
@c @var{codepage} is @code{cp@var{codepage}} or
@c @code{windows-@var{codepage}}.  To convert @var{language-id} to a
@c string (e.g., to use it for various language-dependent features, such
@c as @code{set-language-environment}), use the
@c @code{w32-get-locale-info} function, like this:

@smallexample
;; Получить аббревиатуру языка, такую как "ENU" для English
;; get the abbreviated language name, such as "ENU" for English
(w32-get-locale-info language-id)
;; Получить полное имя языка, для English, например,
;; "English (United States)"
;; Get the full English name of the language,
;; such as "English (United States)"
(w32-get-locale-info language-id 4097)
;; Получить полное локализованное имя для языка
;; Get the full localized name of the language
(w32-get-locale-info language-id t)
@end smallexample
@end table

  Если одно из событий получено в середине ключевой последвательности---
например после клавиш префикса---Emacs переупорядочивает события, так
чтобы событие было либо до, либо после ключевой последвательности
из нескльких событий (Прим. например комбинация из из нескльких клавиш),
но не внутри нее.

@c   If one of these events arrives in the middle of a key sequence---that
@c is, after a prefix key---then Emacs reorders the events so that this
@c event comes either before or after the multi-event key sequence, not
@c within it.

@node Event Examples
@subsection Примеры Событий
@c @subsection Event Examples

Если пользователь нажимает и отпускает левую кнопку мыши в одном
месте, генерируется последовательность событий наподобие этой:

@c If the user presses and releases the left mouse button over the same
@c location, that generates a sequence of events like this:

@smallexample
(down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
(mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))
@end smallexample

Если зажать control, нажать вторую кнопку мыши и перевести мышь
с одной строки на следующую будет следующая последовательность
событий:

@c While holding the control key down, the user might hold down the
@c second mouse button, and drag the mouse from one line to the next.
@c That produces two events, as shown here:

@smallexample
(C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
(C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                (#<window 18 on NEWS> 3510 (0 . 28) -729648))
@end smallexample

Следующующая последовательность событий будет, если зажать
meta, shift, зажать вторую клавишу мыши и перевести мыш из одного
окна в другое:

@c While holding down the meta and shift keys, the user might press the
@c second mouse button on the window's mode line, and then drag the mouse
@c into another window.  That produces a pair of events like these:

@smallexample
(M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
(M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                  (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                   -453816))
@end smallexample

Фрейм может не занимать весь экран, и пользователь может переменстить
мышь вне области фрейма. В специальной форме @code{track-mouse},
будет сгенерирвано событие аналогичное:

@c The frame with input focus might not take up the entire screen, and
@c the user might move the mouse outside the scope of the frame.  Inside
@c the @code{track-mouse} special form, that produces an event like this:

@smallexample
(mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))
@end smallexample

Для обратки сигнала SIGUSR1, нужно определть интерактивную функцию,
и привязать ее к @code{singal usr1} ключевой последовательности:

@c To handle a SIGUSR1 signal, define an interactive function, and
@c bind it to the @code{signal usr1} event sequence:

@smallexample
(defun usr1-handler ()
  (interactive)
  (message "Got USR1 signal"))
(global-set-key [signal usr1] 'usr1-handler)
@end smallexample

@node Classifying Events
@subsection Классивфикация Событий
@c @subsection Classifying Events
@cindex event type
@cindex classifying events

  Каждое событие имеет @dfn{event type} (@dfn{тип события}), используемый
при выполнении связываний с обработчиками. Для событий клавиатуры, тип
события совпадает с самим событием; таким образом, тип события для символа
это сам символ, и тип события для функциональной клавиши тоже символ
клавиши. Для событий, которые являются списками, тип события является символом
хранящимся в @sc{car} списка. Таким образом, тип всегда символ(объект)
или символ(знак).

@c   Every event has an @dfn{event type}, which classifies the event for
@c key binding purposes.  For a keyboard event, the event type equals the
@c event value; thus, the event type for a character is the character, and
@c the event type for a function key symbol is the symbol itself.  For
@c events that are lists, the event type is the symbol in the @sc{car} of
@c the list.  Thus, the event type is always a symbol or a character.

  Два события одного типа эквивалентны с точки зрения связанных обработчиков,
и таким образом запускают одни и теже команды. Это не обязательно
значит, что они делают одни и теже вещи, например команды могут смотреть
на все событие (остальные части списка) и выполнять действия в зависимости
от них. Например, команда может испльзовать положение мыши, чтобы
определить в каком месте буфера нужно выполнить действие.

@c   Two events of the same type are equivalent where key bindings are
@c concerned; thus, they always run the same command.  That does not
@c necessarily mean they do the same things, however, as some commands look
@c at the whole event to decide what to do.  For example, some commands use
@c the location of a mouse event to decide where in the buffer to act.

  Иногда полезны более широкии класификации событий. Например, может
быть нужно узнать была ли зажата клавиша @key{META}, без конкретики
какая именно клавиша клавиатуры или мыши была нажата.

@c   Sometimes broader classifications of events are useful.  For example,
@c you might want to ask whether an event involved the @key{META} key,
@c regardless of which other key or mouse button was used.

  Функции @code{event-modifiers} и @code{event-basic-type} используются
для получения данной информации.

@c   The functions @code{event-modifiers} and @code{event-basic-type} are
@c provided to get such information conveniently.

@defun event-modifiers event
Функция возвращает список модификаторов @var{event}. Модификаторы
представляются символами; включают @code{shift}, @code{control},
@code{meta}, @code{alt}, @code{hyper} и @code{super}. В дополнении
список модификаторов для событий мыши включает один из символов
@code{click}, @code{drag}, @code{down}. Для двойных и тройных событий,
список будет дополнительно содержать @code{double} или @code{triple}.

@c This function returns a list of the modifiers that @var{event} has.  The
@c modifiers are symbols; they include @code{shift}, @code{control},
@c @code{meta}, @code{alt}, @code{hyper} and @code{super}.  In addition,
@c the modifiers list of a mouse event symbol always contains one of
@c @code{click}, @code{drag}, and @code{down}.  For double or triple
@c events, it also contains @code{double} or @code{triple}.

Аргумент @var{event} может быть объектом событием, или только типом
события. Если @var{event} символ, который не использовался при считывании
в текущей сессии Emacs, @code{event-modifiers} может вернуть @code{nil},
даже если @var{event} имеет модификаторы.

@c The argument @var{event} may be an entire event object, or just an
@c event type.  If @var{event} is a symbol that has never been used in an
@c event that has been read as input in the current Emacs session, then
@c @code{event-modifiers} can return @code{nil}, even when @var{event}
@c actually has modifiers.

Несколько примеров:
@c Here are some examples:

@example
(event-modifiers ?a)
     @result{} nil
(event-modifiers ?A)
     @result{} (shift)
(event-modifiers ?\C-a)
     @result{} (control)
(event-modifiers ?\C-%)
     @result{} (control)
(event-modifiers ?\C-\S-a)
     @result{} (control shift)
(event-modifiers 'f5)
     @result{} nil
(event-modifiers 's-f5)
     @result{} (super)
(event-modifiers 'M-S-f5)
     @result{} (meta shift)
(event-modifiers 'mouse-1)
     @result{} (click)
(event-modifiers 'down-mouse-1)
     @result{} (down)
@end example

Список модификаторов для события щелчка явно содержит @code{click},
но имя символа не содержит @samp{click}.

@c The modifiers list for a click event explicitly contains @code{click},
@c but the event symbol name itself does not contain @samp{click}.
@end defun

@defun event-basic-type event
Функция возвращает клавишу или кнопку мыши, которая описывает
@var{event}, если из него удалить все модификаторы. Аргумент @var{event}
такой же как в @code{event-modifiers}.

@c This function returns the key or mouse button that @var{event}
@c describes, with all modifiers removed.  The @var{event} argument is as
@c in @code{event-modifiers}.  For example:

@example
(event-basic-type ?a)
     @result{} 97
(event-basic-type ?A)
     @result{} 97
(event-basic-type ?\C-a)
     @result{} 97
(event-basic-type ?\C-\S-a)
     @result{} 97
(event-basic-type 'f5)
     @result{} f5
(event-basic-type 's-f5)
     @result{} f5
(event-basic-type 'M-S-f5)
     @result{} f5
(event-basic-type 'down-mouse-1)
     @result{} mouse-1
@end example
@end defun

@defun mouse-movement-p object
sxФункция возвращает не-@code{nil} если @var{object} движение перемещения мыши.
@xref{Motion Events}.

@c This function returns non-@code{nil} if @var{object} is a mouse movement
@c event.  @xref{Motion Events}.
@end defun

@defun event-convert-list list
Функция преобразует список модификаторов и базовый тип события в тип
события определяющий их все. Базовый тип элемента должен находится в конце
списка. Например:

@c This function converts a list of modifier names and a basic event type
@c to an event type which specifies all of them.  The basic event type
@c must be the last element of the list.  For example,

@example
(event-convert-list '(control ?a))
     @result{} 1
(event-convert-list '(control meta ?a))
     @result{} -134217727
(event-convert-list '(control super f1))
     @result{} C-s-f1
@end example
@end defun

@node Accessing Mouse
@subsection Получение Даных Событий Мыши
@c @subsection Accessing Mouse Events
@cindex mouse events, data in
@cindex keyboard events, data in

  Данный раздел описывает получения данных для событий нажатия кнопок
мыши или движения мыши. Эти функции могут испсользоваться и для получения данных
для событий клавиатуры, но если какие-то элементы отсутствуют в событиях
клавиатуры результаты будут ноль или @code{nil}.

@c   This section describes convenient functions for accessing the data in
@c a mouse button or motion event.  Keyboard event data can be accessed
@c using the same functions, but data elements that aren't applicable to
@c keyboard events are zero or @code{nil}.

  Две следующие функции возвращают список позиции мыши
(@pxref{Click Events}).

@c   The following two functions return a mouse position list
@c (@pxref{Click Events}), specifying the position of a mouse event.

@defun event-start event
Функция возвращает начальную позицию @var{event}.
@c This returns the starting position of @var{event}.

Если @var{event} щелчок (clibk) или нажатие, возвращается место
где события. Если @var{event} перетаскивание, возвращается начальная
позиция перестаскивания.

@c If @var{event} is a click or button-down event, this returns the
@c location of the event.  If @var{event} is a drag event, this returns the
@c drag's starting position.
@end defun

@defun event-end event
Функция возвращает конечную позицию @var{event}.
@c This returns the ending position of @var{event}.

Если @var{event} событие перетаскивания, возвращается позиция, где
пользователь отпустил кнопку мыши. Если @var{event} щелчок или нажатие,
значение совпадает с начальной позицией, которая является единственной
позицией, которая есть у события.

@c If @var{event} is a drag event, this returns the position where the user
@c released the mouse button.  If @var{event} is a click or button-down
@c event, the value is actually the starting position, which is the only
@c position such events have.
@end defun

@defun posnp object
Функция возвращается не-@code{nil} если @var{object} список
позиции мыши, в любом из форматов описанных в @ref{Click Events},
иначе возвращается @code{nil}.

@c This function returns non-@code{nil} if @var{object} is a mouse
@c position list, in either of the formats documented in @ref{Click
@c Events}); and @code{nil} otherwise.
@end defun

@cindex mouse position list, accessing
  Следующие функции получает список позиции мыши в качестве аргумент и возвращает
разные его части.

@c   These functions take a mouse position list as argument, and return
@c various parts of it:

@defun posn-window position
Возвращает окно из списка @var{position}. Если @var{position}
представляет место вне фрейма, где событие было начато, возвращается
фрейм.

@c Return the window that @var{position} is in.  If @var{position}
@c represents a location outside the frame where the event was initiated,
@c return that frame instead.
@end defun

@defun posn-area position
Возвращает область окна хранящуюся в @var{position}. Возвращается @code{nil}
если событие происходит в текстовой области, иначе символ, определяющий
область где произошло событие.

@c Return the window area recorded in @var{position}.  It returns @code{nil}
@c when the event occurred in the text area of the window; otherwise, it
@c is a symbol identifying the area in which the event occurred.
@end defun

@defun posn-point position
Возвращает позицию в буфере @var{position}. Если событие произошло
в текстовой области, области краев(fringes), области отступов(marginal area)
возвращается целое число определяющее позицию в буфере, иначе
возвращаемое значение не определено.

@c Return the buffer position in @var{position}.  When the event occurred
@c in the text area of the window, in a marginal area, or on a fringe,
@c this is an integer specifying a buffer position.  Otherwise, the value
@c is undefined.
@end defun

@defun posn-x-y position
Возвращает пиксельные координаты x и y в @var{position}, в виде
cons ячейки @code{(@var{x} . @var{y})}. Координаты считаются относительно
окна, полученного вызовом @code{posn-window}.

@c Return the pixel-based x and y coordinates in @var{position}, as a
@c cons cell @code{(@var{x} . @var{y})}.  These coordinates are relative
@c to the window given by @code{posn-window}.

Пример показывает как преобразовать относительные координаты
в текстовой области окна в координаты относительно фрейма:

@c This example shows how to convert the window-relative coordinates in
@c the text area of a window into frame-relative coordinates:

@example
(defun frame-relative-coordinates (position)
  "Return frame-relative coordinates from POSITION.
POSITION is assumed to lie in a window text area."
  (let* ((x-y (posn-x-y position))
         (window (posn-window position))
         (edges (window-inside-pixel-edges window)))
    (cons (+ (car x-y) (car edges))
          (+ (cdr x-y) (cadr edges)))))
@end example
@end defun

@defun posn-col-row position
Функция возвращает cons ячейку @code{(@var{col} . @var{row})},
содержащую колонку и строку соответсвующие позиции @var{position}
в буфере. Возвращается значение расчитываемое на основе
ширины символа пол умолчанию и высоты строки(учитывая растояние между строками)
по умолчанию для фрейма, для значений @var{x} и @var{y} из @var{position}.
(Поэтому если реальные символы имеют размеры отличные от дефолтных, реальные
номер колонки и строки могут отличаться, от вычисленных.)

@c This function returns a cons cell @code{(@var{col} .  @var{row})},
@c containing the estimated column and row corresponding to buffer
@c position in @var{position}.  The return value is given in units of the
@c frame's default character width and default line height (including
@c spacing), as computed from the @var{x} and @var{y} values
@c corresponding to @var{position}.  (So, if the actual characters have
@c non-default sizes, the actual row and column may differ from these
@c computed values.)

Стоит отметить, что @var{row} считается от верха текстовой области. Если
окно для @var{position} имеет строку заголовка (@pxref{Header Lines}),
она не учитывается при вычислении @var{row}.

@c Note that @var{row} is counted from the top of the text area.  If the
@c window given by @var{position} possesses a header line (@pxref{Header
@c Lines}), it is @emph{not} included in the @var{row} count.
@end defun

@defun posn-actual-col-row position
Функция возвращает реальные строку и колонку для @var{position},
в сиде cons ячейки @code{(@var{col} . @var{row})}. Значениями являются
числа. @xref{Click Events}. Функция возвращает @code{nil}, если @var{position}
не содержит реальные значения позиции; в этом случае можно использовать
@code{posn-col-row} для получения приблизительных значений.

@c Return the actual row and column in @var{position}, as a cons cell
@c @code{(@var{col} . @var{row})}.  The values are the actual row and
@c column numbers in the window given by @var{position}.  @xref{Click
@c Events}, for details.  The function returns @code{nil} if
@c @var{position} does not include actual position values; in that case
@c @code{posn-col-row} can be used to get approximate values.

Функция не учитывает визуальную ширину символов на экране, как и
визиульное количество колонок символа tab или изображения. Если нужны
координаты в канонических единицах стоит использовать @code{posn-col-row}.

@c Note that this function doesn't account for the visual width of
@c characters on display, like the number of visual columns taken by a
@c tab character or an image.  If you need the coordinates in canonical
@c character units, use @code{posn-col-row} instead.
@end defun

@defun posn-string position
Функция возвращает строковый объект в @var{position}, или @code{nil},
или cons ячейку @code{(@var{string} . @var{string-pos})}.

@c Return the string object in @var{position}, either @code{nil}, or a
@c cons cell @code{(@var{string} . @var{string-pos})}.
@end defun

@defun posn-image position
Возвращает объект изображения в @var{position}, или @code{nil},
или изображение @code{(image ...)}.

@c Return the image object in @var{position}, either @code{nil}, or an
@c image @code{(image ...)}.
@end defun

@defun posn-object position
Возвращает изображение или строковый объект в @var{position},
либо @code{nil}, либо @code{image ...}, или cons ячейку
@code{(@var{string} . @var{string-pos})}.

@c Return the image or string object in @var{position}, either
@c @code{nil}, an image @code{(image ...)}, or a cons cell
@c @code{(@var{string} . @var{string-pos})}.
@end defun

@defun posn-object-x-y position
Возвращает пиксельные координаты x и y, отноительно верхнего левого
угла объекта в @var{position} в виде cons ячейки @code{(@var{dx} . @var{dy})}.
Если @var{position} находится не тексте в буфере, возвращается
относительная позция символа ближайшего к позици @var{position}.

@c Return the pixel-based x and y coordinates relative to the upper left
@c corner of the object in @var{position} as a cons cell @code{(@var{dx}
@c . @var{dy})}.  If the @var{position} is on buffer text, return the
@c relative position of the buffer-text character closest to that
@c position.
@end defun

@defun posn-object-width-height position
Функция возвращает ширину и высоту объекта в пикселях в позиции @var{position}
в виде cons ячейки @code{(@var{width} . @var{height})}. Если @var{position}
позиция буфера, возвращается размер символа в позиции.

@c Return the pixel width and height of the object in @var{position} as a
@c cons cell @code{(@var{width} . @var{height})}.  If the @var{position}
@c is a buffer position, return the size of the character at that position.
@end defun

@cindex timestamp of a mouse event
@defun posn-timestamp position
Возвращает временную метку из @var{position}. Это время в которое
произошло событие, в милесекундах.

@c Return the timestamp in @var{position}.  This is the time at which the
@c event occurred, in milliseconds.
@end defun

  Функции вычисляют список позиционирования (position list) для
заданной позиции в буфере или экрана. Обращение к частям списка
осуществляется с помощью функций описанных выше.

@c   These functions compute a position list given particular buffer
@c position or screen position.  You can access the data in this position
@c list with the functions described above.

@defun posn-at-point &optional pos window
Функция возвращает список позиционирования для позиции @var{pos}
в @var{window}. @var{pos} по умолчанию, точка курсора в @var{window}.
@var{window} по умолчанию текущее окно.

@c This function returns a position list for position @var{pos} in
@c @var{window}.  @var{pos} defaults to point in @var{window};
@c @var{window} defaults to the selected window.

@code{posn-at-point} возвращает @code{nil} если @var{pos} не видна
в @var{window}.

@c @code{posn-at-point} returns @code{nil} if @var{pos} is not visible in
@c @var{window}.
@end defun

@defun posn-at-x-y x y &optional frame-or-window whole
Функция возвращает иформацию о позиции соответствующей коодинатам
@var{x} и @var{y} в пикселях, в заданном фрейме или окне, @var{frame-or-window},
которое по умолчанию соответствует выбранному окну.
Координаты @var{x} и @var{y} относительные для фейма или окна.

@c This function returns position information corresponding to pixel
@c coordinates @var{x} and @var{y} in a specified frame or window,
@c @var{frame-or-window}, which defaults to the selected window.
@c The coordinates @var{x} and @var{y} are relative to the
@c frame or window used.

Если @var{whole} @code{nil}, координаты относительны текстовой
облати окна, иначе относительны внутренней части окна, включая
полосы прокрутки, отступы(margins) и края(fringes).

@c If @var{whole} is @code{nil}, the coordinates are relative
@c to the window text area, otherwise they are relative to
@c the entire window area including scroll bars, margins and fringes.
@end defun

@node Accessing Scroll
@subsection Получение Событий Полосы Прокрутки
@c @subsection Accessing Scroll Bar Events
@cindex scroll bar events, data in

  Функции данного раздела полезны при разборе событий полосы прокрутки.
  @c These functions are useful for decoding scroll bar events.

@defun scroll-bar-event-ratio event
Функция возвращает дробную часть позиции события полосы прокрутки внутри
полосы прокрутки (видимо отношение позиции ползунка, к длине всей полосы).
Значением является cons ячейка @code{(@var{portion} . @var{whole})} содержащей
два числа, чье соотношение описывает положение ползунка.

@c This function returns the fractional vertical position of a scroll bar
@c event within the scroll bar.  The value is a cons cell
@c @code{(@var{portion} . @var{whole})} containing two integers whose ratio
@c is the fractional position.
@end defun

@defun scroll-bar-scale ratio total
Функция умножает @var{ratio} на @var{total}, округляя результат до
целого. Аргумент @var{ratio} не число, а пара @code{(@var{num} . @var{denom})}---
как правило значение возвращаемое @code{scroll-bar-event-ratio}.

@c This function multiplies (in effect) @var{ratio} by @var{total},
@c rounding the result to an integer.  The argument @var{ratio} is not a
@c number, but rather a pair @code{(@var{num} . @var{denom})}---typically a
@c value returned by @code{scroll-bar-event-ratio}.

Функция для масштабирования позиции на полосе прокрутке, до позиции
в буфере. Например это можно сделать так:

@c This function is handy for scaling a position on a scroll bar into a
@c buffer position.  Here's how to do that:

@example
(+ (point-min)
   (scroll-bar-scale
      (posn-x-y (event-start event))
      (- (point-max) (point-min))))
@end example

События полосы прокрутки содержат два целых числа формирующих отношение,
вместо пары координат x и y.

@c Recall that scroll bar events have two integers forming a ratio, in place
@c of a pair of x and y coordinates.
@end defun

@node Strings of Events
@subsection Запись Событий в Строку
@c @subsection Putting Keyboard Events in Strings
@cindex keyboard events in strings
@cindex strings with keyboard events

  В большинстве мест где используются строки, предполагается, что
строки содержат символы(знаки) текста---в том же виде символы(знаки)
находятся в буферах и файлах. Время от времени Lisp программы используют
строки содержащие клавиатурные символы; например, они могут быть
ключевой последовательностью или определением клавиатурного макроса.
Хранение клавиатурных знаков в строке сложная задача, по причинам исторической
совместимости, и не всегда возможно.

@c   In most of the places where strings are used, we conceptualize the
@c string as containing text characters---the same kind of characters found
@c in buffers or files.  Occasionally Lisp programs use strings that
@c conceptually contain keyboard characters; for example, they may be key
@c sequences or keyboard macro definitions.  However, storing keyboard
@c characters in a string is a complex matter, for reasons of historical
@c compatibility, and it is not always possible.

  Рекомендуется, новым программым избегать даной сложности и не хранить
события клавиатуры в строках. Ниже описывается как это делать:

@c   We recommend that new programs avoid dealing with these complexities
@c by not storing keyboard events in strings.  Here is how to do that:

@itemize @bullet
@item
Использовать векторы вместо строк для ключевых последовательностей,
когда планируется использовать их для чего-то кроме @code{lookup-key} и
@code{define-key}. Например, можно использовать @code{read-key-sequence-vector}
вместо @code{read-key-sequence}, и @code{this-command-keys-vector} вместо
@code{this-command-keys}.

@c Use vectors instead of strings for key sequences, when you plan to use
@c them for anything other than as arguments to @code{lookup-key} and
@c @code{define-key}.  For example, you can use
@c @code{read-key-sequence-vector} instead of @code{read-key-sequence}, and
@c @code{this-command-keys-vector} instead of @code{this-command-keys}.

@item
Использовать вектора для записи константных ключевых последовательностей
содержащих мета символы, даже когда они передаются напрямую в @code{define-key}.

@c Use vectors to write key sequence constants containing meta characters,
@c even when passing them directly to @code{define-key}.

@item
Если выполняется работа с объектом содержащим ключевую последовательность,
которая может быть строкой, сначал использовать @code{listify-key-sequence}
(@pxref{Event Input Misc}) для преобразования последовательностей в списки.

@c When you have to look at the contents of a key sequence that might be a
@c string, use @code{listify-key-sequence} (@pxref{Event Input Misc})
@c first, to convert it to a list.
@end itemize

  Сложности возникают из-за битов модификаторов, которые могут включать
символы вводимые с клавиатуры. Кроме Meta модификатора, ни один из
этих битов модификаторов не может быть включен в строку, и Meta модификатор
разрешен только в особых случаях.

@c   The complexities stem from the modifier bits that keyboard input
@c characters can include.  Aside from the Meta modifier, none of these
@c modifier bits can be included in a string, and the Meta modifier is
@c allowed only in special cases.

  Ранние версии GNU Emacs представляли meta символы кодами в диапазоне
от 128 до 255. В то время базовые кода символов находились в диапазоне
от 0 до 127, поэтому все символы клавиатуры помещались в строке. Много
Lisp программ использует @samp{\M-} в строковых константах для установки
meta символов, особенно в аргументах @code{define-key} и аналогичных
функциях, ключевые последовательности и последовательности событий
всегда представлялись строками.

@c   The earliest GNU Emacs versions represented meta characters as codes
@c in the range of 128 to 255.  At that time, the basic character codes
@c ranged from 0 to 127, so all keyboard character codes did fit in a
@c string.  Many Lisp programs used @samp{\M-} in string constants to stand
@c for meta characters, especially in arguments to @code{define-key} and
@c similar functions, and key sequences and sequences of events were always
@c represented as strings.

  Когда добавили поддержка для базовых кодов символов между 127 и
дополнительные биты модификаторы, было изменено представление meta
символов. В настоящий момент флаг, который представляет Meta модификатор
в символе

@c   When we added support for larger basic character codes beyond 127, and
@c additional modifier bits, we had to change the representation of meta
@c characters.  Now the flag that represents the Meta modifier in a
@c character is
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
и такие числа не могут быть включены в строку.
@c and such numbers cannot be included in a string.

  Для поддержки программ содержащих в строках @samp{\M-}, есть
специальные правила для включения определенных meta символов в строку.
Ниже правила интерпретации строки в качестве последовательности
символов ввода:

@c   To support programs with @samp{\M-} in string constants, there are
@c special rules for including certain meta characters in a string.
@c Here are the rules for interpreting a string as a sequence of input
@c characters:

@itemize @bullet
@item
Если символ с клавиатуры в диапазоне от 0 до 127, он может использоваться
в строке без изменений.

@c If the keyboard character value is in the range of 0 to 127, it can go
@c in the string unchanged.

@item
meta варианты символов, с кодами из диапазона
@c The meta variants of those characters, with codes in the range of
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
до
@c to
@tex
@math{2^{27} + 127},
@end tex
@ifnottex
2**27+127,
@end ifnottex
могут использоваться в строке, но нужно изменить их
числовые значения. Нужно установить
@c can also go in the string, but you must change their
@c numeric values.  You must set the
@tex
@math{2^{7}}
@end tex
@ifnottex
2**7
@end ifnottex
бит вместо
@c bit instead of the
@tex
@math{2^{27}}
@end tex
@ifnottex
2**27
@end ifnottex
бита, в результате чего будет значение между 128 и 255. Только
одно-байтовые строки могут включать эти значения.

@c bit, resulting in a value between 128 and 255.  Only a unibyte string
@c can include these codes.

@item
Не-@acronym{ASCII} символы большие 256 могут включаться в много-байтовые строки.
@c Non-@acronym{ASCII} characters above 256 can be included in a multibyte string.

@item
Другие события клавиатуры не могут размещаться в строке. В данный
диапазон входят события с номерами от 128 до 255.
@c Other keyboard character events cannot fit in a string.  This includes
@c keyboard events in the range of 128 to 255.
@end itemize

  Функции такие как @code{read-key-sequence}, которые создают строку, для
ввода с клавиатуры, придерживаются этих правил: они создают вектор вместо
строк, когда события не могут быть помещены в строку.

@c   Functions such as @code{read-key-sequence} that construct strings of
@c keyboard input characters follow these rules: they construct vectors
@c instead of strings, when the events won't fit in a string.

  Когда используется синтаксис чтения @samp{\M-} в строке, создается код
в диапазоне 128-255---тот же код, который будет получен если изменить
соответствующее событие клавиатуры для помещения его в строку. Таким, образом
соблюдается последовательность при работе с meta событиями в строках.

@c   When you use the read syntax @samp{\M-} in a string, it produces a
@c code in the range of 128 to 255---the same code that you get if you
@c modify the corresponding keyboard event to put it in the string.  Thus,
@c meta events in strings work consistently regardless of how they get into
@c the strings.

  Но, хорошо, если большинство программ будет избегать использования
строк для событий клавиатуры, следуя рекомендации в начале данной секции.

@c   However, most programs would do well to avoid these issues by
@c following the recommendations at the beginning of this section.

@node Reading Input
@section Считывание Ввода
@c @section Reading Input
@cindex read input
@cindex keyboard input

  Командный цикл редактора считывает ключевые последовательности
используя функцию @code{read-key-sequence}, которая использует
@code{read-event}. Эта и другие функции для считывания событий
доступны для использования в Lisp программах. Так же стоит
ознакомиться с @code{momentary-string-display} в @ref{Temporary Displays},
и @code{sit-for} в @ref{Waiting}. См. @xref{Terminal Input}, по
функциям и переменным контролирующим режимы ввода с терминала и
отладке ввода в терминале.

@c   The editor command loop reads key sequences using the function
@c @code{read-key-sequence}, which uses @code{read-event}.  These and other
@c functions for event input are also available for use in Lisp programs.
@c See also @code{momentary-string-display} in @ref{Temporary Displays},
@c and @code{sit-for} in @ref{Waiting}.  @xref{Terminal Input}, for
@c functions and variables for controlling terminal input modes and
@c debugging terminal input.

  Средства ввода более высокого уровня описнаы в @ref{Minibuffers}.
  @c For higher-level input facilities, see @ref{Minibuffers}.

@menu
* Key Sequence Input::          Как считать одну ключевую последовательность.
* Reading One Event::           Как считать одно событие.
* Event Mod::                   Как Emacs изменяет события по мере их чтения.
* Invoking the Input Method::   Как чтение события использует метод ввода.
* Quoted Character Input::      Запрос пользователя задать символ.
* Event Input Misc::            Как перечитать или выбросить событие ввода.
@end menu

@c @menu
@c * Key Sequence Input::          How to read one key sequence.
@c * Reading One Event::           How to read just one event.
@c * Event Mod::                   How Emacs modifies events as they are read.
@c * Invoking the Input Method::   How reading an event uses the input method.
@c * Quoted Character Input::      Asking the user to specify a character.
@c * Event Input Misc::            How to reread or throw away input events.
@c @end menu

@node Key Sequence Input
@subsection Ввод Ключевой Последовательности
@c @subsection Key Sequence Input
@cindex key sequence input

  Командный цикл считывает ключевую последовательность, вызывая
@code{read-key-sequence}. Данную функцию можно использовать и в Lisp
программах, например, @code{describe-key} использует ее для считывания
ключа, для которого нужно показать описание.

@c   The command loop reads input a key sequence at a time, by calling
@c @code{read-key-sequence}.  Lisp programs can also call this function;
@c for example, @code{describe-key} uses it to read the key to describe.

@defun read-key-sequence prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
Функция считыват ключевую последовательность и возвращает ее в виде
строки или вектора. Считывание событие продолжается пока не будет
считана полная последовательность, то есть, ее должно быть достаточно
для какой-то не-префикс команды используя текущую раскладку. (Ключевая
последовательность начинающаяся с события мыши, использует
раскладку буфера к которому относится это событие мыши, и это не обязательно
текущий буфер.)

@c This function reads a key sequence and returns it as a string or
@c vector.  It keeps reading events until it has accumulated a complete key
@c sequence; that is, enough to specify a non-prefix command using the
@c currently active keymaps.  (Remember that a key sequence that starts
@c with a mouse event is read using the keymaps of the buffer in the
@c window that the mouse was in, not the current buffer.)

Если события все события символы и могут быть помещены в строку, тогда
@code{read-key-sequence} вернет строку (@pxref{Strings of Events}).
Иначе, возвращается вектор, так как вектор может хранить все виды событий---
символы(знаки), символы(объекты), и списки.

@c If the events are all characters and all can fit in a string, then
@c @code{read-key-sequence} returns a string (@pxref{Strings of Events}).
@c Otherwise, it returns a vector, since a vector can hold all kinds of
@c events---characters, symbols, and lists.  The elements of the string or
@c vector are the events in the key sequence.

Чтение ключевой последовательности включает перевод(преобразование) событий
разными способами. @xref{Translation Keymaps}.

@c Reading a key sequence includes translating the events in various
@c ways.  @xref{Translation Keymaps}.

Аргумент @var{prompt} может быть строкой, которая будет отображена в
эхо области, либо @code{nil}, если отображение запроса не нужно.
Аргумент @var{continue-echo}, если не-@code{nil}, означает вывод
данного ключа, как продолжение предыдущего.

@c The argument @var{prompt} is either a string to be displayed in the
@c echo area as a prompt, or @code{nil}, meaning not to display a prompt.
@c The argument @var{continue-echo}, if non-@code{nil}, means to echo
@c this key as a continuation of the previous key.

Обычно любое событие в верхнем регистре преобразуется к нижнему регистру,
если событие не определено, но определено эквивалентное событие
в нижнем регистре. Аргумент @var{dont-downcase-last}, если не-@code{nil},
указывает на то, что не нужно преобразовывать события к нижнему регистру.
Ключ подходит, для чтения последовательностей, события в которых
должны быть определены.

@c Normally any upper case event is converted to lower case if the
@c original event is undefined and the lower case equivalent is defined.
@c The argument @var{dont-downcase-last}, if non-@code{nil}, means do not
@c convert the last event to lower case.  This is appropriate for reading
@c a key sequence to be defined.

Аргумент @var{switch-frame-ok}, если не-@code{nil}, означает, что
функция должна обработать событие @code{switch-frame} (если пользователь
переключит фрейм), прежде чем что-то выводить. Если пользователь
перелючает фреймы в середине ключевой последовательности, или в начале
последовательности, но @var{switch-frame-ok} @code{nil}, тогда событие
будет отложено до конца текущей последовательности.

@c The argument @var{switch-frame-ok}, if non-@code{nil}, means that this
@c function should process a @code{switch-frame} event if the user
@c switches frames before typing anything.  If the user switches frames
@c in the middle of a key sequence, or at the start of the sequence but
@c @var{switch-frame-ok} is @code{nil}, then the event will be put off
@c until after the current key sequence.

Аргумент @var{command-loop}, если не-@code{nil}, указывает, что
ключевая последовательность читается чем-то, что читает одну команду
за другой. Если вызывающий код считывает только одну последовательность,
значение должно быть @code{nil}.

@c The argument @var{command-loop}, if non-@code{nil}, means that this
@c key sequence is being read by something that will read commands one
@c after another.  It should be @code{nil} if the caller will read just
@c one key sequence.

В следующем примере, Emacs отображает запрос @samp{?} в эхо
области, а затем пользователь вводит @kbd{C-x C-f}.

@c In the following example, Emacs displays the prompt @samp{?} in the
@c echo area, and then the user types @kbd{C-x C-f}.

@example
(read-key-sequence "?")

@group
---------- Echo Area ----------
?@kbd{C-x C-f}
---------- Echo Area ----------

     @result{} "^X^F"
@end group
@end example

Функция @code{read-key-sequence} подавляет выход по @kbd{C-g} во
время считывания ввода, и данная комбинация работает как любая другая,
и не устанавливает @code{quit-flag}. @xref{Quitting}.

@c The function @code{read-key-sequence} suppresses quitting: @kbd{C-g}
@c typed while reading with this function works like any other character,
@c and does not set @code{quit-flag}.  @xref{Quitting}.
@end defun

@defun read-key-sequence-vector prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop
Функция аналогична @code{read-key-sequence} за исключением,
того, что результат всегда вектор, и никогда строка.
@xref{Strings of Events}.

@c This is like @code{read-key-sequence} except that it always
@c returns the key sequence as a vector, never as a string.
@c @xref{Strings of Events}.
@end defun

@cindex upper case key sequence
@cindex downcasing in @code{lookup-key}
@cindex shift-translation
Если вводимый символ(знак), в верхнем регистре (или имеет shift модификатор)
и не имеет привязцки, но эквивалентная версия в нижнем регистре имеет,
тогда @code{read-key-sequence} преобразует символ к нижнему регистру. @code{lookup-key}
не выполняет преобразование регистра таким образом.

@c If an input character is upper-case (or has the shift modifier) and
@c has no key binding, but its lower-case equivalent has one, then
@c @code{read-key-sequence} converts the character to lower case.  Note
@c that @code{lookup-key} does not perform case conversion in this way.

@vindex this-command-keys-shift-translated
При считывании ввода с поддержкой @dfn{shift-translation} (@dfn{преобразованием регистра})
Emacs Устанавливает переменную @code{this-command-keys-shift-translation}
в не-@code{nil}. Lisp программы могут использовать значение этой
переменной, если они должны менять свое поведения для случая
вызова по ключевой комбинации, полученной с поддержкой shift-translation.
Например функция, @code{handle-shift-selection} использует
эту переменную, чтобы определить как активировать или отключить
область (@pxref{The Mark, handle-shift-selection}).

@c When reading input results in such a @dfn{shift-translation}, Emacs
@c sets the variable @code{this-command-keys-shift-translated} to a
@c non-@code{nil} value.  Lisp programs can examine this variable if they
@c need to modify their behavior when invoked by shift-translated keys.
@c For example, the function @code{handle-shift-selection} examines the
@c value of this variable to determine how to activate or deactivate the
@c region (@pxref{The Mark, handle-shift-selection}).

Функция @code{read-key-sequence} преобразует некоторые события мыши.
Выполняется преобразование перетаскиваний(drag events) за границы в события щелчки
(click events), а события опускания кнопки (button-down) за границами
вообще отбрасываются. Функция так же переставляет события фокуса и разные
события онка, так чтобы они не появлялись внутри ключевых
последовательностей из других событий.

@c The function @code{read-key-sequence} also transforms some mouse events.
@c It converts unbound drag events into click events, and discards unbound
@c button-down events entirely.  It also reshuffles focus events and
@c miscellaneous window events so that they never appear in a key sequence
@c with any other events.

@cindex @code{header-line} prefix key
@cindex @code{mode-line} prefix key
@cindex @code{vertical-line} prefix key
@cindex @code{horizontal-scroll-bar} prefix key
@cindex @code{vertical-scroll-bar} prefix key
@cindex @code{menu-bar} prefix key
@cindex mouse events, in special parts of frame
Когда события мыши происходят в определенных частях окна, таких
как строка режима, или полоса прокрутки, тип события не показывает
ничего особенного---это тот же символ, указывающий комбинацию
из кнопки мыши и кнопок модификаторов. Информация о части окна, к
которой относится событие находится в другой части события, а именно
в координатах. Но @code{read-key-sequence} преобразует эту информацию
в мнимые префикс ключи, которые представляются символами:
@code{header-line}, @code{horizontal-scroll-bar}, @code{menu-bar},
@code{mode-line}, @code{vertical-line}, и @code{vertical-scroll-bar}.
Можно задать обработчики, для щелчков мыши в определенных
областях окна, используя эти префикс ключи.

@c When mouse events occur in special parts of a window, such as a mode
@c line or a scroll bar, the event type shows nothing special---it is the
@c same symbol that would normally represent that combination of mouse
@c button and modifier keys.  The information about the window part is kept
@c elsewhere in the event---in the coordinates.  But
@c @code{read-key-sequence} translates this information into imaginary
@c prefix keys, all of which are symbols: @code{header-line},
@c @code{horizontal-scroll-bar}, @code{menu-bar}, @code{mode-line},
@c @code{vertical-line}, and @code{vertical-scroll-bar}.  You can define
@c meanings for mouse clicks in special window parts by defining key
@c sequences using these imaginary prefix keys.

Например, если вызывать @code{read-key-sequence} и потом щелкнуть
мышкой на строки режима окна, будут получены два события:

@c For example, if you call @code{read-key-sequence} and then click the
@c mouse on the window's mode line, you get two events, like this:

@example
(read-key-sequence "Click on the mode line: ")
     @result{} [mode-line
         (mouse-1
          (#<window 6 on NEWS> mode-line
           (40 . 63) 5959987))]
@end example

@defvar num-input-keys
Значение переменной хранит колическтво ключевых последовательностей
обработанных в текущей сессии Emacs. В это число входят последовательности
считанные с терминала и считанные при выполнении клавиатурных макросов.

@c This variable's value is the number of key sequences processed so far in
@c this Emacs session.  This includes key sequences read from the terminal
@c and key sequences read from keyboard macros being executed.
@end defvar

@node Reading One Event
@subsection Считывание Одного События
@c @subsection Reading One Event
@cindex reading a single event
@cindex event, reading only one

  Самая низкоуровневая функция для считывания команд @code{read-event},
@code{read-char}, и @code{read-char-exclusive}.

@c   The lowest level functions for command input are @code{read-event},
@c @code{read-char}, and @code{read-char-exclusive}.

@defun read-event &optional prompt inherit-input-method seconds
Функция считывает и возвращает следующее событие из ввода, если
нужно ожидая пока событие появится.

@c This function reads and returns the next event of command input,
@c waiting if necessary until an event is available.

Возвращаемое событие может прийти напрямую от пользователя, или
от клавиатурного макроса. Событие не декодируется системой
кодировки клавиатуры (@pxref{Terminal I/O Encoding}).

@c The returned event may come directly from the user, or from a keyboard
@c macro.  It is not decoded by the keyboard's input coding system
@c (@pxref{Terminal I/O Encoding}).

Если не обязательный аргумент @var{prompt} не-@code{nil}, он должен
быть строкой для отображения в эхо области. Иначе, @code{read-event}
не отображает никакого сообщения указывающего на ожидание ввода;
вместо этого, команда выводит в эхо область описание события которое
привело к (led to) или было считано текущей командой. @xref{The Echo Area}.

@c If the optional argument @var{prompt} is non-@code{nil}, it should be a
@c string to display in the echo area as a prompt.  Otherwise,
@c @code{read-event} does not display any message to indicate it is waiting
@c for input; instead, it prompts by echoing: it displays descriptions of
@c the events that led to or were read by the current command.  @xref{The
@c Echo Area}.

Если @var{inherit-input-method} не-@code{nil}, тогда текущий метод ввода
(если есть) используется, для возможности ввода не-@acronym{ASCII} символ.
Иначе, считывание таких событий будет отключено.

@c If @var{inherit-input-method} is non-@code{nil}, then the current input
@c method (if any) is employed to make it possible to enter a
@c non-@acronym{ASCII} character.  Otherwise, input method handling is disabled
@c for reading this event.

Если @code{cursor-in-echo-area} не-@code{nil}, тогда @code{read-event}
временно перемещает корсор в эхо область, в конец любого отображаемого
здесь сообщения. Иначе @code{read-event} не перемещает курсор.

@c If @code{cursor-in-echo-area} is non-@code{nil}, then @code{read-event}
@c moves the cursor temporarily to the echo area, to the end of any message
@c displayed there.  Otherwise @code{read-event} does not move the cursor.

Если параметр @var{seconds} не-@code{nil}, то значение должно
быть числом, которое будет определять максимальное количество секунд
ожидания ввода. Некоторые системы поддерживают, только целое число
секунд, для таких систем, @var{seconds} будет округлено до меньшего целого.
Если @var{seconds} @code{nil}, @code{read-event} ожидает пока событие
не будет получено.

@c If @var{seconds} is non-@code{nil}, it should be a number specifying
@c the maximum time to wait for input, in seconds.  If no input arrives
@c within that time, @code{read-event} stops waiting and returns
@c @code{nil}.  A floating point @var{seconds} means to wait
@c for a fractional number of seconds.  Some systems support only a whole
@c number of seconds; on these systems, @var{seconds} is rounded down.
@c If @var{seconds} is @code{nil}, @code{read-event} waits as long as
@c necessary for input to arrive.

Если @var{seconds} @code{nil}, Emacs расматривает считается бездействующим
при ожидании ввода от пользователя. Таймеры ожидания---который создается
с помощью @code{run-with-idle-timer} (@pxref{Idle Timers})---могут работать
в этот период. Но, если @var{seconds} не-@code{nil}, состояние бездействия(idle) не меняется.
Если Emacs не-бездействует когда @code{read-event} вызывается, его состояние
остается работающим на время выполнения @code{read-event}; если Emacs
бездействует при вызове @code{read-event} (например если вызов происходит
внутри таймера бездействия), он остается бездействующим (idle).

@c If @var{seconds} is @code{nil}, Emacs is considered idle while waiting
@c for user input to arrive.  Idle timers---those created with
@c @code{run-with-idle-timer} (@pxref{Idle Timers})---can run during this
@c period.  However, if @var{seconds} is non-@code{nil}, the state of
@c idleness remains unchanged.  If Emacs is non-idle when
@c @code{read-event} is called, it remains non-idle throughout the
@c operation of @code{read-event}; if Emacs is idle (which can happen if
@c the call happens inside an idle timer), it remains idle.

Если @code{read-event} получает событие которое определно как символ
помощи, тогда в некоторых случаях @code{read-event} обрабатывает
событие самостоятельно без возврата. @xref{Help Functions}. Некоторые
другие события, называемые @dfn{специальными событиями} (@dfn{special events}),
так же обрабатываются в @code{read-event} (@pxref{Special Events}).

@c If @code{read-event} gets an event that is defined as a help character,
@c then in some cases @code{read-event} processes the event directly without
@c returning.  @xref{Help Functions}.  Certain other events, called
@c @dfn{special events}, are also processed directly within
@c @code{read-event} (@pxref{Special Events}).

Ниже пример того, что будет если вызывать @code{read-event} и затем
нажать стрелочку вправо:

@c Here is what happens if you call @code{read-event} and then press the
@c right-arrow function key:

@example
@group
(read-event)
     @result{} right
@end group
@end example
@end defun

@defun read-char &optional prompt inherit-input-method seconds
Функция считывает и возвращает символ(знак) с ввода комманд. Если
пользователь генерирует событие, которое не символ(знак) (например щелчок
мыши или событие функциональной клавиши), @code{read-char}  синализирует
об ошибке. Аргументы работают как в @code{read-event}.

@c This function reads and returns a character of command input.  If the
@c user generates an event which is not a character (i.e., a mouse click or
@c function key event), @code{read-char} signals an error.  The arguments
@c work as in @code{read-event}.

В первом примере, пользователь вводит смивол @kbd{1} (@acronym{ASCII} код 49).
Во втором примере показано определение клавиатурного макроса, которое
вызывает @code{read-char} из минибуфера, используя @code{eval-expression}.
@code{read-char} считывает символ после макроса, который @kbd{1}.
Тогда @code{eval-expression} отобразить возвращаемое значение в
эхо области.

@c In the first example, the user types the character @kbd{1} (@acronym{ASCII}
@c code 49).  The second example shows a keyboard macro definition that
@c calls @code{read-char} from the minibuffer using @code{eval-expression}.
@c @code{read-char} reads the keyboard macro's very next character, which
@c is @kbd{1}.  Then @code{eval-expression} displays its return value in
@c the echo area.

@example
@group
(read-char)
     @result{} 49
@end group

@group
;; @r{Предолагается, что @kbd{M-:} вызыват eval-expression.}
;; @r{We assume here you use @kbd{M-:} to evaluate this.}
(symbol-function 'foo)
     @result{} "^[:(read-char)^M1"
@end group
@group
(execute-kbd-macro 'foo)
     @print{} 49
     @result{} nil
@end group
@end example
@end defun

@defun read-char-exclusive &optional prompt inherit-input-method seconds
Функция считывает и возвращает символ(знак) с потока ввода комманд.
Если пользователь генерирует событие, которое не символ
@code{read-char-exclusive} игнорирует его, и считывает другое
событие, пока не будет получен символ. Аргументы работают как в @code{read-event}.

@c This function reads and returns a character of command input.  If the
@c user generates an event which is not a character,
@c @code{read-char-exclusive} ignores it and reads another event, until it
@c gets a character.  The arguments work as in @code{read-event}.
@end defun

  Ни одна из вышеприведенных функцией не подавляет выход (@kbd{C-g}).
  @c None of the above functions suppress quitting.

@defvar num-nonmacro-input-events
Переменная хранит количество событий полученных от терминала---не учитывая события
сгенерированные клавиатурными макросами.

@c This variable holds the total number of input events received so far
@c from the terminal---not counting those generated by keyboard macros.
@end defvar

  Стоит подчеркнуть, что в отличие от @code{read-key-sequence},
функции @code{read-event}, @code{read-char}, и @code{read-char-exclusive}
не выполняют преобразование описанное в @ref{Translation Keymaps}.
Если нужно считать одну клавишу(событие) с выполнением преобразования,
нужно использовать функцию @code{read-key}.

@c   We emphasize that, unlike @code{read-key-sequence}, the functions
@c @code{read-event}, @code{read-char}, and @code{read-char-exclusive} do
@c not perform the translations described in @ref{Translation Keymaps}.
@c If you wish to read a single key taking these translations into
@c account, use the function @code{read-key}:

@defun read-key &optional prompt
Функция считывает одну клавишу(событие). Функция, является
средним между @code{read-key-sequence} и @code{read-event}.
От перевой она отличается тем, что считывает одно событий, а не последовательность.
А от второй, тем что не возвращает чистое событие (raw event), а
выполняет декодирование и преобазование в соответствии
с @code{input-decode-map}, @code{local-function-key-map}, и
@code{key-translation-map} (@pxref{Translation Keymaps}).

@c This function reads a single key.  It is intermediate between
@c @code{read-key-sequence} and @code{read-event}.  Unlike the former, it
@c reads a single key, not a key sequence.  Unlike the latter, it does
@c not return a raw event, but decodes and translates the user input
@c according to @code{input-decode-map}, @code{local-function-key-map},
@c and @code{key-translation-map} (@pxref{Translation Keymaps}).

Аргумент @var{prompt} задает строку запроса, отображаемую в эхо области
или @code{nil}, если запрос не нужен.

@c The argument @var{prompt} is either a string to be displayed in the
@c echo area as a prompt, or @code{nil}, meaning not to display a prompt.
@end defun

@defun read-char-choice prompt chars &optional inhibit-quit
Функция использует @code{read-key}, чтобы считать и вернут один
символ(знак). Фунция игнорирует любой ввод, который не
является членом @var{chars}, списка допустимых символов.
Так же функция может игнорировать команду выхода (@kbd{C-g}),
пока ожидается корректный ввод. Если @code{help-form} (@pxref{Help Functions})
не-@code{nil}, во время @code{read-char-choice}, тогда нажатие
@code{help-char} приведет к вычислению @code{help-form} и отображению
результата. После чего, функция продолжит ожидать ввода корректного
символа(знака), или комбинации выхода (@kbd{C-g} keyboard-quit).

@c This function uses @code{read-key} to read and return a single
@c character.  It ignores any input that is not a member of @var{chars},
@c a list of accepted characters.  Optionally, it will also ignore
@c keyboard-quit events while it is waiting for valid input.  If you bind
@c @code{help-form} (@pxref{Help Functions}) to a non-@code{nil} value
@c while calling @code{read-char-choice}, then pressing @code{help-char}
@c causes it to evaluate @code{help-form} and display the result.  It
@c then continues to wait for a valid input character, or keyboard-quit.
@end defun

@node Event Mod
@subsection Модификация и Преобразование Событий Ввода
@c @subsection Modifying and Translating Input Events
@cindex modifiers of events
@cindex translating input events
@cindex event translation

  Emacs изменяет каждое считываемое событие в соответствии
с @code{extra-keyboard-modifiers}, после чего преобразовывает
его в соотсветствии с @code{keyboard-translate-table} (если применимо),
перед тем как вернуть из @code{read-event}.

@c   Emacs modifies every event it reads according to
@c @code{extra-keyboard-modifiers}, then translates it through
@c @code{keyboard-translate-table} (if applicable), before returning it
@c from @code{read-event}.

@defvar extra-keyboard-modifiers
Переменная позволяет Lisp программам ``press'' (``нажимать'')
кнопки модификаторы на клавиатуре. Значение символ(знак).
Имеют значения только модификаторы символов. Каждый раз когда
пользователь нажимает кнопку клавиатуры, выполняется изменение
как буд-то указаные модификаторы были нажаты. Например, если
задать значение @code{extra-keyboard-modifiers} в @code{?\C-\M-a},
тогда все вводимые символы будут иметь модификаторы control и meta,
в области действия значения @code{extra-keyboard-modifiers}.
(прим. например внутри let.) Символ @code{?\C-@@}, эквивалентен
целому 0, не рассматривается как control модификатор, а считается
символом без модификаторов. Таким образом, установка @code{extra-keyboard-modifiers}
отключает применение дополнительных модификаторов.

@c This variable lets Lisp programs ``press'' the modifier keys on the
@c keyboard.  The value is a character.  Only the modifiers of the
@c character matter.  Each time the user types a keyboard key, it is
@c altered as if those modifier keys were held down.  For instance, if
@c you bind @code{extra-keyboard-modifiers} to @code{?\C-\M-a}, then all
@c keyboard input characters typed during the scope of the binding will
@c have the control and meta modifiers applied to them.  The character
@c @code{?\C-@@}, equivalent to the integer 0, does not count as a control
@c character for this purpose, but as a character with no modifiers.
@c Thus, setting @code{extra-keyboard-modifiers} to zero cancels any
@c modification.

Когда использует оконная система, программа может нажать
любые модификаторы таким образом. Иначе, только @key{CTL} и
@key{META} символы могут быть нажаты виртуально.

@c When using a window system, the program can press any of the
@c modifier keys in this way.  Otherwise, only the @key{CTL} and @key{META}
@c keys can be virtually pressed.

Стоит отметить, что переменная влияет только на события, которые
действительно приходят от клавиатуры, и не влияет на события мыши
и другие события.

@c Note that this variable applies only to events that really come from
@c the keyboard, and has no effect on mouse events or any other events.
@end defvar

@defvar keyboard-translate-table
Локальная для терминала переменная, представляет из себя таблицу
преобразования клавиатурных символов. Данная возможно позволяет
переставлять клавиши на клавиатуре, без необходимости менять
привязки. Как правило значением является char-table (таблица-символов(знаков)),
или @code{nil}. (Вообще говоря значение может быть строкой или
вектором, но это считается устаревшим.)

@c This terminal-local variable is the translate table for keyboard
@c characters.  It lets you reshuffle the keys on the keyboard without
@c changing any command bindings.  Its value is normally a char-table, or
@c else @code{nil}.  (It can also be a string or vector, but this is
@c considered obsolete.)

Если @code{keyboard-translate-table} символьная таблица(char-table),
каждый символ считываемый с клавиатуры проверяется на наличие в таблице.
Если значение найдено и не-@code{nil}, тогда оно используется вместо
введенного символа.

@c If @code{keyboard-translate-table} is a char-table
@c (@pxref{Char-Tables}), then each character read from the keyboard is
@c looked up in this char-table.  If the value found there is
@c non-@code{nil}, then it is used instead of the actual input character.

Данная трансляция это первое, что случается с символом после ввода.
Функции записи такие как @code{recent-keys} и dribble files (прим. ?)
записывают символы после преобразования.

@c Note that this translation is the first thing that happens to a
@c character after it is read from the terminal.  Record-keeping features
@c such as @code{recent-keys} and dribble files record the characters after
@c translation.

Трансляция делается до того как символы поступят в методы
ввода (@pxref{Input Methods}). Если нужно
сделать преобразование после работы методов ввода, стоит
использовать @code{translation-table-for-input} (@pxref{Translation of Characters}).

@c Note also that this translation is done before the characters are
@c supplied to input methods (@pxref{Input Methods}).  Use
@c @code{translation-table-for-input} (@pxref{Translation of Characters}),
@c if you want to translate characters after input methods operate.
@end defvar

@defun keyboard-translate from to
Функция изменяет @code{keyboard-translate-table} так, что символы
@code{from} будут преобразовываться в символы @var{to}. Если нужно
функция создает таблицу преобразования.

@c This function modifies @code{keyboard-translate-table} to translate
@c character code @var{from} into character code @var{to}.  It creates
@c the keyboard translate table if necessary.
@end defun

  Ниже пример использования @code{keyboard-translate-table}, чтобы
@kbd{C-x}, @kbd{C-c} и @kbd{C-v} выполняли действия вырезат, копировать
вставить:

@c   Here's an example of using the @code{keyboard-translate-table} to
@c make @kbd{C-x}, @kbd{C-c} and @kbd{C-v} perform the cut, copy and paste
@c operations:

@example
(keyboard-translate ?\C-x 'control-x)
(keyboard-translate ?\C-c 'control-c)
(keyboard-translate ?\C-v 'control-v)
(global-set-key [control-x] 'kill-region)
(global-set-key [control-c] 'kill-ring-save)
(global-set-key [control-v] 'yank)
@end example

@noindent
В графическом терминале, который поддерживает расширенный @acronym{ASCII}
ввод, модно получить стандартные значения одного из этих символов
путем ввода его с зажатой shift клавишей. Тогда будет получен другой символ
если имеет место преобразование(keyboard translation), но как правило
у этого символа будет тот же смысл.

@c On a graphical terminal that supports extended @acronym{ASCII} input,
@c you can still get the standard Emacs meanings of one of those
@c characters by typing it with the shift key.  That makes it a different
@c character as far as keyboard translation is concerned, but it has the
@c same usual meaning.

  Механизм преобразования последовательностей событий
на уровне @code{read-key-sequence} описан в @ref{Translation Keymaps}.

@c   @xref{Translation Keymaps}, for mechanisms that translate event sequences
@c at the level of @code{read-key-sequence}.

@node Invoking the Input Method
@subsection Возов Метода Ввода
@c @subsection Invoking the Input Method
@cindex invoking input method

  Функции чтения событий вызывают текущий метод ввода, если он есть
(@pxref{Input Methods}). Если значение @code{input-method-function}
не-@code{nil}, то это должна быть функция, которая будет вызываться
при чтении @code{read-event} печатного символа без
битов модификаторов (включая @key{SPC}). Считанный символ передается
в качестве аргумента.

@c   The event-reading functions invoke the current input method, if any
@c (@pxref{Input Methods}).  If the value of @code{input-method-function}
@c is non-@code{nil}, it should be a function; when @code{read-event} reads
@c a printing character (including @key{SPC}) with no modifier bits, it
@c calls that function, passing the character as an argument.

@defvar input-method-function
Если значение не-@code{nil}, оно определяет текущий метод ввода. Значение
должно быть функцией.

@c If this is non-@code{nil}, its value specifies the current input method
@c function.
@strong{Внимание:} нельзя задавать значение данной переменной внутри @code{let}.
Переменная часто локальная для буфера, поэтому если задать значение
для части ввода, асинхронное переключение буферов, пока Emacs выполняет
ожидание, приведет к тому, что значение будет восстановлено в
неправильном буфере.

@c @strong{Warning:} don't bind this variable with @code{let}.  It is often
@c buffer-local, and if you bind it around reading input (which is exactly
@c when you @emph{would} bind it), switching buffers asynchronously while
@c Emacs is waiting will cause the value to be restored in the wrong
@c buffer.
@end defvar

  Функция метода ввода должнао возвращать список событий, которые должны
использоваться в качестве ввода. (Если список @code{nil}, это значит ввода
нет и @code{read-event} будет ждать другого события.) Данные события обрабатываются
до @code{unread-command-events} (@pxref{Event Input Misc}). События возвращенные
функцией метода ввода не передаются повторно в функцию метода ввода,
даже если это печетные символы без битов модификаторов.

@c   The input method function should return a list of events which should
@c be used as input.  (If the list is @code{nil}, that means there is no
@c input, so @code{read-event} waits for another event.)  These events are
@c processed before the events in @code{unread-command-events}
@c (@pxref{Event Input Misc}).  Events
@c returned by the input method function are not passed to the input method
@c function again, even if they are printing characters with no modifier
@c bits.

  Если функция метода ввоаа вызывает @code{read-event} или
@code{read-key-sequence}, она должна сначала задать значение @code{input-method-function}
равной @code{nil}, чтобы избежать рекурсии.

@c   If the input method function calls @code{read-event} or
@c @code{read-key-sequence}, it should bind @code{input-method-function} to
@c @code{nil} first, to prevent recursion.

  Функция метода ввода не вызывается когда считываетс второе и последующие
события ключевой последовательности. Таким образом, эти символя не являются
объектами обарабатываемыми методом ввода. Функция метода ввода
должна проверять значения @code{overriding-local-map} и @code{overriding-terminal-local-map},
и если хотя бы одно из этих знаений не-@code{nil}, она должна поменщать свой
аргумент в список и возвращать его без дальнейшей обработки.

@c   The input method function is not called when reading the second and
@c subsequent events of a key sequence.  Thus, these characters are not
@c subject to input method processing.  The input method function should
@c test the values of @code{overriding-local-map} and
@c @code{overriding-terminal-local-map}; if either of these variables is
@c non-@code{nil}, the input method should put its argument into a list and
@c return that list with no further processing.

@node Quoted Character Input
@subsection Ввод Символов В Кавычках
@c @subsection Quoted Character Input
@cindex quoted character input

  Можно использовать функцию @code{read-quoted-char}, чтобы запросить
у пользователя ввести символ(знак), и ползволить пользователю удобно задать
control или meta символ, буквально или в виде восмеричного кода символа.
Команда @code{quoted-insert} использует эту функцию.

@c   You can use the function @code{read-quoted-char} to ask the user to
@c specify a character, and allow the user to specify a control or meta
@c character conveniently, either literally or as an octal character code.
@c The command @code{quoted-insert} uses this function.

 @defun read-quoted-char &optional prompt
@cindex octal character input
@cindex control characters, reading
@cindex nonprinting characters, reading
Функция аналогична @code{read-char}, но если первый символ является
восьмеричной цифрой (0--7), функция считывает символы пока они
являются восьмиричными цифрами, и возврщает символ представленный
введенным кодом. Если символ завершающий последовательность
восьмиричных цифр @key{RET}, он удаляется. Любые другие символы
являющиеся не восьмиричными цифрами, используются в качестве ввода
для кода выполняющегося после возврата из функции @code{read-quoted-char}.

@c This function is like @code{read-char}, except that if the first
@c character read is an octal digit (0--7), it reads any number of octal
@c digits (but stopping if a non-octal digit is found), and returns the
@c character represented by that numeric character code.  If the
@c character that terminates the sequence of octal digits is @key{RET},
@c it is discarded.  Any other terminating character is used as input
@c after this function returns.

Выход подавляется, когда считывается первый символ, поэтому пользователь
может ввести @kbd{C-g}. @xref{Quitting}.

@c Quitting is suppressed when the first character is read, so that the
@c user can enter a @kbd{C-g}.  @xref{Quitting}.

Если задан @var{prompt}, то он используется в качестве запроса для пользователя.
prompt должно быть строкой, которая будет отображена в эхо области.
к @var{prompt} добавляется знак @samp{-}.

@c If @var{prompt} is supplied, it specifies a string for prompting the
@c user.  The prompt string is always displayed in the echo area, followed
@c by a single @samp{-}.

В следующем примере, пользователь вводит восьмиричное число 177 (
которое соответствует 127 в десятичной).

@c In the following example, the user types in the octal number 177 (which
@c is 127 in decimal).

@example
(read-quoted-char "What character")

@group
---------- Echo Area ----------
What character @kbd{1 7 7}-
---------- Echo Area ----------

     @result{} 127
@end group
@end example
@end defun

@need 2000
@node Event Input Misc
@subsection Разные Функции Ввода событий
@c @subsection Miscellaneous Event Input Features

В данном разделел описывается как просмотреть события без их
использования, как выполнить проверку на ожидание ввода, и как
удалить отложенный ввода. Так же стоит посмотреть на
функцию @code{read-passwd} (@pxref{Reading a Password}).

@c This section describes how to peek ahead at events without using
@c them up, how to check for pending input, and how to discard pending
@c input.  See also the function @code{read-passwd} (@pxref{Reading a
@c Password}).

@defvar unread-command-events
@cindex next input
@cindex peeking at input
Переменная хранит список событий ожидающих считывания, как ввод для
комманд. События используются в порядке очереди (как в списке), и
удаляются после использования.

@c This variable holds a list of events waiting to be read as command
@c input.  The events are used in the order they appear in the list, and
@c removed one by one as they are used.

Переменная нужна, например, для случаев, когда функция считывает событие,
но потом решает не использовать его. Хранение события в данной переменной
позволяет ему быть нормально обработанным в командным циклом или
функция считывающими ввод команд.

@c The variable is needed because in some cases a function reads an event
@c and then decides not to use it.  Storing the event in this variable
@c causes it to be processed normally, by the command loop or by the
@c functions to read command input.

@cindex prefix argument unreading
Например, функция которая задействует числовой аргумент префикс, считывает
любое количество цифр. Когда встречается не-цифровое событие, оно должно
быть возвращено (unread), чтобы впоследствии быть обработанным обычным образов
командным циклом. Таким же образом, последовательный поиск (incremental search)
использует данную возможность, чтобы вернуть событяи которые не имеют
смысла при поиске, так как они должны приводить к выходу из поиска,
и потом быть обработанны обычнм образом.

@c For example, the function that implements numeric prefix arguments reads
@c any number of digits.  When it finds a non-digit event, it must unread
@c the event so that it can be read normally by the command loop.
@c Likewise, incremental search uses this feature to unread events with no
@c special meaning in a search, because these events should exit the search
@c and then execute normally.

Надежный и простой способ извлечь события из ключевой последовательности,
чтобы поставить их в @code{unread-command-events}, использовать
@code{listify-key-sequence} (см. ниже).

@c The reliable and easy way to extract events from a key sequence so as
@c to put them in @code{unread-command-events} is to use
@c @code{listify-key-sequence} (see below).

Обычно события добавляюттся в начало списка, поэтому события которые
были возвращены последними, будут считаны первыми.

@c Normally you add events to the front of this list, so that the events
@c most recently unread will be reread first.

События считываются из этого списка добавляются в текующую
ключевую последовательность комманды не обычным способом
(как, например, возвращаемые @code{this-command-keys}),
поскольку события уже были один раз добавлены, во время первого считывания.
Элемент в форме @w{@code{(t . @var{event})}} усиливающий @var{event}
добавляется в текущую ключевую последовательность.

@c Events read from this list are not normally added to the current
@c command's key sequence (as returned by, e.g., @code{this-command-keys}),
@c as the events will already have been added once as they were read for
@c the first time.  An element of the form @w{@code{(t . @var{event})}}
@c forces @var{event} to be added to the current command's key sequence.
@end defvar

@defun listify-key-sequence key
Функция преобразует строку или вектор @var{key} в список
отдельных событий, которые можно поместить в @code{unread-command-events}.

@c This function converts the string or vector @var{key} to a list of
@c individual events, which you can put in @code{unread-command-events}.
@end defun

@defun input-pending-p &optional check-timers
@cindex waiting for command key input
Функция определяет есть ли доступный ввод, который может быть считан.
Функция сразу возвращает результат (прим. без ожидания)
@code{t} если есть доступный ввод, @code{nil} если нет. В редких
случаях, может быть возвращено @code{t}, если доступного ввода нет.

@c This function determines whether any command input is currently
@c available to be read.  It returns immediately, with value @code{t} if
@c there is available input, @code{nil} otherwise.  On rare occasions it
@c may return @code{t} when no input is available.

Если не обязательный аргумент @var{check-timers} не-@code{nil}, тогда,
если нет доступного ввода, Emacs запустит таймеры если они готовы.
@xref{Timers}.

@c If the optional argument @var{check-timers} is non-@code{nil}, then if
@c no input is available, Emacs runs any timers which are ready.
@c @xref{Timers}.
@end defun

@defvar last-input-event
Переменная записывает последнее считанное с терминала событие,
как часть команды или явно Lisp программой. 

@c This variable records the last terminal input event read, whether
@c as part of a command or explicitly by a Lisp program.

В примере ниже, Lisp програма считывает символ @kbd{1}, @acronym{ASCII} код 49.
Значение записывается в @code{last-input-event}, пока @kbd{C-e} (предполагается,
что используется команда @kbd{C-x C-e} для вычисления выражения)
остается значением @code{last-command-event}.

@c In the example below, the Lisp program reads the character @kbd{1},
@c @acronym{ASCII} code 49.  It becomes the value of @code{last-input-event},
@c while @kbd{C-e} (we assume @kbd{C-x C-e} command is used to evaluate
@c this expression) remains the value of @code{last-command-event}.

@example
@group
(progn (print (read-char))
       (print last-command-event)
       last-input-event)
     @print{} 49
     @print{} 5
     @result{} 49
@end group
@end example
@end defvar

@defmac while-no-input body@dots{}
Конструкция запускает форму @var{body} и возвращает ее значение, но
только если не поступит никакого ввода. Если во время выполнения
будет получен любой ввод, выполнение @var{body} будет прервано
(прерывание работает аналогично выходу (quit)). Форма @code{while-no-input}
возвращает @code{nil}, если прерывается по действительному выходу (quit),
и @code{t} если прерывается при поступлении другого ввода.

@c This construct runs the @var{body} forms and returns the value of the
@c last one---but only if no input arrives.  If any input arrives during
@c the execution of the @var{body} forms, it aborts them (working much
@c like a quit).  The @code{while-no-input} form returns @code{nil} if
@c aborted by a real quit, and returns @code{t} if aborted by arrival of
@c other input.

Если в часть @var{body} есть связывание @code{inhibit-quit} с
не-@code{nil}, получаемый ввод не будет прерывать выполнение
@var{body}, пока действует привязка (например, значение внутри let).

@c If a part of @var{body} binds @code{inhibit-quit} to non-@code{nil},
@c arrival of input during those parts won't cause an abort until
@c the end of that part.

Если нужно отличать значения вычисленные в @var{body}, от других
выидов завершения, можно написать код вроде следующего:

@c If you want to be able to distinguish all possible values computed
@c by @var{body} from both kinds of abort conditions, write the code
@c like this:

@example
(while-no-input
  (list
    (progn . @var{body})))
@end example
@end defmac

@defun discard-input
@cindex flushing input
@cindex discarding input
@cindex keyboard macro, terminating
Функция удаляет содержимое буфера ввода с терминала и завершает все
клавиатурные макросы, которые могут быть в процессе определения.
Функция возвращает @code{nil}.

@c This function discards the contents of the terminal input buffer and
@c cancels any keyboard macro that might be in the process of definition.
@c It returns @code{nil}.

В следующем примере, пользователь может ввести несколько символов
после начала вычисления формы. После окончания ожидания @code{sleep-for},
@code{discard-input} удалит все символы введеные во время ожидания.

@c In the following example, the user may type a number of characters right
@c after starting the evaluation of the form.  After the @code{sleep-for}
@c finishes sleeping, @code{discard-input} discards any characters typed
@c during the sleep.

@example
(progn (sleep-for 2)
       (discard-input))
     @result{} nil
@end example
@end defun

@node Special Events
@section Специальные События
@c @section Special Events

@cindex special events
Некоторые @dfn{специальные события}(@dfn{special events}) обрабатываются
на очень низком уровне---сразу как только считываются. Функция @code{read-event}
сама обрабатывает такие события, и никогда их не возвращает. Напротив,
она ожидает любого события, которое не являетс специальным и возвращает его.

@c Certain @dfn{special events} are handled at a very low level---as soon
@c as they are read.  The @code{read-event} function processes these
@c events itself, and never returns them.  Instead, it keeps waiting for
@c the first event that is not special and returns that one.

  Специальные события не отображаются и не группируются в ключевые
последовательности, и они никогда не появляются в значениях
@code{last-command-event} или @code{(this-command-keys)}. Они не удаляют
числовой аргумент, и не могут быть возвращены с помощью
@code{unread-command-events}, они не могут появляться в клавиатурных макросах,
и не записываются в клавиатурные макросы при определении.

@c   Special events do not echo, they are never grouped into key
@c sequences, and they never appear in the value of
@c @code{last-command-event} or @code{(this-command-keys)}.  They do not
@c discard a numeric argument, they cannot be unread with
@c @code{unread-command-events}, they may not appear in a keyboard macro,
@c and they are not recorded in a keyboard macro while you are defining
@c one.

  Специальные события, однако, появляются в @code{last-input-event}
сразу после чтения, и это способ чтобы найти фактическое событие.

@c   Special events do, however, appear in @code{last-input-event}
@c immediately after they are read, and this is the way for the event's
@c definition to find the actual event.

  К специальным событиям как правило относятся: @code{iconify-frame},
@code{make-frame-visible}, @code{delete-frame}, @code{drag-n-drop}, @code{language-change},
и пользовательские сигналы ткаие как @code{sigusr1}. @code{special-event-map} расладка,
определяющая обаботку специальных событий---и того какие события считать специалными.
(@pxref{Active Keymaps}).

@c   The events types @code{iconify-frame}, @code{make-frame-visible},
@c @code{delete-frame}, @code{drag-n-drop}, @code{language-change}, and
@c user signals like @code{sigusr1} are normally handled in this way.
@c The keymap which defines how to handle special events---and which
@c events are special---is in the variable @code{special-event-map}
@c (@pxref{Active Keymaps}).

@node Waiting
@section Ожидание Определенного Времени или Ввода
@c @section Waiting for Elapsed Time or Input
@cindex waiting

  Функции ожидания предназначенные для ожидания определенного времени
или пока не будет получен ввода. Например, можно сделать паузу во время
вычисления, чтобы позволить пользователю посмотреть отображаемые результаты.
Функция @code{sit-for} делает паузу и обновляет экран, и завершается сразу,
как только будет получен ввод, в то время @code{sleep-for} делает паузе
без обновления экрана.

@c   The wait functions are designed to wait for a certain amount of time
@c to pass or until there is input.  For example, you may wish to pause in
@c the middle of a computation to allow the user time to view the display.
@c @code{sit-for} pauses and updates the screen, and returns immediately if
@c input comes in, while @code{sleep-for} pauses without updating the
@c screen.

@defun sit-for seconds &optional nodisp
Функция выполняет обновление данных на дисплее (redisplay) (при условии,
что нет ввода ожидающего обработки), после чего ожидает @var{seconds} секунд,
или пока не будет получен ввод. Обычное применение @code{sit-for},
дать пользовтелю время ознакомиться с отображаемым текстом. Значение @code{t}
если @code{sit-for} ожидала все заданное время, и ввода не было
(@pxref{Event Input Misc}). Иначе, возвращается @code{nil}.

@c This function performs redisplay (provided there is no pending input
@c from the user), then waits @var{seconds} seconds, or until input is
@c available.  The usual purpose of @code{sit-for} is to give the user
@c time to read text that you display.  The value is @code{t} if
@c @code{sit-for} waited the full time with no input arriving
@c (@pxref{Event Input Misc}).  Otherwise, the value is @code{nil}.

Аргумент @var{seconds} не обязан быть целым числом. Если значением является
число с плавающей точко, @code{sit-for} ожидает не целое число секунд.
Если система поддерживают только целое число секунд, @var{seconds} округляется
до меньшего целого.

@c The argument @var{seconds} need not be an integer.  If it is floating
@c point, @code{sit-for} waits for a fractional number of seconds.
@c Some systems support only a whole number of seconds; on these systems,
@c @var{seconds} is rounded down.

Выражание @code{(sit-for 0)} эквивалентно @code{(redisplay)},
то есть, просто выполняется обновление информации, без ожидания.
@xref{Forcing Redisplay}.

@c The expression @code{(sit-for 0)} is equivalent to @code{(redisplay)},
@c i.e., it requests a redisplay, without any delay, if there is no pending input.
@c @xref{Forcing Redisplay}.

Если @var{nodisp} не-@code{nil}, @code{sit-for} не выполняет
обновление данных на дисплее (redisplay), но выполняет ожидание.

@c If @var{nodisp} is non-@code{nil}, then @code{sit-for} does not
@c redisplay, but it still returns as soon as input is available (or when
@c the timeout elapses).

В пакетном режиме (@pxref{Batch Mode}), @code{sit-for},
не может быть прервано вводом, даже по вводу со стандартного потока ввода.
В этом случае функция эквивалентна @code{sleep-for}, описанной ниже.

@c In batch mode (@pxref{Batch Mode}), @code{sit-for} cannot be
@c interrupted, even by input from the standard input descriptor.  It is
@c thus equivalent to @code{sleep-for}, which is described below.

Возможен вызов @code{sit-for} с тремя аргументами,
@code{(sit-for @var{seconds} @code{milisec} @var{nodisk})},
но такое использование считается устаревшим.

@c It is also possible to call @code{sit-for} with three arguments,
@c as @code{(sit-for @var{seconds} @var{millisec} @var{nodisp})},
@c but that is considered obsolete.
@end defun

@defun sleep-for seconds &optional millisec
Функция просто делает паузу на @var{seconds} без обновления экрана.
Функция не обращает внимание на ввода и возвращает @code{nil}.

@c This function simply pauses for @var{seconds} seconds without updating
@c the display.  It pays no attention to available input.  It returns
@c @code{nil}.

Аргумент @var{seconds} не обязан быть целым числом. Если значением является
число с плавающей точко, @code{sit-for} ожидает не целое число секунд.
Если система поддерживают только целое число секунд, @var{seconds} округляется
до меньшего целого.

@c The argument @var{seconds} need not be an integer.  If it is floating
@c point, @code{sleep-for} waits for a fractional number of seconds.
@c Some systems support only a whole number of seconds; on these systems,
@c @var{seconds} is rounded down.

Необязательный аргумент @var{milisec} задает дополнительное ожидание в
милисекундах. Если система не поддерживает ождание не целого числа секунд
будет ожибка если задать не нулевое значение для @var{milisec}.

@c The optional argument @var{millisec} specifies an additional waiting
@c period measured in milliseconds.  This adds to the period specified by
@c @var{seconds}.  If the system doesn't support waiting fractions of a
@c second, you get an error if you specify nonzero @var{millisec}.

@code{sleep-for} стоит использовать, когда нужна гарантированная задержка.
@c Use @code{sleep-for} when you wish to guarantee a delay.
@end defun

  Функции получения текущего времени можно найти в @ref{Time of Day}.
  @c @xref{Time of Day}, for functions to get the current time.

@node Quitting
@section Выход (Quiting)
@c @section Quitting
@cindex @kbd{C-g}
@cindex quitting
@cindex interrupt Lisp functions

  Ввод @kbd{C-g} во время выполнения Lisp функции указывает Emacs
выполнить @dfn{выход} (@dfn{quit}) и текущего действия. Это значит,
вернуть управление во внутренний активный командный цикл.

@c   Typing @kbd{C-g} while a Lisp function is running causes Emacs to
@c @dfn{quit} whatever it is doing.  This means that control returns to the
@c innermost active command loop.

  Ввод @kbd{C-g}, когда командый цикл ожидает ввода не вызывает выход;
а обрабатывается как обычный символ. В простейшем случаев, отличия
не видны, так как @kbd{C-g} вызывает команду @code{keyboard-quit}, действие
которой выход. Но, когда @kbd{C-g} следуюет за префиксом, получается
неопределенная комбинация. Эффект будет заключатсья в отмене префикса
как и любого префикс аргумента.

@c   Typing @kbd{C-g} while the command loop is waiting for keyboard input
@c does not cause a quit; it acts as an ordinary input character.  In the
@c simplest case, you cannot tell the difference, because @kbd{C-g}
@c normally runs the command @code{keyboard-quit}, whose effect is to quit.
@c However, when @kbd{C-g} follows a prefix key, they combine to form an
@c undefined key.  The effect is to cancel the prefix key as well as any
@c prefix argument.

  В мини-буфере, @kbd{C-g} имеет другое определение: выход из мини-буфера.
Это значит, что в результате будет выполнен выход из мини-буфера и затем
выход (прим. до командного цикла). (Простой выход будет возвращать
в командный цикл @emph{внутри} мини-буфера.) Причина по которой @kbd{C-g}
не просто выходит когда считыватель команд считывает ввод, заключается
в том, что действие може быть переопределено в мини-буфере. @kbd{C-g}, которая
следует за префиксом ключа не переопределяется в мини-буфере, и выполняет
отмену префика и префикс аргумента. Это было бы не возможно, если
бы по @kbd{C-g} сразы бы выполнялся выход.

@c   In the minibuffer, @kbd{C-g} has a different definition: it aborts out
@c of the minibuffer.  This means, in effect, that it exits the minibuffer
@c and then quits.  (Simply quitting would return to the command loop
@c @emph{within} the minibuffer.)  The reason why @kbd{C-g} does not quit
@c directly when the command reader is reading input is so that its meaning
@c can be redefined in the minibuffer in this way.  @kbd{C-g} following a
@c prefix key is not redefined in the minibuffer, and it has its normal
@c effect of canceling the prefix key and prefix argument.  This too
@c would not be possible if @kbd{C-g} always quit directly.

  Прямой выход по @kbd{C-g}, выполняется путем установки флага @code{quit-flag}
в @code{t}. Emacs проверяет данную переменную в подходящее время и выполняет
выход, если значение не @code{nil}. Таким образом установка @code{quit-flag}
в не-@code{nil}, приводит к выходу.

@c   When @kbd{C-g} does directly quit, it does so by setting the variable
@c @code{quit-flag} to @code{t}.  Emacs checks this variable at appropriate
@c times and quits if it is not @code{nil}.  Setting @code{quit-flag}
@c non-@code{nil} in any way thus causes a quit.

  На уровне C кода, выход не пожет выполниться в произвольном месте,
а только в специальных местах в которых проверяется @code{quit-flag}.
Так делается, потому что выход и произвольного места, может привести
к противоречивому состоянию Emacs. Но так как выход выполняется в безопасных
местах он не приводит к падению Emacs.

@c   At the level of C code, quitting cannot happen just anywhere; only at the
@c special places that check @code{quit-flag}.  The reason for this is
@c that quitting at other places might leave an inconsistency in Emacs's
@c internal state.  Because quitting is delayed until a safe place, quitting
@c cannot make Emacs crash.

  Некоторые функции такие как @code{read-key-sequence} или
@code{read-quote-char}, отключают выход во время ожидания
ввода. Вместо выхода, @kbd{C-g} воспринимается как запрошенный ввод.
В случае @code{read-key-sequence}, в результате имеем особое поведение
@kbd{C-g} в командном цикле. В случае @code{read-quoted-char}, можно
использовать @kbd{C-q}, чтобы ввести (to quote a) @kbd{C-g}.

@c   Certain functions such as @code{read-key-sequence} or
@c @code{read-quoted-char} prevent quitting entirely even though they wait
@c for input.  Instead of quitting, @kbd{C-g} serves as the requested
@c input.  In the case of @code{read-key-sequence}, this serves to bring
@c about the special behavior of @kbd{C-g} in the command loop.  In the
@c case of @code{read-quoted-char}, this is so that @kbd{C-q} can be used
@c to quote a @kbd{C-g}.

@cindex preventing quitting
  Можно заблокировать выход для участка Lisp функции путем задания
не-@code{nil} значения переменной @code{inhibit-quit}. Тогда, хотя
@kbd{C-g} все еще будет устанавливать @code{quit-flag} в @code{t} как
обычно, это не будет приводить к выходу. В конченом счете,
@code{inhibit-quit} снова станет @code{nil}, как правило когда
закончится соответствующий @code{let}. Выход будте сделан сразу,
если в это время @code{quit-flag} все еще будет не-@code{nil}.
Такое поведение идеально подходит, для ситуаций, когда нужно
быть уверенным, что не будет сделано выхода в критическом участке кода.

@c   You can prevent quitting for a portion of a Lisp function by binding
@c the variable @code{inhibit-quit} to a non-@code{nil} value.  Then,
@c although @kbd{C-g} still sets @code{quit-flag} to @code{t} as usual, the
@c usual result of this---a quit---is prevented.  Eventually,
@c @code{inhibit-quit} will become @code{nil} again, such as when its
@c binding is unwound at the end of a @code{let} form.  At that time, if
@c @code{quit-flag} is still non-@code{nil}, the requested quit happens
@c immediately.  This behavior is ideal when you wish to make sure that
@c quitting does not happen within a critical section of the program.

@cindex @code{read-quoted-char} quitting
  В некоторых функциях (таких как @code{read-quoted-char}), @kbd{C-g}
обрабатывается специальным образом, без выхода. Это делается путем
считывания ввод при значении @code{inhibit-quit} равном @code{t},
и установкой @code{quit-flag} в @code{nil}, перед тем как @code{inhibit-quit}
снова станет @code{nil}. Часть кода @code{read-quoted-char} показывает
как это делается, так же тут показывается, что обычный выход разрешается
после ввода первого символа.

@c   In some functions (such as @code{read-quoted-char}), @kbd{C-g} is
@c handled in a special way that does not involve quitting.  This is done
@c by reading the input with @code{inhibit-quit} bound to @code{t}, and
@c setting @code{quit-flag} to @code{nil} before @code{inhibit-quit}
@c becomes @code{nil} again.  This excerpt from the definition of
@c @code{read-quoted-char} shows how this is done; it also shows that
@c normal quitting is permitted after the first character of input.

@example
(defun read-quoted-char (&optional prompt)
  "@dots{}@var{documentation}@dots{}"
  (let ((message-log-max nil) done (first t) (code 0) char)
    (while (not done)
      (let ((inhibit-quit first)
            @dots{})
        (and prompt (message "%s-" prompt))
        (setq char (read-event))
        (if inhibit-quit (setq quit-flag nil)))
      @r{@dots{}set the variable @code{code}@dots{}})
    code))
@end example

@defvar quit-flag
Если значение переменной не-@code{nil}, тогда Emacs выполняет выход
сразу, если только @code{inhibit-quit} тоже не-@code{nil}. Нажатие
@kbd{C-g} как правило уставливает @code{quit-flag} в не-@code{nil},
в не зависимости от значения @code{inhibit-quit}.

@c If this variable is non-@code{nil}, then Emacs quits immediately, unless
@c @code{inhibit-quit} is non-@code{nil}.  Typing @kbd{C-g} ordinarily sets
@c @code{quit-flag} non-@code{nil}, regardless of @code{inhibit-quit}.
@end defvar

@defvar inhibit-quit
Переменная определяет должен ли Emacs выполнять выход, когда @code{quit-flag}
не-@code{nil}. Пока @code{inhibit-quit} не-@code{nil}, @code{quit-flag}
не приводит к выходу.

@c This variable determines whether Emacs should quit when @code{quit-flag}
@c is set to a value other than @code{nil}.  If @code{inhibit-quit} is
@c non-@code{nil}, then @code{quit-flag} has no special effect.
@end defvar

@defmac with-local-quit body@dots{}
Макрос выполняет форму @var{body}, но позволяет выполнять выход
наиболее локально, внутри @var{body}, даже если @code{inhibit-quit}
не-@code{nil}, вне конструкции. В результате выполнения вызвращается
значение последней формы @var{body}, если выхода не было, и @code{nil}
если был.

@c This macro executes @var{body} forms in sequence, but allows quitting, at
@c least locally, within @var{body} even if @code{inhibit-quit} was
@c non-@code{nil} outside this construct.  It returns the value of the
@c last form in @var{body}, unless exited by quitting, in which case
@c it returns @code{nil}.

Если @code{inhibit-quit} @code{nil} при входе в @code{with-local-quit},
макрос просто выполняет тело @var{body}. Но если, @code{inhibit-quit}
не-@code{nil} (то есть обычный выход отложен), не-@code{nil}
@code{quit-flag} запускает специальный тип локального выхода. При таком
выходе завершается выполнение @var{body} и выполняется выход из @code{with-local-quit}
с @code{quit-flag} тоже не-@code{nil}, в результате чего будет
выполнен обычный выход, как только станет возможен. Если @code{quit-flag}
не-@code{nil} перед выполнением @var{body}, сразу выполняется локальный
выход и формы @var{body} не выполняются.

@c If @code{inhibit-quit} is @code{nil} on entry to @code{with-local-quit},
@c it only executes the @var{body}, and setting @code{quit-flag} causes
@c a normal quit.  However, if @code{inhibit-quit} is non-@code{nil} so
@c that ordinary quitting is delayed, a non-@code{nil} @code{quit-flag}
@c triggers a special kind of local quit.  This ends the execution of
@c @var{body} and exits the @code{with-local-quit} body with
@c @code{quit-flag} still non-@code{nil}, so that another (ordinary) quit
@c will happen as soon as that is allowed.  If @code{quit-flag} is
@c already non-@code{nil} at the beginning of @var{body}, the local quit
@c happens immediately and the body doesn't execute at all.

Макрос преимущественно используется в функциях, которые могут
вызываться из таймеров, фильтров процессов (process filters),
и стражей процессов (process sentinels), @code{pre-command-hook},
@code{post-command-hook}, и других местах где @code{inhibit-quit}
обычно равен @code{t}.

@c This macro is mainly useful in functions that can be called from
@c timers, process filters, process sentinels, @code{pre-command-hook},
@c @code{post-command-hook}, and other places where @code{inhibit-quit} is
@c normally bound to @code{t}.
@end defmac

@deffn Command keyboard-quit
Функция сигнализирует @code{quit} услоивие с помощью @code{(signal 'quit nil)}.
Имеено это выполняет выход. (См. @code{signal} в @ref{Errors}.)

@c This function signals the @code{quit} condition with @code{(signal 'quit
@c nil)}.  This is the same thing that quitting does.  (See @code{signal}
@c in @ref{Errors}.)
@end deffn

  Можно определить комбинцию отличную от @kbd{C-g} для выхода.
См. функцию @code{set-input-mode} в @ref{Input Modes}.
  
@c   You can specify a character other than @kbd{C-g} to use for quitting.
@c See the function @code{set-input-mode} in @ref{Input Modes}.

@node Prefix Command Arguments
@section Префикс Аргументы Команды
@c @section Prefix Command Arguments
@cindex prefix argument
@cindex raw prefix argument
@cindex numeric prefix argument

  Большинство команд Emacs может использовать @dfn{префикс аргумент}
(@dfn{prefix argument}), который является числом заданным до команды.
(Не стоит путать префикс аругменты с префикс ключами). Префикс аргумент всегда
имеет значение, которое может быть @code{nil}, означающее, что
префикс аргумента нет. Команда может использовать префикс аргумент или
игнорировать его.

@c   Most Emacs commands can use a @dfn{prefix argument}, a number
@c specified before the command itself.  (Don't confuse prefix arguments
@c with prefix keys.)  The prefix argument is at all times represented by a
@c value, which may be @code{nil}, meaning there is currently no prefix
@c argument.  Each command may use the prefix argument or ignore it.

  Есть два представления префикс аргумента @dfn{сырое} (@dfn{raw})
(прим. будем использовать @emph{raw}) и @dfn{числовое} (@dfn{numeric}).
Командный цикл для себя использует raw представление, и его же
хранят Lisp соответствующие переменные, но команды могут запросить любой
вариант представления.
  
@c   There are two representations of the prefix argument: @dfn{raw} and
@c @dfn{numeric}.  The editor command loop uses the raw representation
@c internally, and so do the Lisp variables that store the information, but
@c commands can request either representation.

  Возможные значения raw префикс аргумента представлены ниже:
  @c Here are the possible values of a raw prefix argument:

@itemize @bullet
@item
@code{nil}, означает, что префикс аргумента нет. Числовое значение
будет 1, но команды использующие числовое значение могут отличать @code{nil}
и целое 1.

@c @code{nil}, meaning there is no prefix argument.  Its numeric value is
@c 1, but numerous commands make a distinction between @code{nil} and the
@c integer 1.

@item
Целое, которое в числовом виде будет этим же числом.
@c An integer, which stands for itself.

@item
Список целых. Данная форма префикс аргумента является результатом
нажатия @kbd{C-u} один или более раз, без ввода числа. Числовым
значением будет числов в списки, но некоторые команды могут
отличать такие списки от одиночных целых.

@c A list of one element, which is an integer.  This form of prefix
@c argument results from one or a succession of @kbd{C-u}s with no
@c digits.  The numeric value is the integer in the list, but some
@c commands make a distinction between such a list and an integer alone.

@item
Символ @code{-}. Что является индикатором того, что были введены
@kbd{M--} или @kbd{C-u -} без последующих цифр. Эквивалентное числовое
значение @minus{}1, но некоторые команды могут отличать @minus{}1 и
символ @code{-}.

@c The symbol @code{-}.  This indicates that @kbd{M--} or @kbd{C-u -} was
@c typed, without following digits.  The equivalent numeric value is
@c @minus{}1, but some commands make a distinction between the integer
@c @minus{}1 and the symbol @code{-}.
@end itemize

Проилистрировать возможности можно примерами вызова следующий функции
с разными префиксами:
@c We illustrate these possibilities by calling the following function with
@c various prefixes:

@example
@group
(defun display-prefix (arg)
  "Display the value of the raw prefix arg."
  (interactive "P")
  (message "%s" arg))
@end group
@end example

@noindent
Результаты вызова @code{display-prefix} с разными raw префикс аргументами:
@c Here are the results of calling @code{display-prefix} with various
@c raw prefix arguments:

@example
        M-x display-prefix  @print{} nil

C-u     M-x display-prefix  @print{} (4)

C-u C-u M-x display-prefix  @print{} (16)

C-u 3   M-x display-prefix  @print{} 3

M-3     M-x display-prefix  @print{} 3      ; @r{(Same as @code{C-u 3}.)}

C-u -   M-x display-prefix  @print{} -

M--     M-x display-prefix  @print{} -      ; @r{(Same as @code{C-u -}.)}

C-u - 7 M-x display-prefix  @print{} -7

M-- 7   M-x display-prefix  @print{} -7     ; @r{(Same as @code{C-u -7}.)}
@end example

  Emacs использует две переменные дял хранения префикс аргумента:
@code{prefix-arg} и @code{current-prefix-arg}. Команды, такие
как @code{universal-argument}, устанавливающие префикс аргументы для
других команд, хранят их в @code{prefix-arg}. Переменная
@code{current-prefix-arg} используется для передачи аргумента в текущую
команду, поэтому ее установка не влияет на префикс аргументы следующих команд.

@c   Emacs uses two variables to store the prefix argument:
@c @code{prefix-arg} and @code{current-prefix-arg}.  Commands such as
@c @code{universal-argument} that set up prefix arguments for other
@c commands store them in @code{prefix-arg}.  In contrast,
@c @code{current-prefix-arg} conveys the prefix argument to the current
@c command, so setting it has no effect on the prefix arguments for future
@c commands.

  Обычно, в команде определяется какое представление использовать для
префикс аргумента, числовое или raw, в спецификации @code{ineractive}.
(@xref{Using Interactive}.) Кроме того функции могут обращаться к префикс
аргументу напрямую через переменную @code{current-prefix-arg}, но такой
способ менее ясный.

@c   Normally, commands specify which representation to use for the prefix
@c argument, either numeric or raw, in the @code{interactive} specification.
@c (@xref{Using Interactive}.)  Alternatively, functions may look at the
@c value of the prefix argument directly in the variable
@c @code{current-prefix-arg}, but this is less clean.

@defun prefix-numeric-value arg
Функция возвращает числовое значение для корректного raw префикс аргумента,
@var{arg}. Аргумент моежт быть символом, числом, или списком.
Если значение @code{nil}, возаращается 1, если @code{-}, возвращается
@minus{}1, если число, возвращается само число, если список возвращается
@sc{car} списка(которое должно быть числом).

@c This function returns the numeric meaning of a valid raw prefix argument
@c value, @var{arg}.  The argument may be a symbol, a number, or a list.
@c If it is @code{nil}, the value 1 is returned; if it is @code{-}, the
@c value @minus{}1 is returned; if it is a number, that number is returned;
@c if it is a list, the @sc{car} of that list (which should be a number) is
@c returned.
@end defun

@defvar current-prefix-arg
Переменная хранит raw префикс аргумент для @emph{текущей} команды.
Команда можте обращаться к переменной напряму, но как правило
используется спецификация interactive @code{(interactive "P")}.

@c This variable holds the raw prefix argument for the @emph{current}
@c command.  Commands may examine it directly, but the usual method for
@c accessing it is with @code{(interactive "P")}.
@end defvar

@defvar prefix-arg
Значение переменной хранит raw префикс аргумент для @emph{следующей}
команды редактирования. Эту переменную устанавливают команды, задающие префикс аргумент
для следующей команды, такие как @code{universal-argument}.

@c The value of this variable is the raw prefix argument for the
@c @emph{next} editing command.  Commands such as @code{universal-argument}
@c that specify prefix arguments for the following command work by setting
@c this variable.
@end defvar

@defvar last-prefix-arg
raw префикс аргумент используемый предыдущей командой.
@c The raw prefix argument value used by the previous command.
@end defvar

  Следующие команды задают префикс аргумент для следующей команды.
Не стоит их использоват для других целей.

@c   The following commands exist to set up prefix arguments for the
@c following command.  Do not call them for any other reason.

@deffn Command universal-argument
Команда считывает ввода и задает префикс аргумент для следующей
команды. Эту команду стоит вызывать, только если точно знаешь, что делаешь.

@c This command reads input and specifies a prefix argument for the
@c following command.  Don't call this command yourself unless you know
@c what you are doing.
@end deffn

@deffn Command digit-argument arg
Команда добавляет префикс аргумент для следующей команды. Аргумент @var{arg}
задает raw значение, как если бы это значение было перед командой.
Эту команду стоит вызывать, только если точно знаешь, что делаешь.

@c This command adds to the prefix argument for the following command.  The
@c argument @var{arg} is the raw prefix argument as it was before this
@c command; it is used to compute the updated prefix argument.  Don't call
@c this command yourself unless you know what you are doing.
@end deffn

@deffn Command negative-argument arg
Команда добавляет числовой аргумент к следующей команде.
Аргумент @var{arg} raw префикс аргумент, как если бы он был
перед командой. Если аргумент числовой, то берется его отрицание.
Эту команду стоит вызывать, только если точно знаешь, что делаешь.

@c This command adds to the numeric argument for the next command.  The
@c argument @var{arg} is the raw prefix argument as it was before this
@c command; its value is negated to form the new prefix argument.  Don't
@c call this command yourself unless you know what you are doing.
@end deffn

@node Recursive Editing
@section Рекурсивное Редактирование
@c @section Recursive Editing
@cindex recursive command loop
@cindex recursive editing level
@cindex command loop, recursive

  Командный цикл Emacs запускается автоматически при старте Emacs.
Этот вехний уровень выполнения работает на протяжении все работы Emacs.
Lisp программы тоже могут выполнять командный цикл. Поскольку может
быть больше одного командного цикла, такую ситуацию будем называть
@dfn{рекурсивное редактирование} (@dfn{recursive editing}). Рекурсивное
редактирование приостанавливает вызвавшую его команду и позволяет
пользователю выполнить произвольное редактирование перед возобновлением
команды.

@c   The Emacs command loop is entered automatically when Emacs starts up.
@c This top-level invocation of the command loop never exits; it keeps
@c running as long as Emacs does.  Lisp programs can also invoke the
@c command loop.  Since this makes more than one activation of the command
@c loop, we call it @dfn{recursive editing}.  A recursive editing level has
@c the effect of suspending whatever command invoked it and permitting the
@c user to do arbitrary editing before resuming that command.

  Команды доступные при рекурсивном редактировании теже, что и команды
для командного цикла верхнего уровня и определяеются в клавиатурных раскладках.
Только несколько специальных команд выполяют выход из рекурсивного
редактирования; другие возвращают на тот же уровень редактирования
при завершении. (Специальные команды для выхода доступны всегда, но
они ничего не делают, когда рекурсивного редактирования нет.)

@c   The commands available during recursive editing are the same ones
@c available in the top-level editing loop and defined in the keymaps.
@c Only a few special commands exit the recursive editing level; the others
@c return to the recursive editing level when they finish.  (The special
@c commands for exiting are always available, but they do nothing when
@c recursive editing is not in progress.)

  Все командные цикл, включая рекурсивные, настравивают обработку универальной
ошибки, чтобы ошибки возникшие при выполнении команды не приводили
к завершению текущего командного цикла.

@c   All command loops, including recursive ones, set up all-purpose error
@c handlers so that an error in a command run from the command loop will
@c not exit the loop.

@cindex minibuffer input
  Ввод в мини-буфере является особым видом рекурсивного редактирования.
Он имеет несколько специальных методов, таких как включение отображения
минибуфера в окне минибуфера, но их меньше, чем можно предположить.
Некоторые ключи (клавиши) работают по другому в минибуфере, но причина
тут в использовании локальной раскладки минибуфера, если переключить
окно, команды станут обычными для Emacs.

@c   Minibuffer input is a special kind of recursive editing.  It has a few
@c special wrinkles, such as enabling display of the minibuffer and the
@c minibuffer window, but fewer than you might suppose.  Certain keys
@c behave differently in the minibuffer, but that is only because of the
@c minibuffer's local map; if you switch windows, you get the usual Emacs
@c commands.

@cindex @code{throw} example
@kindex exit
@cindex exit recursive editing
@cindex aborting
  Чтобы запустить рекурсивное редактирование нужно вызвать функцию
@code{recursive-edit}. Функция содержит командный цикл, а так же в ней
есть вызовы @code{catch} с тегом @code{exti}, что позволяет выйти
из рекурсивного редактирования подняв исключение (throwing) @code{exit}
(@pxref{Catch and Throw}). Если бросить(throwing) значение отличное
от @code{t}, @code{recursive-edit} просто выполнит возврат в функцию
ее вызвавшую. Команда @kbd{C-M-c} (@code{exit-recursive-edit}) так
и делает. Бросание(throwing) @code{t}, вызывает выход из @code{recursive-edit},
и управление возвращается в командный цикл уровнем выше. Такое
действие называется @dfn{прерывание} (@dfn{aborting}), и делается
с помощью @kbd{C-]} (@code{abort-recursive-edit}).

@c   To invoke a recursive editing level, call the function
@c @code{recursive-edit}.  This function contains the command loop; it also
@c contains a call to @code{catch} with tag @code{exit}, which makes it
@c possible to exit the recursive editing level by throwing to @code{exit}
@c (@pxref{Catch and Throw}).  If you throw a value other than @code{t},
@c then @code{recursive-edit} returns normally to the function that called
@c it.  The command @kbd{C-M-c} (@code{exit-recursive-edit}) does this.
@c Throwing a @code{t} value causes @code{recursive-edit} to quit, so that
@c control returns to the command loop one level up.  This is called
@c @dfn{aborting}, and is done by @kbd{C-]} (@code{abort-recursive-edit}).

  Большинство приложений не должны использовать рекурсивное редактирование,
за исключением использования минибуфера. Как правило для пользователя
удобнее когда временно меняется основной режим текущего буфера на специальный
режим, который должен иметь команду для возврату к предыдущему режиму редактирования.
(Команда @kbd{e} в Rmail использует эту технику.) Или, если нужно дать пользователю
другой текст для рекурсивного редактирования, создать и выбрать другой буфер
в специальном режиме. В этом режиме, нужно определить команду для завершения
работы и возврата в предыдущий буфер. (Так делает команда @kbd{m} в Rmail).

@c   Most applications should not use recursive editing, except as part of
@c using the minibuffer.  Usually it is more convenient for the user if you
@c change the major mode of the current buffer temporarily to a special
@c major mode, which should have a command to go back to the previous mode.
@c (The @kbd{e} command in Rmail uses this technique.)  Or, if you wish to
@c give the user different text to edit recursively, create and select
@c a new buffer in a special mode.  In this mode, define a command to
@c complete the processing and go back to the previous buffer.  (The
@c @kbd{m} command in Rmail does this.)

  Рекурсивное редактирование полезно при отладке. Можно вставить
@code{debug} в определение функции как вид точки остановки, в результате
можно будет изучить состояние системы когда функция достигнет этой точки.
@code{debug} вызывает рекурсивное редактирование, и кроме того
предоставляет дополнительные функции отладки.

@c Recursive edits are useful in debugging.  You can insert a call to
@c @code{debug} into a function definition as a sort of breakpoint, so that
@c you can look around when the function gets there.  @code{debug} invokes
@c a recursive edit but also provides the other features of the debugger.

  Рекурсивное редактирование используется, если ввести @kbd{C-r}
в @code{query-replace} или использоавть @kbd{C-x q} в (@kbd{kbd-macro-query}).

@c   Recursive editing levels are also used when you type @kbd{C-r} in
@c @code{query-replace} or use @kbd{C-x q} (@code{kbd-macro-query}).

@deffn Command recursive-edit
@cindex suspend evaluation
Функция вызывает командный цикл редактора. Данная функция вызывается
атоматически при инициализации Emacs, после чего пользователь
может начать редактирование. Когда функция вызывается из Lisp программы,
создается еще один уровень рекурсивного редактирования.

@c This function invokes the editor command loop.  It is called
@c automatically by the initialization of Emacs, to let the user begin
@c editing.  When called from a Lisp program, it enters a recursive editing
@c level.

Если текущй буфер отличается от буфера выбранного окна,
@code{recursive-edit} сохраняет и восстанавливает текущий буфер.
Иначе, если переключить буферы, буфер в который будет выполнено
переключение, будет текущим после возврата из @code{recursive-edit}.

@c If the current buffer is not the same as the selected window's buffer,
@c @code{recursive-edit} saves and restores the current buffer.  Otherwise,
@c if you switch buffers, the buffer you switched to is current after
@c @code{recursive-edit} returns.

В следующем примере, функция @code{simple-rec} сначал передвигает
курсор на одно слово вперед, затем запускает рекурсивное редактирование,
печатает сообщение в эхо область. Пользователь может пото выполнить
произвольное редактирование, после чего нажать @kbd{C-M-c} и вернуться
к выполнению @code{simple-rec}.

@c In the following example, the function @code{simple-rec} first
@c advances point one word, then enters a recursive edit, printing out a
@c message in the echo area.  The user can then do any editing desired, and
@c then type @kbd{C-M-c} to exit and continue executing @code{simple-rec}.

@example
(defun simple-rec ()
  (forward-word 1)
  (message "Recursive edit in progress")
  (recursive-edit)
  (forward-word 1))
     @result{} simple-rec
(simple-rec)
     @result{} nil
@end example
@end deffn

@deffn Command exit-recursive-edit
Функция выходит из текущего рекурсивного редактирования (
включая ввод в мини-буфере). Данная функция (прим. видимо)
аналогична @code{(throw 'exit nil)}.

@c This function exits from the innermost recursive edit (including
@c minibuffer input).  Its definition is effectively @code{(throw 'exit
@c nil)}.
@end deffn

@deffn Command abort-recursive-edit
Функция выходит из команды запросившей текущее рекурсивное редактирование
(включая ввод в минибуфере), путем отправки сигнала @code{quit}
после выхода из рекурсивного редактирования. Функция аналогична
@code{(throw 'exit t)}. @xref{Quitting}.

@c This function aborts the command that requested the innermost recursive
@c edit (including minibuffer input), by signaling @code{quit}
@c after exiting the recursive edit.  Its definition is effectively
@c @code{(throw 'exit t)}.  @xref{Quitting}.
@end deffn

@deffn Command top-level
Функция заканчивает рекурсивное редактирование на всех уровнях, кроме верхнего.
Функция не возвращает значения, а просто выполняет возврат из любого вычисления
в главный командный цикл.

@c This function exits all recursive editing levels; it does not return a
@c value, as it jumps completely out of any computation directly back to
@c the main command loop.
@end deffn

@defun recursion-depth
Функция возвращает текущую глубину рекурсивного редактирования. Если
активного рекурсивного редактирования нет, возвращается 0.

@c This function returns the current depth of recursive edits.  When no
@c recursive edit is active, it returns 0.
@end defun

@node Disabling Commands
@section Отключение Команд
@c @section Disabling Commands
@cindex disabled command

  @dfn{Отключение команды}(@dfn{disabling a command}) добавляет
ограничение для команду, требуещее дополнительно подтверждения от
пользователя, чтобы ее выполнить. Отключение используется для
команд, которые могут запутать начинающего пользователя, и являются
защитой от их случайного использования.

@c   @dfn{Disabling a command} marks the command as requiring user
@c confirmation before it can be executed.  Disabling is used for commands
@c which might be confusing to beginning users, to prevent them from using
@c the commands by accident.

@kindex disabled
  На низком уровне отключение команд, заключается в добавлении не-@code{nil}
свойства @code{disabled} для Lisp символа(объекта) команды. Такие
свойства как правило устанавливаются в пользовательском файле
инициализации(init file) (@pxref{Init File}), используя следующие
выражения:

@c   The low-level mechanism for disabling a command is to put a
@c non-@code{nil} @code{disabled} property on the Lisp symbol for the
@c command.  These properties are normally set up by the user's
@c init file (@pxref{Init File}) with Lisp expressions such as this:

@example
(put 'upcase-region 'disabled t)
@end example

@noindent
Для некоторых команд, такие свойства заданы по умолчанию
(и в файле инициализации их можно удалить).

@c For a few commands, these properties are present by default (you can
@c remove them in your init file if you wish).

  Если значение свойства @code{disabled} строка, значение будет
включено в сообщение, о том что команда отключена. Например:

@c   If the value of the @code{disabled} property is a string, the message
@c saying the command is disabled includes that string.  For example:

@example
(put 'delete-region 'disabled
     "Text deleted this way cannot be yanked back!\n")
@end example

  Подробное описание, того что
присходит при интерактивном вызове отключенной команды
можно посмотреть в @ref{Disabling,,, emacs, The GNU Emacs Manual}.
Отключение программы не вляет на ее вызов из Lisp кода.
  
@c   @xref{Disabling,,, emacs, The GNU Emacs Manual}, for the details on
@c what happens when a disabled command is invoked interactively.
@c Disabling a command has no effect on calling it as a function from Lisp
@c programs.

@deffn Command enable-command command
Функция включает команду(символ), то есть позволяет ей вызываться
интерактивно без дополнительного подтверждения от пользователя.
Функция изменяет файл инициализации(@pxref{Init File}) пользователя, так что
разрешение сохраняется для последующих сессий.

@c Allow @var{command} (a symbol) to be executed without special
@c confirmation from now on, and alter the user's init file (@pxref{Init
@c File}) so that this will apply to future sessions.
@end deffn

@deffn Command disable-command command
Функция отключает команду @var{command}, то есть от пользователя
будет требоваться подтверждение, при интерактивном вызове команды.
Функция изменяет файл инициализации, сохраняя изменение для последующих
сессии.

@c Require special confirmation to execute @var{command} from now on, and
@c alter the user's init file so that this will apply to future sessions.
@end deffn

@defvar disabled-command-function
Значение переменной должно быть функцией. Данная функция вызывается,
вместо отключенных функций при их интерактивном вызове. Функция может использовать
@code{this-command-keys} , чтобы определить, что пользователь ввел
для вызова команды, и таким образом определить вызванную пользователем
команду.

@c The value of this variable should be a function.  When the user
@c invokes a disabled command interactively, this function is called
@c instead of the disabled command.  It can use @code{this-command-keys}
@c to determine what the user typed to run the command, and thus find the
@c command itself.

Значение может @code{nil}, тогда все команды будут работать обычным
образом, даже если они отключены.

@c The value may also be @code{nil}.  Then all commands work normally,
@c even disabled ones.

По умолчанию, значением является функции, спрашивающая пользователя
желает ли он продолжить.

@c By default, the value is a function that asks the user whether to
@c proceed.
@end defvar

@node Command History
@section Инстория Команд
@c @section Command History
@cindex command history
@cindex complex command
@cindex history of commands

  Командный цикл хранит историю сложных команд, которые были
выполнены, что позволяет предоставить удобную возможность для
их повторного вызова. @dfn{Сложная команда} (@dfn{complex command}), та
для которой при интерактивном вызове было считывание из минибуфера.
Сюда входят команды @kbd{M-x} (@code{execute-extended-command}),
@kbd{M-:} (@code{eval-expression}), и любая другая команда,
@code{interactive} спецификация для которой подразумевает
чтение аргумента из минибуфера. При этом явное использование
минибуфера при выполнении команды не превращает ее в сложную.

@c   The command loop keeps a history of the complex commands that have
@c been executed, to make it convenient to repeat these commands.  A
@c @dfn{complex command} is one for which the interactive argument reading
@c uses the minibuffer.  This includes any @kbd{M-x} command, any
@c @kbd{M-:} command, and any command whose @code{interactive}
@c specification reads an argument from the minibuffer.  Explicit use of
@c the minibuffer during the execution of the command itself does not cause
@c the command to be considered complex.

@defvar command-history
Переменная хранит список истории сложным команд, каждая из которых
представлена в виде формы для вычисления. Переменная накапливает
значения в течении всей сессии редактирования, но при достижении
максимального размера (@pxref{Minibuffer History}), самые старые команды
начинают удаляться при поступлении новых.

@c This variable's value is a list of recent complex commands, each
@c represented as a form to evaluate.  It continues to accumulate all
@c complex commands for the duration of the editing session, but when it
@c reaches the maximum size (@pxref{Minibuffer History}), the oldest
@c elements are deleted as new ones are added.

@example
@group
command-history
@result{} ((switch-to-buffer "chistory.texi")
    (describe-key "^X^[")
    (visit-tags-table "~/emacs/src/")
    (find-tag "repeat-complex-command"))
@end group
@end example
@end defvar

  Список истории это особый случай истории минибуфера (@pxref{Minibuffer History}),
с необычным свойством: элементы списка выражения, а не строки.

@c   This history list is actually a special case of minibuffer history
@c (@pxref{Minibuffer History}), with one special twist: the elements are
@c expressions rather than strings.

  Есть ряд команд предназначенных для редактирования и повторного
вызова предыдущих команд. Команды @code{repeat-complex-command},
и @code{list-command-history} описаны в руководстве пользователя
(@pxref{Repetition,,, emacs, The GNU Emacs Manual}). В самом минибуфере,
доступны обычные команды истории минибуфера.

@c   There are a number of commands devoted to the editing and recall of
@c previous commands.  The commands @code{repeat-complex-command}, and
@c @code{list-command-history} are described in the user manual
@c (@pxref{Repetition,,, emacs, The GNU Emacs Manual}).  Within the
@c minibuffer, the usual minibuffer history commands are available.

@node Keyboard Macros
@section Клавиатурные Макросы
@c @section Keyboard Macros
@cindex keyboard macros

  @dfn{Клавиатурный макрос} (@dfn{keyboard macro}) это записанная
последовательность событий ввода, которая может расматриваться
как команда и использоваться при определении клавиатурной комбинации
(прим. то есть для нее может быть назначена своя комбинация). В Lisp
макрос представляется в строки или вектора содержащего события. Клавиатурные
макросы и Lisp макросы(@pxref{Macros}) это разные вещи и их не стоит путать.

@c   A @dfn{keyboard macro} is a canned sequence of input events that can
@c be considered a command and made the definition of a key.  The Lisp
@c representation of a keyboard macro is a string or vector containing the
@c events.  Don't confuse keyboard macros with Lisp macros
@c (@pxref{Macros}).

@defun execute-kbd-macro kbdmacro &optional count loopfunc
Функция выполняет @var{kbdmacro} как последовательность событий. Если
@var{kdbmacro} строка или вектор, тогда события выполняются, как
если бы их вводил пользователь. @emph{Не} предполагается,
что последовательность будет содержать одно события, как правило
событий несколько.

@c This function executes @var{kbdmacro} as a sequence of events.  If
@c @var{kbdmacro} is a string or vector, then the events in it are executed
@c exactly as if they had been input by the user.  The sequence is
@c @emph{not} expected to be a single key sequence; normally a keyboard
@c macro definition consists of several key sequences concatenated.

Если @var{kdbmacro} символ, тогда для него берется определение функции.
Если так хранится другой символ, для него берется значение из ячейки функции,
и так пока не будет получена строка или вектор. Если в результате
будет получена не строка или вектор, сигнализируется ошибка.

@c If @var{kbdmacro} is a symbol, then its function definition is used in
@c place of @var{kbdmacro}.  If that is another symbol, this process repeats.
@c Eventually the result should be a string or vector.  If the result is
@c not a symbol, string, or vector, an error is signaled.

Аргумент @var{count} задает количество повторений @var{kdbmacro}.
Если @var{count} не задано или @code{nil}, макрос выполняется один раз.
Если значение 0, макрос будет выполняться пока не 
возникнет ошибка или будет неудачный поиск.

@c The argument @var{count} is a repeat count; @var{kbdmacro} is executed that
@c many times.  If @var{count} is omitted or @code{nil}, @var{kbdmacro} is
@c executed once.  If it is 0, @var{kbdmacro} is executed over and over until it
@c encounters an error or a failing search.

Если @var{loopfun} не-@code{nil}, то значение параметра должно
быть функцией. Она будет вызываться перед каждым вызовом макроса.
Если @var{loopfunc} возвратит @code{nil}, тогда вызовы макроса
прекратятся.

@c If @var{loopfunc} is non-@code{nil}, it is a function that is called,
@c without arguments, prior to each iteration of the macro.  If
@c @var{loopfunc} returns @code{nil}, then this stops execution of the macro.

Пример использования @code{execute-kdb-macro} описан в @xref{Reading One Event}.
@c @xref{Reading One Event}, for an example of using @code{execute-kbd-macro}.
@end defun

@defvar executing-kbd-macro
Переменная содержит строку или вектор, которые определяют выполняемый
в данный момент макрос. Если макрос не выполняется значение @code{nil}.
Команды могут обращаться к данной переменной, чтобы изменить свое
поведение, если вызываются из макросов. Данную переменную не стоит
устанавливать самостоятельно.

@c This variable contains the string or vector that defines the keyboard
@c macro that is currently executing.  It is @code{nil} if no macro is
@c currently executing.  A command can test this variable so as to behave
@c differently when run from an executing macro.  Do not set this variable
@c yourself.
@end defvar

@defvar defining-kbd-macro
Переменная не-@code{nil}, только если выполняется определение,
клавиатурного макроса. Команды могут проверить значение данной
переменной, чтобы выполнить определенные действия для случая их
вызова при определении макроса. Знчение @code{appedn}, пока
выполняется добавление к определению существующего макроса.
Данную переменную устанавливают команды @code{start-kbd-macro},
@code{kmacro-start-macro}, @code{end-kbd-macro}. Самостоятельно
данную переменную устанавливать не стоит.

@c This variable is non-@code{nil} if and only if a keyboard macro is
@c being defined.  A command can test this variable so as to behave
@c differently while a macro is being defined.  The value is
@c @code{append} while appending to the definition of an existing macro.
@c The commands @code{start-kbd-macro}, @code{kmacro-start-macro} and
@c @code{end-kbd-macro} set this variable---do not set it yourself.

Переменная всегда локальна для текущего терминала и не может
быть локальной для буфера. @xref{Multiple Terminals}.

@c The variable is always local to the current terminal and cannot be
@c buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar last-kbd-macro
Переменная хранит определение предыдущего определенного макроса.
Значение строка, вектор или @code{nil}.

@c This variable is the definition of the most recently defined keyboard
@c macro.  Its value is a string or vector, or @code{nil}.

Переменная всегда локальна для текущего терминала и не может
быть локальной для буфера. @xref{Multiple Terminals}.

@c The variable is always local to the current terminal and cannot be
@c buffer-local.  @xref{Multiple Terminals}.
@end defvar

@defvar kbd-macro-termination-hook
Обыкновенный перехватчик, который запускается когда завешается клавиатурный
макрос, в не зависимости от причины завершения (достижение конца или возникновение
ошибки).

@c This normal hook is run when a keyboard macro terminates, regardless
@c of what caused it to terminate (reaching the macro end or an error
@c which ended the macro prematurely).
@end defvar
